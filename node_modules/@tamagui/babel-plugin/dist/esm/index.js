import { basename } from "path";
import generator from "@babel/generator";
import { declare } from "@babel/helper-plugin-utils";
import template from "@babel/template";
import * as t from "@babel/types";
import { simpleHash } from "@tamagui/simple-hash";
import {
  createExtractor,
  getPragmaOptions,
  isSimpleSpread,
  literalToAst
} from "@tamagui/static";
const importNativeView = template(`
import { View as __ReactNativeView, Text as __ReactNativeText } from 'react-native';
`);
const importStyleSheet = template(`
import { StyleSheet as ReactNativeStyleSheet } from 'react-native';
`);
process.env.TAMAGUI_TARGET = process.env.TAMAGUI_TARGET || "native";
const extractor = createExtractor();
var src_default = declare(function snackBabelPlugin(api, options) {
  api.assertVersion(7);
  return {
    name: "tamagui",
    visitor: {
      Program: {
        enter(root) {
          var _a, _b, _c, _d, _e;
          let sourcePath = this.file.opts.filename;
          if ((_a = process.env.SOURCE_ROOT) == null ? void 0 : _a.endsWith("ios")) {
            sourcePath = sourcePath.replace("/ios", "");
          }
          let hasImportedView = false;
          const sheetStyles = {};
          const sheetIdentifier = root.scope.generateUidIdentifier("sheet");
          const firstComment = ((_e = (_d = (_c = (_b = root.node.body[0]) == null ? void 0 : _b.leadingComments) == null ? void 0 : _c[0]) == null ? void 0 : _d.value) == null ? void 0 : _e.trim()) ?? "";
          const { shouldPrintDebug, shouldDisable } = getPragmaOptions({
            disableCommentCheck: true,
            source: firstComment,
            path: sourcePath
          });
          if (shouldDisable) {
            return;
          }
          function addSheetStyle(style, node) {
            const styleIndex = `${Object.keys(sheetStyles).length}`;
            let key = `${styleIndex}`;
            if (process.env.NODE_ENV === "development") {
              const lineNumbers = node.loc ? node.loc.start.line + (node.loc.start.line !== node.loc.end.line ? `-${node.loc.end.line}` : "") : "";
              key += `:${basename(sourcePath)}:${lineNumbers}`;
            }
            sheetStyles[key] = style;
            return readStyleExpr(key);
          }
          function readStyleExpr(key) {
            return template(`SHEET['KEY']`)({
              SHEET: sheetIdentifier.name,
              KEY: key
            })["expression"];
          }
          try {
            extractor.parseSync(root, {
              target: "native",
              shouldPrintDebug,
              importsWhitelist: ["constants.js", "colors.js"],
              deoptProps: /* @__PURE__ */ new Set([
                "focusStyle",
                "hoverStyle",
                "pressStyle",
                "pointerEvents"
              ]),
              extractStyledDefinitions: options.forceExtractStyleDefinitions,
              excludeProps: /* @__PURE__ */ new Set([
                "className",
                "userSelect",
                "whiteSpace",
                "textOverflow",
                "cursor",
                "contain"
              ]),
              ...options,
              // disable this extraction for now at least, need to figure out merging theme vs non-theme
              // because theme need to stay in render(), whereas non-theme can be extracted
              // for now just turn it off entirely at a small perf loss
              disableExtractInlineMedia: true,
              // disable extracting variables as no native concept of them (only theme values)
              disableExtractVariables: "theme",
              sourcePath,
              // disabling flattening for now
              // it's flattening a plain <Paragraph>hello</Paragraph> which breaks things because themes
              // thinking it's not really worth the effort to do much compilation on native
              // for now just disable flatten as it can only run in narrow places on native
              // disableFlattening: 'styled',
              getFlattenedNode({ isTextView }) {
                if (!hasImportedView) {
                  hasImportedView = true;
                  root.unshiftContainer("body", importNativeView());
                }
                return isTextView ? "__ReactNativeText" : "__ReactNativeView";
              },
              onExtractTag(props) {
                if (!props.isFlattened) {
                  return;
                }
                assertValidTag(props.node);
                const stylesExpr = t.arrayExpression([]);
                const finalAttrs = [];
                function addStyle(expr, key) {
                  if (props.isFlattened) {
                    stylesExpr.elements.push(expr);
                  } else {
                    finalAttrs.push(
                      t.jsxAttribute(
                        t.jsxIdentifier(`_style${key}`),
                        t.jsxExpressionContainer(expr)
                      )
                    );
                  }
                }
                for (const attr of props.attrs) {
                  switch (attr.type) {
                    case "style": {
                      const { themed, plain } = splitThemeStyles(attr.value);
                      for (const key in themed) {
                        finalAttrs.push(
                          t.jsxAttribute(
                            t.jsxIdentifier(key),
                            t.stringLiteral(themed[key])
                          )
                        );
                      }
                      const ident = addSheetStyle(plain, props.node);
                      addStyle(ident, simpleHash(JSON.stringify(plain)));
                      break;
                    }
                    case "ternary": {
                      const { consequent, alternate } = attr.value;
                      const cons = addSheetStyle(consequent, props.node);
                      const alt = addSheetStyle(alternate, props.node);
                      const styleExpr = t.conditionalExpression(
                        attr.value.test,
                        cons,
                        alt
                      );
                      addStyle(
                        styleExpr,
                        simpleHash(JSON.stringify({ consequent, alternate }))
                      );
                      break;
                    }
                    case "attr": {
                      if (t.isJSXSpreadAttribute(attr.value)) {
                        if (isSimpleSpread(attr.value)) {
                          stylesExpr.elements.push(
                            t.memberExpression(attr.value.argument, t.identifier("style"))
                          );
                        }
                      }
                      finalAttrs.push(attr.value);
                      break;
                    }
                  }
                }
                props.node.attributes = finalAttrs;
                if (props.isFlattened) {
                  props.node.attributes.push(
                    t.jsxAttribute(
                      t.jsxIdentifier("style"),
                      t.jsxExpressionContainer(
                        stylesExpr.elements.length === 1 ? stylesExpr.elements[0] : stylesExpr
                      )
                    )
                  );
                }
              }
            });
          } catch (err) {
            if (err instanceof Error) {
              let message = `${shouldPrintDebug === "verbose" ? err : err.message}`;
              if (message.includes("Unexpected return value from visitor method")) {
                message = "Unexpected return value from visitor method";
              }
              console.warn("Error in Tamagui parse, skipping", message, err.stack);
              return;
            }
          }
          if (!Object.keys(sheetStyles).length) {
            if (shouldPrintDebug) {
              console.log("END no styles");
            }
            return;
          }
          const sheetObject = literalToAst(sheetStyles);
          const sheetOuter = template("const SHEET = ReactNativeStyleSheet.create(null)")(
            {
              SHEET: sheetIdentifier.name
            }
          );
          sheetOuter.declarations[0].init.arguments[0] = sheetObject;
          root.unshiftContainer("body", sheetOuter);
          root.unshiftContainer("body", importStyleSheet());
          if (shouldPrintDebug) {
            console.log("\n -------- output code ------- \n");
            console.log(
              generator(root.parent).code.split("\n").filter((x) => !x.startsWith("//")).join("\n")
            );
          }
        }
      }
    }
  };
});
function assertValidTag(node) {
  var _a;
  if (node.attributes.find((x) => x.type === "JSXAttribute" && x.name.name === "style")) {
    if ((_a = process.env.DEBUG) == null ? void 0 : _a.startsWith("tamagui")) {
      console.warn("\u26A0\uFE0F Cannot pass style attribute to extracted style");
    }
  }
}
function splitThemeStyles(style) {
  const themed = {};
  const plain = {};
  for (const key in style) {
    const val = style[key];
    if (val && val[0] === "$") {
      themed[key] = val;
    } else {
      plain[key] = val;
    }
  }
  return { themed, plain };
}
export {
  src_default as default
};
//# sourceMappingURL=index.js.map
