import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import { useIsPresent } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import {
  Theme,
  composeEventHandlers,
  isWeb,
  styled,
  useAnimationDriver,
  useEvent,
  useThemeName
} from "@tamagui/core";
import { Dismissable } from "@tamagui/dismissable";
import { PortalItem } from "@tamagui/portal";
import { ThemeableStack } from "@tamagui/stacks";
import * as React from "react";
import {
  PanResponder
} from "react-native";
import { TOAST_NAME } from "./constants";
import { ToastAnnounce } from "./ToastAnnounce";
import {
  Collection,
  createToastContext,
  useToastProviderContext
} from "./ToastProvider";
import { VIEWPORT_PAUSE, VIEWPORT_RESUME } from "./ToastViewport";
const ToastImplFrame = styled(ThemeableStack, {
  name: "ToastImpl",
  focusable: true,
  variants: {
    unstyled: {
      false: {
        focusStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$borderColorHover"
        },
        backgroundColor: "$color6",
        borderRadius: "$10",
        paddingHorizontal: "$5",
        paddingVertical: "$2",
        marginHorizontal: "auto",
        marginVertical: "$1"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(
  TOAST_NAME,
  {
    onClose() {
    }
  }
);
const ToastImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      viewportName = "default",
      ...toastProps
    } = props;
    const isPresent = useIsPresent();
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React.useRef(0);
    const closeTimerRemainingTimeRef = React.useRef(duration);
    const closeTimerRef = React.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const viewport = React.useMemo(() => {
      return context.viewports[viewportName];
    }, [context.viewports, viewportName]);
    const handleClose = useEvent(() => {
      if (!isPresent) {
        return;
      }
      if (isWeb) {
        const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
        if (isFocusInToast)
          viewport == null ? void 0 : viewport.focus();
      }
      onClose();
    });
    const startTimer = React.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity)
          return;
        clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    const handleResume = React.useCallback(() => {
      startTimer(closeTimerRemainingTimeRef.current);
      onResume == null ? void 0 : onResume();
    }, [onResume, startTimer]);
    const handlePause = React.useCallback(() => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
      closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
      window.clearTimeout(closeTimerRef.current);
      onPause == null ? void 0 : onPause();
    }, [onPause]);
    React.useEffect(() => {
      if (!isWeb)
        return;
      if (viewport) {
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [viewport, duration, onPause, onResume, startTimer]);
    React.useEffect(() => {
      if (open && !context.isClosePausedRef.current) {
        startTimer(duration);
      }
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React.useMemo(() => {
      if (!isWeb)
        return null;
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    const isHorizontalSwipe = ["left", "right", "horizontal"].includes(
      context.swipeDirection
    );
    const driver = useAnimationDriver();
    if (!driver) {
      throw new Error("Must set animations in tamagui.config.ts");
    }
    const { useAnimatedNumber, useAnimatedNumberStyle } = driver;
    const animatedNumber = useAnimatedNumber(0);
    const AnimatedView = driver["NumberView"] ?? driver.View;
    const animatedStyles = useAnimatedNumberStyle(animatedNumber, (val) => {
      "worklet";
      return {
        transform: [isHorizontalSwipe ? { translateX: val } : { translateY: val }]
      };
    });
    const panResponder = React.useMemo(() => {
      return PanResponder.create({
        onMoveShouldSetPanResponder: (e, gesture) => {
          const shouldMove = shouldGrantGestureMove(context.swipeDirection, gesture);
          if (shouldMove) {
            onSwipeStart == null ? void 0 : onSwipeStart(e);
            return true;
          }
          return false;
        },
        onPanResponderGrant: (e) => {
          if (!isWeb) {
            handlePause == null ? void 0 : handlePause();
          }
        },
        onPanResponderMove: (e, gesture) => {
          const { x, y } = getGestureDistance(context.swipeDirection, gesture);
          const delta = { x, y };
          animatedNumber.setValue(isHorizontalSwipe ? x : y, { type: "direct" });
          if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
            onSwipeEnd == null ? void 0 : onSwipeEnd(e);
          }
          onSwipeMove == null ? void 0 : onSwipeMove(e);
        },
        onPanResponderEnd: (e, { dx, dy }) => {
          if (!isDeltaInDirection(
            { x: dx, y: dy },
            context.swipeDirection,
            context.swipeThreshold
          )) {
            if (!isWeb) {
              handleResume == null ? void 0 : handleResume();
            }
            onSwipeCancel == null ? void 0 : onSwipeCancel(e);
            animatedNumber.setValue(0, { type: "spring" });
          }
        }
      });
    }, [handlePause, handleResume]);
    const themeName = useThemeName();
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsx(PortalItem, { hostName: viewportName ?? "default", children: /* @__PURE__ */ jsx(
        ToastInteractiveProvider,
        {
          scope: __scopeToast,
          onClose: () => {
            handleClose();
          },
          children: /* @__PURE__ */ jsx(
            Dismissable,
            {
              onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
                if (!context.isFocusedToastEscapeKeyDownRef.current) {
                  handleClose();
                }
                context.isFocusedToastEscapeKeyDownRef.current = false;
              }),
              children: /* @__PURE__ */ jsx(Theme, { forceClassName: true, name: themeName, children: /* @__PURE__ */ jsx(
                AnimatedView,
                {
                  ...panResponder == null ? void 0 : panResponder.panHandlers,
                  style: [{ margin: "auto" }, animatedStyles],
                  children: /* @__PURE__ */ jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsx(
                    ToastImplFrame,
                    {
                      role: "status",
                      "aria-live": "off",
                      "aria-atomic": true,
                      "data-state": open ? "open" : "closed",
                      "data-swipe-direction": context.swipeDirection,
                      pointerEvents: "auto",
                      userSelect: "none",
                      ...toastProps,
                      ref: composedRefs,
                      ...isWeb && {
                        onKeyDown: composeEventHandlers(
                          props.onKeyDown,
                          (event) => {
                            if (event.key !== "Escape")
                              return;
                            onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
                            onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
                            if (!event.defaultPrevented) {
                              context.isFocusedToastEscapeKeyDownRef.current = true;
                              handleClose();
                            }
                          }
                        )
                      }
                    }
                  ) })
                }
              ) })
            }
          )
        },
        props.id
      ) })
    ] });
  }
);
ToastImpl.propTypes = {
  type(props) {
    if (props.type && !["foreground", "background"].includes(props.type)) {
      const error = `Invalid prop \`type\` supplied to \`${TOAST_NAME}\`. Expected \`foreground | background\`.`;
      return new Error(error);
    }
    return null;
  }
};
const isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right" || direction === "horizontal") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function getAnnounceTextContent(container) {
  if (!isWeb)
    return "";
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.toastAnnounceExclude === "";
      if (!isHidden) {
        if (isExcluded) {
          const altText = node.dataset.toastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
const GESTURE_GRANT_THRESHOLD = 10;
const shouldGrantGestureMove = (dir, { dx, dy }) => {
  if ((dir === "horizontal" || dir === "left") && dx < -GESTURE_GRANT_THRESHOLD) {
    return true;
  } else if ((dir === "horizontal" || dir === "right") && dx > GESTURE_GRANT_THRESHOLD) {
    return true;
  } else if ((dir === "vertical" || dir === "up") && dy > -GESTURE_GRANT_THRESHOLD) {
    return true;
  } else if ((dir === "vertical" || dir === "down") && dy < GESTURE_GRANT_THRESHOLD) {
    return true;
  }
  return false;
};
const getGestureDistance = (dir, { dx, dy }) => {
  let y = 0;
  let x = 0;
  if (dir === "horizontal")
    x = dx;
  else if (dir === "left")
    x = Math.min(0, dx);
  else if (dir === "right")
    x = Math.max(0, dx);
  else if (dir === "vertical")
    y = dy;
  else if (dir === "up")
    y = Math.min(0, dy);
  else if (dir === "down")
    y = Math.max(0, dy);
  return {
    x,
    y
  };
};
export {
  ToastImpl,
  ToastImplFrame,
  useToastInteractiveContext
};
//# sourceMappingURL=ToastImpl.js.map
