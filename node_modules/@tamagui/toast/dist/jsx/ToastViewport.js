import { AnimatePresence } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb, styled } from "@tamagui/core";
import { PortalHost } from "@tamagui/portal";
import { YStack } from "@tamagui/stacks";
import { VisuallyHidden } from "@tamagui/visually-hidden";
import * as React from "react";
import {
  Collection,
  useCollection,
  useToastProviderContext
} from "./ToastProvider";
const VIEWPORT_NAME = "ToastViewport";
const VIEWPORT_DEFAULT_HOTKEY = ["F8"];
const VIEWPORT_PAUSE = "toast.viewportPause";
const VIEWPORT_RESUME = "toast.viewportResume";
const ToastViewportWrapperFrame = styled(YStack, {
  name: "ViewportWrapper",
  variants: {
    unstyled: {
      false: {
        pointerEvents: "box-none",
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        position: isWeb ? "fixed" : "absolute",
        maxWidth: "100%",
        tabIndex: 0,
        zIndex: 1e5
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ToastViewportFrame = styled(YStack, {
  name: VIEWPORT_NAME,
  variants: {
    unstyled: {
      false: {
        pointerEvents: "box-none",
        position: isWeb ? "fixed" : "absolute",
        maxWidth: "100%"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const ToastViewport = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      name = "default",
      multipleToasts,
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const headFocusProxyRef = React.useRef(null);
    const tailFocusProxyRef = React.useRef(null);
    const wrapperRef = React.useRef(null);
    const ref = React.useRef(null);
    const onViewportChange = React.useCallback(
      (el) => {
        if (context.viewports[name] !== el)
          context.onViewportChange(name, el);
      },
      [name, context.viewports]
    );
    const composedRefs = useComposedRefs(forwardedRef, ref, onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    React.useEffect(() => {
      if (!isWeb)
        return;
      if (context.toastCount === 0)
        return;
      const handleKeyDown = (event) => {
        const isHotkeyPressed = hotkey.every(
          (key) => event[key] || event.code === key
        );
        if (isHotkeyPressed)
          ref.current?.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
      };
    }, [hotkey, context.toastCount]);
    React.useEffect(() => {
      if (!isWeb)
        return;
      if (context.toastCount === 0)
        return;
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(
            event.relatedTarget
          );
          if (isFocusMovingOutside)
            handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside)
            handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef, context.toastCount]);
    const getSortedTabbableCandidates = React.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    React.useEffect(() => {
      if (!isWeb)
        return;
      if (context.toastCount === 0)
        return;
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.current?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index = sortedCandidates.findIndex(
              (candidate) => candidate === focusedElement
            );
            if (focusFirst(sortedCandidates.slice(index + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (
                // @ts-ignore ali TODO type
                headFocusProxyRef.current?.focus()
              ) : (
                // @ts-ignore ali TODO type
                tailFocusProxyRef.current?.focus()
              );
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates, context.toastCount]);
    return <ToastViewportWrapperFrame
      ref={wrapperRef}
      role="region"
      aria-label={label.replace("{hotkey}", hotkeyLabel)}
      tabIndex={-1}
    >
      {hasToasts && <FocusProxy
        viewportName={name}
        ref={headFocusProxyRef}
        onFocusFromOutsideViewport={() => {
          const tabbableCandidates = getSortedTabbableCandidates({
            tabbingDirection: "forwards"
          });
          focusFirst(tabbableCandidates);
        }}
      />}
      {
        /**
        * tabindex on the the list so that it can be focused when items are removed. we focus
        * the list instead of the viewport so it announces number of items remaining.
        */
      }
      <Collection.Slot scope={__scopeToast}><ToastViewportFrame
        focusable={context.toastCount > 0}
        ref={composedRefs}
        {...viewportProps}
      ><PortalHost
        render={(children) => <AnimatePresence exitBeforeEnter={!multipleToasts}>{children}</AnimatePresence>}
        name={name ?? "default"}
      /></ToastViewportFrame></Collection.Slot>
      {hasToasts && <FocusProxy
        viewportName={name}
        ref={tailFocusProxyRef}
        onFocusFromOutsideViewport={() => {
          const tabbableCandidates = getSortedTabbableCandidates({
            tabbingDirection: "backwards"
          });
          focusFirst(tabbableCandidates);
        }}
      />}
    </ToastViewportWrapperFrame>;
  }
);
ToastViewport.displayName = VIEWPORT_NAME;
const FOCUS_PROXY_NAME = "ToastFocusProxy";
const FocusProxy = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, viewportName, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    const viewport = context.viewports[viewportName];
    return <VisuallyHidden
      aria-hidden
      tabIndex={0}
      {...proxyProps}
      ref={forwardedRef}
      position={isWeb ? "fixed" : "absolute"}
      onFocus={(event) => {
        if (!isWeb)
          return;
        const prevFocusedElement = event.relatedTarget;
        const isFocusFromOutsideViewport = !viewport?.contains(prevFocusedElement);
        if (isFocusFromOutsideViewport)
          onFocusFromOutsideViewport();
      }}
    />;
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
function focusFirst(candidates) {
  if (!isWeb)
    return;
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
function getTabbableCandidates(container) {
  if (!isWeb)
    return [];
  const containerHtml = container;
  const nodes = [];
  const walker = document.createTreeWalker(containerHtml, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
export {
  ToastViewport,
  VIEWPORT_DEFAULT_HOTKEY,
  VIEWPORT_PAUSE,
  VIEWPORT_RESUME
};
//# sourceMappingURL=ToastViewport.js.map
