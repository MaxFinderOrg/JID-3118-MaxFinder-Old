"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ToastImpl_exports = {};
__export(ToastImpl_exports, {
  ToastImpl: () => ToastImpl,
  ToastImplFrame: () => ToastImplFrame,
  useToastInteractiveContext: () => useToastInteractiveContext
});
module.exports = __toCommonJS(ToastImpl_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_animate_presence = require("@tamagui/animate-presence");
var import_compose_refs = require("@tamagui/compose-refs");
var import_core = require("@tamagui/core");
var import_dismissable = require("@tamagui/dismissable");
var import_portal = require("@tamagui/portal");
var import_stacks = require("@tamagui/stacks");
var React = __toESM(require("react"));
var import_react_native = require("react-native");
var import_constants = require("./constants");
var import_ToastAnnounce = require("./ToastAnnounce");
var import_ToastProvider = require("./ToastProvider");
var import_ToastViewport = require("./ToastViewport");
const ToastImplFrame = (0, import_core.styled)(import_stacks.ThemeableStack, {
  name: "ToastImpl",
  focusable: true,
  variants: {
    unstyled: {
      false: {
        focusStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$borderColorHover"
        },
        backgroundColor: "$color6",
        borderRadius: "$10",
        paddingHorizontal: "$5",
        paddingVertical: "$2",
        marginHorizontal: "auto",
        marginVertical: "$1"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const [ToastInteractiveProvider, useToastInteractiveContext] = (0, import_ToastProvider.createToastContext)(
  import_constants.TOAST_NAME,
  {
    onClose() {
    }
  }
);
const ToastImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      viewportName = "default",
      ...toastProps
    } = props;
    const isPresent = (0, import_animate_presence.useIsPresent)();
    const context = (0, import_ToastProvider.useToastProviderContext)(import_constants.TOAST_NAME, __scopeToast);
    const [node, setNode] = React.useState(null);
    const composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, (node2) => setNode(node2));
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React.useRef(0);
    const closeTimerRemainingTimeRef = React.useRef(duration);
    const closeTimerRef = React.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const viewport = React.useMemo(() => {
      return context.viewports[viewportName];
    }, [context.viewports, viewportName]);
    const handleClose = (0, import_core.useEvent)(() => {
      if (!isPresent) {
        return;
      }
      if (import_core.isWeb) {
        const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
        if (isFocusInToast)
          viewport == null ? void 0 : viewport.focus();
      }
      onClose();
    });
    const startTimer = React.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity)
          return;
        clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    const handleResume = React.useCallback(() => {
      startTimer(closeTimerRemainingTimeRef.current);
      onResume == null ? void 0 : onResume();
    }, [onResume, startTimer]);
    const handlePause = React.useCallback(() => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
      closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
      window.clearTimeout(closeTimerRef.current);
      onPause == null ? void 0 : onPause();
    }, [onPause]);
    React.useEffect(() => {
      if (!import_core.isWeb)
        return;
      if (viewport) {
        viewport.addEventListener(import_ToastViewport.VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(import_ToastViewport.VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(import_ToastViewport.VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(import_ToastViewport.VIEWPORT_RESUME, handleResume);
        };
      }
    }, [viewport, duration, onPause, onResume, startTimer]);
    React.useEffect(() => {
      if (open && !context.isClosePausedRef.current) {
        startTimer(duration);
      }
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React.useMemo(() => {
      if (!import_core.isWeb)
        return null;
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    const isHorizontalSwipe = ["left", "right", "horizontal"].includes(
      context.swipeDirection
    );
    const driver = (0, import_core.useAnimationDriver)();
    if (!driver) {
      throw new Error("Must set animations in tamagui.config.ts");
    }
    const { useAnimatedNumber, useAnimatedNumberStyle } = driver;
    const animatedNumber = useAnimatedNumber(0);
    const AnimatedView = driver["NumberView"] ?? driver.View;
    const animatedStyles = useAnimatedNumberStyle(animatedNumber, (val) => {
      "worklet";
      return {
        transform: [isHorizontalSwipe ? { translateX: val } : { translateY: val }]
      };
    });
    const panResponder = React.useMemo(() => {
      return import_react_native.PanResponder.create({
        onMoveShouldSetPanResponder: (e, gesture) => {
          const shouldMove = shouldGrantGestureMove(context.swipeDirection, gesture);
          if (shouldMove) {
            onSwipeStart == null ? void 0 : onSwipeStart(e);
            return true;
          }
          return false;
        },
        onPanResponderGrant: (e) => {
          if (!import_core.isWeb) {
            handlePause == null ? void 0 : handlePause();
          }
        },
        onPanResponderMove: (e, gesture) => {
          const { x, y } = getGestureDistance(context.swipeDirection, gesture);
          const delta = { x, y };
          animatedNumber.setValue(isHorizontalSwipe ? x : y, { type: "direct" });
          if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
            onSwipeEnd == null ? void 0 : onSwipeEnd(e);
          }
          onSwipeMove == null ? void 0 : onSwipeMove(e);
        },
        onPanResponderEnd: (e, { dx, dy }) => {
          if (!isDeltaInDirection(
            { x: dx, y: dy },
            context.swipeDirection,
            context.swipeThreshold
          )) {
            if (!import_core.isWeb) {
              handleResume == null ? void 0 : handleResume();
            }
            onSwipeCancel == null ? void 0 : onSwipeCancel(e);
            animatedNumber.setValue(0, { type: "spring" });
          }
        }
      });
    }, [handlePause, handleResume]);
    const themeName = (0, import_core.useThemeName)();
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_ToastAnnounce.ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.PortalItem, { hostName: viewportName ?? "default", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        ToastInteractiveProvider,
        {
          scope: __scopeToast,
          onClose: () => {
            handleClose();
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_dismissable.Dismissable,
            {
              onEscapeKeyDown: (0, import_core.composeEventHandlers)(onEscapeKeyDown, () => {
                if (!context.isFocusedToastEscapeKeyDownRef.current) {
                  handleClose();
                }
                context.isFocusedToastEscapeKeyDownRef.current = false;
              }),
              children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_core.Theme, { forceClassName: true, name: themeName, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                AnimatedView,
                {
                  ...panResponder == null ? void 0 : panResponder.panHandlers,
                  style: [{ margin: "auto" }, animatedStyles],
                  children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ToastProvider.Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    ToastImplFrame,
                    {
                      role: "status",
                      "aria-live": "off",
                      "aria-atomic": true,
                      "data-state": open ? "open" : "closed",
                      "data-swipe-direction": context.swipeDirection,
                      pointerEvents: "auto",
                      userSelect: "none",
                      ...toastProps,
                      ref: composedRefs,
                      ...import_core.isWeb && {
                        onKeyDown: (0, import_core.composeEventHandlers)(
                          props.onKeyDown,
                          (event) => {
                            if (event.key !== "Escape")
                              return;
                            onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
                            onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
                            if (!event.defaultPrevented) {
                              context.isFocusedToastEscapeKeyDownRef.current = true;
                              handleClose();
                            }
                          }
                        )
                      }
                    }
                  ) })
                }
              ) })
            }
          )
        },
        props.id
      ) })
    ] });
  }
);
ToastImpl.propTypes = {
  type(props) {
    if (props.type && !["foreground", "background"].includes(props.type)) {
      const error = `Invalid prop \`type\` supplied to \`${import_constants.TOAST_NAME}\`. Expected \`foreground | background\`.`;
      return new Error(error);
    }
    return null;
  }
};
const isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right" || direction === "horizontal") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function getAnnounceTextContent(container) {
  if (!import_core.isWeb)
    return "";
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.toastAnnounceExclude === "";
      if (!isHidden) {
        if (isExcluded) {
          const altText = node.dataset.toastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
const GESTURE_GRANT_THRESHOLD = 10;
const shouldGrantGestureMove = (dir, { dx, dy }) => {
  if ((dir === "horizontal" || dir === "left") && dx < -GESTURE_GRANT_THRESHOLD) {
    return true;
  } else if ((dir === "horizontal" || dir === "right") && dx > GESTURE_GRANT_THRESHOLD) {
    return true;
  } else if ((dir === "vertical" || dir === "up") && dy > -GESTURE_GRANT_THRESHOLD) {
    return true;
  } else if ((dir === "vertical" || dir === "down") && dy < GESTURE_GRANT_THRESHOLD) {
    return true;
  }
  return false;
};
const getGestureDistance = (dir, { dx, dy }) => {
  let y = 0;
  let x = 0;
  if (dir === "horizontal")
    x = dx;
  else if (dir === "left")
    x = Math.min(0, dx);
  else if (dir === "right")
    x = Math.max(0, dx);
  else if (dir === "vertical")
    y = dy;
  else if (dir === "up")
    y = Math.min(0, dy);
  else if (dir === "down")
    y = Math.max(0, dy);
  return {
    x,
    y
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ToastImpl,
  ToastImplFrame,
  useToastInteractiveContext
});
//# sourceMappingURL=ToastImpl.js.map
