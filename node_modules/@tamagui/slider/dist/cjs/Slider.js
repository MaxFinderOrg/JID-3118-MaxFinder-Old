"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Slider_exports = {};
__export(Slider_exports, {
  Range: () => Range,
  Slider: () => Slider,
  SliderThumb: () => SliderThumb,
  SliderThumbFrame: () => SliderThumbFrame,
  SliderTrack: () => SliderTrack,
  SliderTrackActive: () => SliderTrackActive,
  SliderTrackActiveFrame: () => SliderTrackActiveFrame,
  SliderTrackFrame: () => SliderTrackFrame,
  Thumb: () => Thumb,
  Track: () => Track
});
module.exports = __toCommonJS(Slider_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_compose_refs = require("@tamagui/compose-refs");
var import_core = require("@tamagui/core");
var import_get_token = require("@tamagui/get-token");
var import_helpers = require("@tamagui/helpers");
var import_stacks = require("@tamagui/stacks");
var import_use_controllable_state = require("@tamagui/use-controllable-state");
var import_use_direction = require("@tamagui/use-direction");
var React = __toESM(require("react"));
var import_constants = require("./constants");
var import_helpers2 = require("./helpers");
var import_SliderImpl = require("./SliderImpl");
const SliderHorizontal = React.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      dir,
      onSlideStart,
      onSlideMove,
      onStepKeyDown,
      onSlideEnd,
      ...sliderProps
    } = props;
    const direction = (0, import_use_direction.useDirection)(dir);
    const isDirectionLTR = direction === "ltr";
    const sliderRef = React.useRef(null);
    const [state, setState_] = React.useState(() => ({ size: 0, offset: 0 }));
    const setState = (0, import_core.createShallowSetState)(setState_);
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      const output = isDirectionLTR ? [min, max] : [max, min];
      const value = (0, import_helpers2.linearScale)(input, output);
      return value(pointerPosition);
    }
    const measure = () => {
      var _a;
      (_a = sliderRef.current) == null ? void 0 : _a.measure((_x, _y, width, _height, pageX, _pageY) => {
        setState({
          size: width,
          offset: pageX
        });
      });
    };
    if (import_core.isClient) {
      useOnDebouncedWindowResize(measure);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_constants.SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isDirectionLTR ? "left" : "right",
        endEdge: isDirectionLTR ? "right" : "left",
        direction: isDirectionLTR ? 1 : -1,
        sizeProp: "width",
        size: state.size,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_SliderImpl.SliderImpl,
          {
            ref: (0, import_compose_refs.composeRefs)(forwardedRef, sliderRef),
            dir: direction,
            ...sliderProps,
            orientation: "horizontal",
            onLayout: measure,
            onSlideStart: (event, target) => {
              const value = getValueFromPointer(event.nativeEvent.locationX);
              if (value) {
                onSlideStart == null ? void 0 : onSlideStart(value, target, event);
              }
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
              if (value) {
                onSlideMove == null ? void 0 : onSlideMove(value, event);
              }
            },
            onSlideEnd: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
              if (value) {
                onSlideEnd == null ? void 0 : onSlideEnd(event, value);
              }
            },
            onStepKeyDown: (event) => {
              const isBackKey = import_constants.BACK_KEYS[direction].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
function useOnDebouncedWindowResize(callback, amt = 200) {
  React.useEffect(() => {
    let last;
    const onResize = () => {
      clearTimeout(last);
      last = setTimeout(callback, amt);
    };
    window.addEventListener("resize", onResize);
    return () => {
      clearTimeout(last);
      window.removeEventListener("resize", onResize);
    };
  }, []);
}
const SliderVertical = React.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      onSlideStart,
      onSlideMove,
      onStepKeyDown,
      onSlideEnd,
      ...sliderProps
    } = props;
    const [state, setState_] = React.useState(() => ({ size: 0, offset: 0 }));
    const setState = (0, import_core.createShallowSetState)(setState_);
    const sliderRef = React.useRef(null);
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      const output = [max, min];
      const value = (0, import_helpers2.linearScale)(input, output);
      return value(pointerPosition);
    }
    const measure = () => {
      var _a;
      (_a = sliderRef.current) == null ? void 0 : _a.measure((_x, _y, _width, height, _pageX, pageY) => {
        setState({
          size: height,
          offset: pageY
        });
      });
    };
    if (import_core.isClient) {
      useOnDebouncedWindowResize(measure);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_constants.SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: "bottom",
        endEdge: "top",
        sizeProp: "height",
        size: state.size,
        direction: 1,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_SliderImpl.SliderImpl,
          {
            ref: (0, import_compose_refs.composeRefs)(forwardedRef, sliderRef),
            ...sliderProps,
            orientation: "vertical",
            onLayout: measure,
            onSlideStart: (event, target) => {
              const value = getValueFromPointer(event.nativeEvent.locationY);
              if (value) {
                onSlideStart == null ? void 0 : onSlideStart(value, target, event);
              }
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
              if (value) {
                onSlideMove == null ? void 0 : onSlideMove(value, event);
              }
            },
            onSlideEnd: (event) => {
              const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
              onSlideEnd == null ? void 0 : onSlideEnd(event, value);
            },
            onStepKeyDown: (event) => {
              const isBackKey = import_constants.BACK_KEYS.ltr.includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
const TRACK_NAME = "SliderTrack";
const SliderTrackFrame = (0, import_core.styled)(import_SliderImpl.SliderFrame, {
  name: "SliderTrack",
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgroundColor: "$background",
        position: "relative",
        borderRadius: 1e5,
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const SliderTrack = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = (0, import_constants.useSliderContext)(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      SliderTrackFrame,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        orientation: context.orientation,
        size: context.size,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
const RANGE_NAME = "SliderTrackActive";
const SliderTrackActiveFrame = (0, import_core.styled)(import_SliderImpl.SliderFrame, {
  name: "SliderTrackActive",
  backgroundColor: "$background",
  position: "absolute"
});
const SliderTrackActive = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = (0, import_constants.useSliderContext)(RANGE_NAME, __scopeSlider);
    const orientation = (0, import_constants.useSliderOrientationContext)(RANGE_NAME, __scopeSlider);
    const ref = React.useRef(null);
    const composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => (0, import_helpers2.convertValueToPercentage)(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      SliderTrackActiveFrame,
      {
        orientation: context.orientation,
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        size: context.size,
        animateOnly: ["left", "top", "right", "bottom"],
        ...rangeProps,
        ref: composedRefs,
        ...{
          [orientation.startEdge]: `${offsetStart}%`,
          [orientation.endEdge]: `${offsetEnd}%`
        },
        ...orientation.sizeProp === "width" ? {
          height: "100%"
        } : {
          left: 0,
          right: 0
        }
      }
    );
  }
);
SliderTrackActive.displayName = RANGE_NAME;
const THUMB_NAME = "SliderThumb";
const getThumbSize = (val) => {
  const tokens = (0, import_core.getTokens)();
  const size = typeof val === "number" ? val : (0, import_get_token.getSize)(tokens.size[val], {
    shift: -1
  });
  return {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size
  };
};
const SliderThumbFrame = (0, import_core.styled)(import_stacks.ThemeableStack, {
  name: "SliderThumb",
  variants: {
    size: {
      "...size": getThumbSize
    },
    unstyled: {
      false: {
        position: "absolute",
        bordered: 2,
        borderWidth: 2,
        backgrounded: true,
        pressTheme: import_core.isWeb,
        focusTheme: import_core.isWeb,
        hoverTheme: import_core.isWeb
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const SliderThumb = SliderThumbFrame.styleable(function SliderThumb2(props, forwardedRef) {
  const { __scopeSlider, index, size: sizeProp, ...thumbProps } = props;
  const context = (0, import_constants.useSliderContext)(THUMB_NAME, __scopeSlider);
  const orientation = (0, import_constants.useSliderOrientationContext)(THUMB_NAME, __scopeSlider);
  const [thumb, setThumb] = React.useState(null);
  const composedRefs = (0, import_compose_refs.useComposedRefs)(
    forwardedRef,
    (node) => setThumb(node)
  );
  const value = context.values[index];
  const percent = value === void 0 ? 0 : (0, import_helpers2.convertValueToPercentage)(value, context.min, context.max);
  const label = (0, import_helpers2.getLabel)(index, context.values.length);
  const sizeIn = sizeProp ?? context.size ?? "$true";
  const [size, setSize] = React.useState(() => {
    const estimatedSize = (0, import_core.getVariableValue)(getThumbSize(sizeIn).width);
    return estimatedSize;
  });
  const thumbInBoundsOffset = size ? (0, import_helpers2.getThumbInBoundsOffset)(size, percent, orientation.direction) : 0;
  React.useEffect(() => {
    if (thumb) {
      context.thumbs.add(thumb);
      return () => {
        context.thumbs.delete(thumb);
      };
    }
  }, [thumb, context.thumbs]);
  const positionalStyles = context.orientation === "horizontal" ? {
    x: thumbInBoundsOffset - size / 2,
    y: -size / 2,
    top: "50%",
    ...size === 0 && {
      top: "auto",
      bottom: "auto"
    }
  } : {
    x: -size / 2,
    y: size / 2,
    left: "50%",
    ...size === 0 && {
      left: "auto",
      right: "auto"
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    SliderThumbFrame,
    {
      ref: composedRefs,
      role: "slider",
      "aria-label": props["aria-label"] || label,
      "aria-valuemin": context.min,
      "aria-valuenow": value,
      "aria-valuemax": context.max,
      "aria-orientation": context.orientation,
      "data-orientation": context.orientation,
      "data-disabled": context.disabled ? "" : void 0,
      tabIndex: context.disabled ? void 0 : 0,
      animateOnly: ["transform", "left", "top", "right", "bottom"],
      ...positionalStyles,
      ...{
        [orientation.startEdge]: `${percent}%`
      },
      size: sizeIn,
      ...thumbProps,
      onLayout: (e) => {
        setSize(e.nativeEvent.layout[orientation.sizeProp]);
      },
      onFocus: (0, import_helpers.composeEventHandlers)(props.onFocus, () => {
        context.valueIndexToChangeRef.current = index;
      })
    }
  );
});
const SliderComponent = React.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min = 0,
      max = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min],
      value,
      onValueChange = () => {
      },
      size: sizeProp,
      onSlideEnd,
      onSlideMove,
      onSlideStart,
      ...sliderProps
    } = props;
    const sliderRef = React.useRef(null);
    const composedRefs = (0, import_compose_refs.useComposedRefs)(sliderRef, forwardedRef);
    const thumbRefs = React.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = React.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const [values = [], setValues] = (0, import_use_controllable_state.useControllableState)({
      prop: value,
      defaultProp: defaultValue,
      transition: true,
      onChange: (value2) => {
        var _a;
        if (import_core.isWeb) {
          const thumbs = [...thumbRefs.current];
          (_a = thumbs[valueIndexToChangeRef.current]) == null ? void 0 : _a.focus();
        }
        onValueChange(value2);
      }
    });
    if (import_core.isWeb) {
      React.useEffect(() => {
        const node = sliderRef.current;
        if (!node)
          return;
        const preventDefault = (e) => {
          e.preventDefault();
        };
        node.addEventListener("touchstart", preventDefault);
        return () => {
          node.removeEventListener("touchstart", preventDefault);
        };
      }, []);
    }
    function handleSlideMove(value2, event) {
      updateValues(value2, valueIndexToChangeRef.current);
      onSlideMove == null ? void 0 : onSlideMove(event, value2);
    }
    function updateValues(value2, atIndex) {
      const decimalCount = (0, import_helpers2.getDecimalCount)(step);
      const snapToStep = (0, import_helpers2.roundValue)(
        Math.round((value2 - min) / step) * step + min,
        decimalCount
      );
      const nextValue = (0, import_helpers.clamp)(snapToStep, [min, max]);
      setValues((prevValues = []) => {
        const nextValues = (0, import_helpers2.getNextSortedValues)(prevValues, nextValue, atIndex);
        if ((0, import_helpers2.hasMinStepsBetweenValues)(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          return String(nextValues) === String(prevValues) ? prevValues : nextValues;
        } else {
          return prevValues;
        }
      });
    }
    const SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_constants.SliderProvider,
      {
        scope: props.__scopeSlider,
        disabled,
        min,
        max,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        size: sizeProp,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          SliderOriented,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: composedRefs,
            min,
            max,
            onSlideEnd,
            onSlideStart: disabled ? void 0 : (value2, target, event) => {
              if (target !== "thumb") {
                const closestIndex = (0, import_helpers2.getClosestValueIndex)(values, value2);
                updateValues(value2, closestIndex);
                onSlideStart == null ? void 0 : onSlideStart(event, value2, target);
              }
            },
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onHomeKeyDown: () => !disabled && updateValues(min, 0),
            onEndKeyDown: () => !disabled && updateValues(max, values.length - 1),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = import_constants.PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && import_constants.ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex);
              }
            }
          }
        )
      }
    );
  }
);
const Slider = (0, import_core.withStaticProperties)(SliderComponent, {
  Track: SliderTrack,
  TrackActive: SliderTrackActive,
  Thumb: SliderThumb
});
Slider.displayName = import_constants.SLIDER_NAME;
const Track = SliderTrack;
const Range = SliderTrackActive;
const Thumb = SliderThumb;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Range,
  Slider,
  SliderThumb,
  SliderThumbFrame,
  SliderTrack,
  SliderTrackActive,
  SliderTrackActiveFrame,
  SliderTrackFrame,
  Thumb,
  Track
});
//# sourceMappingURL=Slider.js.map
