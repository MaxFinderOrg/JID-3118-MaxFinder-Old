import { composeRefs, useComposedRefs } from "@tamagui/compose-refs";
import {
  createShallowSetState,
  getTokens,
  getVariableValue,
  isClient,
  isWeb,
  styled,
  withStaticProperties
} from "@tamagui/core";
import { getSize } from "@tamagui/get-token";
import { clamp, composeEventHandlers } from "@tamagui/helpers";
import { ThemeableStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import { useDirection } from "@tamagui/use-direction";
import * as React from "react";
import {
  ARROW_KEYS,
  BACK_KEYS,
  PAGE_KEYS,
  SLIDER_NAME,
  SliderOrientationProvider,
  SliderProvider,
  useSliderContext,
  useSliderOrientationContext
} from "./constants";
import {
  convertValueToPercentage,
  getClosestValueIndex,
  getDecimalCount,
  getLabel,
  getNextSortedValues,
  getThumbInBoundsOffset,
  hasMinStepsBetweenValues,
  linearScale,
  roundValue
} from "./helpers";
import { SliderFrame, SliderImpl } from "./SliderImpl";
const SliderHorizontal = React.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      dir,
      onSlideStart,
      onSlideMove,
      onStepKeyDown,
      onSlideEnd,
      ...sliderProps
    } = props;
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const sliderRef = React.useRef(null);
    const [state, setState_] = React.useState(() => ({ size: 0, offset: 0 }));
    const setState = createShallowSetState(setState_);
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      const output = isDirectionLTR ? [min, max] : [max, min];
      const value = linearScale(input, output);
      return value(pointerPosition);
    }
    const measure = () => {
      sliderRef.current?.measure((_x, _y, width, _height, pageX, _pageY) => {
        setState({
          size: width,
          offset: pageX
        });
      });
    };
    if (isClient) {
      useOnDebouncedWindowResize(measure);
    }
    return <SliderOrientationProvider
      scope={props.__scopeSlider}
      startEdge={isDirectionLTR ? "left" : "right"}
      endEdge={isDirectionLTR ? "right" : "left"}
      direction={isDirectionLTR ? 1 : -1}
      sizeProp="width"
      size={state.size}
    ><SliderImpl
      ref={composeRefs(forwardedRef, sliderRef)}
      dir={direction}
      {...sliderProps}
      orientation="horizontal"
      onLayout={measure}
      onSlideStart={(event, target) => {
        const value = getValueFromPointer(event.nativeEvent.locationX);
        if (value) {
          onSlideStart?.(value, target, event);
        }
      }}
      onSlideMove={(event) => {
        const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        if (value) {
          onSlideMove?.(value, event);
        }
      }}
      onSlideEnd={(event) => {
        const value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        if (value) {
          onSlideEnd?.(event, value);
        }
      }}
      onStepKeyDown={(event) => {
        const isBackKey = BACK_KEYS[direction].includes(event.key);
        onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
      }}
    /></SliderOrientationProvider>;
  }
);
function useOnDebouncedWindowResize(callback, amt = 200) {
  React.useEffect(() => {
    let last;
    const onResize = () => {
      clearTimeout(last);
      last = setTimeout(callback, amt);
    };
    window.addEventListener("resize", onResize);
    return () => {
      clearTimeout(last);
      window.removeEventListener("resize", onResize);
    };
  }, []);
}
const SliderVertical = React.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      onSlideStart,
      onSlideMove,
      onStepKeyDown,
      onSlideEnd,
      ...sliderProps
    } = props;
    const [state, setState_] = React.useState(() => ({ size: 0, offset: 0 }));
    const setState = createShallowSetState(setState_);
    const sliderRef = React.useRef(null);
    function getValueFromPointer(pointerPosition) {
      const input = [0, state.size];
      const output = [max, min];
      const value = linearScale(input, output);
      return value(pointerPosition);
    }
    const measure = () => {
      sliderRef.current?.measure((_x, _y, _width, height, _pageX, pageY) => {
        setState({
          size: height,
          offset: pageY
        });
      });
    };
    if (isClient) {
      useOnDebouncedWindowResize(measure);
    }
    return <SliderOrientationProvider
      scope={props.__scopeSlider}
      startEdge="bottom"
      endEdge="top"
      sizeProp="height"
      size={state.size}
      direction={1}
    ><SliderImpl
      ref={composeRefs(forwardedRef, sliderRef)}
      {...sliderProps}
      orientation="vertical"
      onLayout={measure}
      onSlideStart={(event, target) => {
        const value = getValueFromPointer(event.nativeEvent.locationY);
        if (value) {
          onSlideStart?.(value, target, event);
        }
      }}
      onSlideMove={(event) => {
        const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        if (value) {
          onSlideMove?.(value, event);
        }
      }}
      onSlideEnd={(event) => {
        const value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        onSlideEnd?.(event, value);
      }}
      onStepKeyDown={(event) => {
        const isBackKey = BACK_KEYS.ltr.includes(event.key);
        onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
      }}
    /></SliderOrientationProvider>;
  }
);
const TRACK_NAME = "SliderTrack";
const SliderTrackFrame = styled(SliderFrame, {
  name: "SliderTrack",
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgroundColor: "$background",
        position: "relative",
        borderRadius: 1e5,
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const SliderTrack = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return <SliderTrackFrame
      data-disabled={context.disabled ? "" : void 0}
      data-orientation={context.orientation}
      orientation={context.orientation}
      size={context.size}
      {...trackProps}
      ref={forwardedRef}
    />;
  }
);
SliderTrack.displayName = TRACK_NAME;
const RANGE_NAME = "SliderTrackActive";
const SliderTrackActiveFrame = styled(SliderFrame, {
  name: "SliderTrackActive",
  backgroundColor: "$background",
  position: "absolute"
});
const SliderTrackActive = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return <SliderTrackActiveFrame
      orientation={context.orientation}
      data-orientation={context.orientation}
      data-disabled={context.disabled ? "" : void 0}
      size={context.size}
      animateOnly={["left", "top", "right", "bottom"]}
      {...rangeProps}
      ref={composedRefs}
      {...{
        [orientation.startEdge]: `${offsetStart}%`,
        [orientation.endEdge]: `${offsetEnd}%`
      }}
      {...orientation.sizeProp === "width" ? {
        height: "100%"
      } : {
        left: 0,
        right: 0
      }}
    />;
  }
);
SliderTrackActive.displayName = RANGE_NAME;
const THUMB_NAME = "SliderThumb";
const getThumbSize = (val) => {
  const tokens = getTokens();
  const size = typeof val === "number" ? val : getSize(tokens.size[val], {
    shift: -1
  });
  return {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size
  };
};
const SliderThumbFrame = styled(ThemeableStack, {
  name: "SliderThumb",
  variants: {
    size: {
      "...size": getThumbSize
    },
    unstyled: {
      false: {
        position: "absolute",
        bordered: 2,
        borderWidth: 2,
        backgrounded: true,
        pressTheme: isWeb,
        focusTheme: isWeb,
        hoverTheme: isWeb
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const SliderThumb = SliderThumbFrame.styleable(function SliderThumb2(props, forwardedRef) {
  const { __scopeSlider, index, size: sizeProp, ...thumbProps } = props;
  const context = useSliderContext(THUMB_NAME, __scopeSlider);
  const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
  const [thumb, setThumb] = React.useState(null);
  const composedRefs = useComposedRefs(
    forwardedRef,
    (node) => setThumb(node)
  );
  const value = context.values[index];
  const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
  const label = getLabel(index, context.values.length);
  const sizeIn = sizeProp ?? context.size ?? "$true";
  const [size, setSize] = React.useState(() => {
    const estimatedSize = getVariableValue(getThumbSize(sizeIn).width);
    return estimatedSize;
  });
  const thumbInBoundsOffset = size ? getThumbInBoundsOffset(size, percent, orientation.direction) : 0;
  React.useEffect(() => {
    if (thumb) {
      context.thumbs.add(thumb);
      return () => {
        context.thumbs.delete(thumb);
      };
    }
  }, [thumb, context.thumbs]);
  const positionalStyles = context.orientation === "horizontal" ? {
    x: thumbInBoundsOffset - size / 2,
    y: -size / 2,
    top: "50%",
    ...size === 0 && {
      top: "auto",
      bottom: "auto"
    }
  } : {
    x: -size / 2,
    y: size / 2,
    left: "50%",
    ...size === 0 && {
      left: "auto",
      right: "auto"
    }
  };
  return <SliderThumbFrame
    ref={composedRefs}
    role="slider"
    aria-label={props["aria-label"] || label}
    aria-valuemin={context.min}
    aria-valuenow={value}
    aria-valuemax={context.max}
    aria-orientation={context.orientation}
    data-orientation={context.orientation}
    data-disabled={context.disabled ? "" : void 0}
    tabIndex={context.disabled ? void 0 : 0}
    animateOnly={["transform", "left", "top", "right", "bottom"]}
    {...positionalStyles}
    {...{
      [orientation.startEdge]: `${percent}%`
    }}
    size={sizeIn}
    {...thumbProps}
    onLayout={(e) => {
      setSize(e.nativeEvent.layout[orientation.sizeProp]);
    }}
    onFocus={composeEventHandlers(props.onFocus, () => {
      context.valueIndexToChangeRef.current = index;
    })}
  />;
});
const SliderComponent = React.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min = 0,
      max = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min],
      value,
      onValueChange = () => {
      },
      size: sizeProp,
      onSlideEnd,
      onSlideMove,
      onSlideStart,
      ...sliderProps
    } = props;
    const sliderRef = React.useRef(null);
    const composedRefs = useComposedRefs(sliderRef, forwardedRef);
    const thumbRefs = React.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = React.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      transition: true,
      onChange: (value2) => {
        if (isWeb) {
          const thumbs = [...thumbRefs.current];
          thumbs[valueIndexToChangeRef.current]?.focus();
        }
        onValueChange(value2);
      }
    });
    if (isWeb) {
      React.useEffect(() => {
        const node = sliderRef.current;
        if (!node)
          return;
        const preventDefault = (e) => {
          e.preventDefault();
        };
        node.addEventListener("touchstart", preventDefault);
        return () => {
          node.removeEventListener("touchstart", preventDefault);
        };
      }, []);
    }
    function handleSlideMove(value2, event) {
      updateValues(value2, valueIndexToChangeRef.current);
      onSlideMove?.(event, value2);
    }
    function updateValues(value2, atIndex) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(
        Math.round((value2 - min) / step) * step + min,
        decimalCount
      );
      const nextValue = clamp(snapToStep, [min, max]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          return String(nextValues) === String(prevValues) ? prevValues : nextValues;
        } else {
          return prevValues;
        }
      });
    }
    const SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;
    return <SliderProvider
      scope={props.__scopeSlider}
      disabled={disabled}
      min={min}
      max={max}
      valueIndexToChangeRef={valueIndexToChangeRef}
      thumbs={thumbRefs.current}
      values={values}
      orientation={orientation}
      size={sizeProp}
    >
      <SliderOriented
        aria-disabled={disabled}
        data-disabled={disabled ? "" : void 0}
        {...sliderProps}
        ref={composedRefs}
        min={min}
        max={max}
        onSlideEnd={onSlideEnd}
        onSlideStart={disabled ? void 0 : (value2, target, event) => {
          if (target !== "thumb") {
            const closestIndex = getClosestValueIndex(values, value2);
            updateValues(value2, closestIndex);
            onSlideStart?.(event, value2, target);
          }
        }}
        onSlideMove={disabled ? void 0 : handleSlideMove}
        onHomeKeyDown={() => !disabled && updateValues(min, 0)}
        onEndKeyDown={() => !disabled && updateValues(max, values.length - 1)}
        onStepKeyDown={({ event, direction: stepDirection }) => {
          if (!disabled) {
            const isPageKey = PAGE_KEYS.includes(event.key);
            const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
            const multiplier = isSkipKey ? 10 : 1;
            const atIndex = valueIndexToChangeRef.current;
            const value2 = values[atIndex];
            const stepInDirection = step * multiplier * stepDirection;
            updateValues(value2 + stepInDirection, atIndex);
          }
        }}
      />
      {
        /* {isFormControl &&
        values.map((value, index) => (
          <BubbleInput
            key={index}
            name={name ? name + (values.length > 1 ? '[]' : '') : undefined}
            value={value}
          />
        ))} */
      }
    </SliderProvider>;
  }
);
const Slider = withStaticProperties(SliderComponent, {
  Track: SliderTrack,
  TrackActive: SliderTrackActive,
  Thumb: SliderThumb
});
Slider.displayName = SLIDER_NAME;
const Track = SliderTrack;
const Range = SliderTrackActive;
const Thumb = SliderThumb;
export {
  Range,
  Slider,
  SliderThumb,
  SliderThumbFrame,
  SliderTrack,
  SliderTrackActive,
  SliderTrackActiveFrame,
  SliderTrackFrame,
  Thumb,
  Track
};
//# sourceMappingURL=Slider.js.map
