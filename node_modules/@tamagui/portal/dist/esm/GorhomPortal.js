import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import { useDidFinishSSR, useEvent, useIsomorphicLayoutEffect } from "@tamagui/core";
import React, {
  createContext,
  memo,
  startTransition,
  useCallback,
  useContext,
  useEffect,
  useId,
  useMemo,
  useReducer
} from "react";
var ACTIONS = /* @__PURE__ */ ((ACTIONS2) => {
  ACTIONS2[ACTIONS2["REGISTER_HOST"] = 0] = "REGISTER_HOST";
  ACTIONS2[ACTIONS2["DEREGISTER_HOST"] = 1] = "DEREGISTER_HOST";
  ACTIONS2[ACTIONS2["ADD_UPDATE_PORTAL"] = 2] = "ADD_UPDATE_PORTAL";
  ACTIONS2[ACTIONS2["REMOVE_PORTAL"] = 3] = "REMOVE_PORTAL";
  return ACTIONS2;
})(ACTIONS || {});
const INITIAL_STATE = {};
const registerHost = (state, hostName) => {
  if (!(hostName in state)) {
    state[hostName] = [];
  }
  return state;
};
const deregisterHost = (state, hostName) => {
  delete state[hostName];
  return state;
};
const addUpdatePortal = (state, hostName, portalName, node) => {
  if (!(hostName in state)) {
    state = registerHost(state, hostName);
  }
  const index = state[hostName].findIndex((item) => item.name === portalName);
  if (index !== -1) {
    state[hostName][index].node = node;
  } else {
    state[hostName].push({
      name: portalName,
      node
    });
  }
  return state;
};
const removePortal = (state, hostName, portalName) => {
  if (!(hostName in state)) {
    console.log(
      `Failed to remove portal '${portalName}', '${hostName}' was not registered!`
    );
    return state;
  }
  const index = state[hostName].findIndex((item) => item.name === portalName);
  if (index !== -1)
    state[hostName].splice(index, 1);
  return state;
};
const reducer = (state, action) => {
  const { type } = action;
  switch (type) {
    case 0 /* REGISTER_HOST */:
      return registerHost({ ...state }, action.hostName);
    case 1 /* DEREGISTER_HOST */:
      return deregisterHost({ ...state }, action.hostName);
    case 2 /* ADD_UPDATE_PORTAL */:
      return addUpdatePortal(
        { ...state },
        action.hostName,
        action.portalName,
        action.node
      );
    case 3 /* REMOVE_PORTAL */:
      return removePortal(
        { ...state },
        action.hostName,
        action.portalName
      );
    default:
      return state;
  }
};
const PortalStateContext = createContext(null);
const PortalDispatchContext = createContext(null);
const usePortalState = (hostName) => {
  const state = useContext(PortalStateContext);
  if (state === null) {
    throw new Error(
      "'PortalStateContext' cannot be null, please add 'PortalProvider' to the root component."
    );
  }
  return state[hostName] || [];
};
const usePortal = (hostName = "root") => {
  const dispatch = useContext(PortalDispatchContext);
  if (dispatch === null) {
    throw new Error(
      "'PortalDispatchContext' cannot be null, please add 'PortalProvider' to the root component."
    );
  }
  const registerHost2 = useCallback(() => {
    dispatch({
      type: 0 /* REGISTER_HOST */,
      hostName
    });
  }, []);
  const deregisterHost2 = useCallback(() => {
    dispatch({
      type: 1 /* DEREGISTER_HOST */,
      hostName
    });
  }, []);
  const addUpdatePortal2 = useCallback((name, node) => {
    dispatch({
      type: 2 /* ADD_UPDATE_PORTAL */,
      hostName,
      portalName: name,
      node
    });
  }, []);
  const removePortal2 = useCallback((name) => {
    dispatch({
      type: 3 /* REMOVE_PORTAL */,
      hostName,
      portalName: name
    });
  }, []);
  return {
    registerHost: registerHost2,
    deregisterHost: deregisterHost2,
    addPortal: addUpdatePortal2,
    updatePortal: addUpdatePortal2,
    removePortal: removePortal2
  };
};
const PortalProviderComponent = ({
  rootHostName = "root",
  shouldAddRootHost = true,
  children
}) => {
  const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
  const transitionDispatch = useMemo(() => {
    const next = (value) => {
      startTransition(() => {
        dispatch(value);
      });
    };
    return next;
  }, [dispatch]);
  return /* @__PURE__ */ jsx(PortalDispatchContext.Provider, { value: transitionDispatch, children: /* @__PURE__ */ jsxs(PortalStateContext.Provider, { value: state, children: [
    children,
    shouldAddRootHost && /* @__PURE__ */ jsx(PortalHost, { name: rootHostName })
  ] }) });
};
const PortalProvider = memo(PortalProviderComponent);
PortalProvider.displayName = "PortalProvider";
const defaultRenderer = (children) => /* @__PURE__ */ jsx(Fragment, { children });
const PortalHostComponent = (props) => {
  const { name, forwardProps, render = defaultRenderer } = props;
  const isServer = !useDidFinishSSR();
  const state = usePortalState(name);
  const { registerHost: registerHost2, deregisterHost: deregisterHost2 } = usePortal(props.name);
  useEffect(() => {
    if (isServer)
      return;
    registerHost2();
    return () => {
      deregisterHost2();
    };
  }, [isServer]);
  if (forwardProps) {
    return render(
      state.map((item) => {
        let next = item.node;
        if (forwardProps) {
          return React.Children.map(next, (child) => {
            return React.isValidElement(child) ? React.cloneElement(child, { key: child.key, ...forwardProps }) : child;
          });
        }
        return next;
      })
    );
  }
  return render(state.map((item) => item.node));
};
const PortalHost = memo(PortalHostComponent);
PortalHost.displayName = "PortalHost";
const PortalComponent = (props) => {
  const {
    name: _providedName,
    hostName,
    handleOnMount: _providedHandleOnMount,
    handleOnUnmount: _providedHandleOnUnmount,
    handleOnUpdate: _providedHandleOnUpdate,
    children
  } = props;
  const { addPortal: addUpdatePortal2, removePortal: removePortal2 } = usePortal(hostName);
  const id = useId();
  const name = _providedName || id;
  const handleOnMount = useEvent(() => {
    if (_providedHandleOnMount) {
      _providedHandleOnMount(() => addUpdatePortal2(name, children));
    } else {
      addUpdatePortal2(name, children);
    }
  });
  const handleOnUnmount = useEvent(() => {
    if (_providedHandleOnUnmount) {
      _providedHandleOnUnmount(() => removePortal2(name));
    } else {
      removePortal2(name);
    }
  });
  const handleOnUpdate = useEvent(() => {
    if (_providedHandleOnUpdate) {
      _providedHandleOnUpdate(() => addUpdatePortal2(name, children));
    } else {
      addUpdatePortal2(name, children);
    }
  });
  useIsomorphicLayoutEffect(() => {
    handleOnMount();
    return () => {
      handleOnUnmount();
    };
  }, []);
  useEffect(() => {
    handleOnUpdate();
  }, [children]);
  return null;
};
const PortalItem = memo(PortalComponent);
PortalItem.displayName = "Portal";
export {
  ACTIONS,
  INITIAL_STATE,
  PortalHost,
  PortalItem,
  PortalProvider,
  usePortal
};
//# sourceMappingURL=GorhomPortal.js.map
