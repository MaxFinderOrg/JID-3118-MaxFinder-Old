import { FloatingFocusManager } from "@floating-ui/react";
import { AnimatePresence } from "@tamagui/animate-presence";
import {
  composeRefs,
  isWeb,
  useIsomorphicLayoutEffect
} from "@tamagui/core";
import { styled } from "@tamagui/core";
import { PortalItem } from "@tamagui/portal";
import { ThemeableStack } from "@tamagui/stacks";
import { VIEWPORT_NAME } from "./constants";
import {
  ForwardSelectContext,
  useSelectContext,
  useSelectItemParentContext
} from "./context";
import { useSelectBreakpointActive } from "./useSelectBreakpointActive";
const SelectViewportFrame = styled(ThemeableStack, {
  name: VIEWPORT_NAME,
  variants: {
    unstyled: {
      false: {
        size: "$2",
        backgroundColor: "$background",
        elevate: true,
        bordered: true,
        userSelect: "none",
        outlineWidth: 0
      }
    },
    size: {
      "...size": (val, { tokens }) => {
        return {
          borderRadius: tokens.radius[val] ?? val
        };
      }
    }
  },
  defaultVariants: {
    unstyled: false
  }
});
const SelectViewport = SelectViewportFrame.styleable(
  function SelectViewport2(props, forwardedRef) {
    const { __scopeSelect, children, disableScroll, ...viewportProps } = props;
    const context = useSelectContext(VIEWPORT_NAME, __scopeSelect);
    const itemContext = useSelectItemParentContext(VIEWPORT_NAME, __scopeSelect);
    const breakpointActive = useSelectBreakpointActive(context.sheetBreakpoint);
    useIsomorphicLayoutEffect(() => {
      if (context.update) {
        context.update();
      }
    }, [breakpointActive]);
    const composedRefs = composeRefs(
      forwardedRef,
      context.floatingContext?.refs.setFloating
    );
    if (itemContext.shouldRenderWebNative) {
      return <>{children}</>;
    }
    if (breakpointActive || !isWeb) {
      return <PortalItem hostName={`${context.scopeKey}SheetContents`}><ForwardSelectContext
        __scopeSelect={__scopeSelect}
        itemContext={itemContext}
        context={context}
      >{children}</ForwardSelectContext></PortalItem>;
    }
    if (!itemContext.interactions) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`No interactions provided to Select, potentially missing Adapt`);
      }
      return null;
    }
    const { style, ...floatingProps } = itemContext.interactions.getFloatingProps();
    const { scrollbarWidth, listStyleType, overflow, ...restStyle } = style;
    return <>
      {!disableScroll && !props.unstyled && <style
        dangerouslySetInnerHTML={{
          __html: selectViewportCSS
        }}
      />}
      <FloatingFocusManager context={context.floatingContext}><AnimatePresence>{context.open ? <SelectViewportFrame
        disableClassName
        key="select-viewport"
        size={itemContext.size}
        role="presentation"
        {...viewportProps}
        ref={composedRefs}
        {...floatingProps}
        {...restStyle}
        {...!props.unstyled && {
          overflow: disableScroll ? void 0 : overflow ?? "scroll"
        }}
      >{children}</SelectViewportFrame> : null}</AnimatePresence></FloatingFocusManager>
      {
        /* keep in dom to allow for portal to the trigger... very hacky! we should fix */
      }
      {!context.open && <div style={{ display: "none" }}>{props.children}</div>}
    </>;
  }
);
const selectViewportCSS = `
.is_SelectViewport {
  scrollbar-width: none;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

.is_SelectViewport::-webkit-scrollbar{
  display:none
}
`;
export {
  SelectViewport,
  SelectViewportFrame
};
//# sourceMappingURL=SelectViewport.js.map
