"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SelectImpl_exports = {};
__export(SelectImpl_exports, {
  SelectInlineImpl: () => SelectInlineImpl
});
module.exports = __toCommonJS(SelectImpl_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_react = require("@floating-ui/react");
var import_core = require("@tamagui/core");
var React = __toESM(require("react"));
var import_react_dom = require("react-dom");
var import_constants = require("./constants");
var import_context = require("./context");
const SelectInlineImpl = (props) => {
  const {
    __scopeSelect,
    children,
    open = false,
    selectedIndexRef,
    listContentRef
  } = props;
  const selectContext = (0, import_context.useSelectContext)("SelectSheetImpl", __scopeSelect);
  const selectItemParentContext = (0, import_context.useSelectItemParentContext)(
    "SelectSheetImpl",
    __scopeSelect
  );
  const { setActiveIndex, selectedIndex, activeIndex, forceUpdate } = selectContext;
  const { setOpen, setSelectedIndex } = selectItemParentContext;
  const [scrollTop, setScrollTop] = React.useState(0);
  const touch = (0, import_core.useIsTouchDevice)();
  const listItemsRef = React.useRef([]);
  const overflowRef = React.useRef(null);
  const upArrowRef = React.useRef(null);
  const downArrowRef = React.useRef(null);
  const allowSelectRef = React.useRef(false);
  const allowMouseUpRef = React.useRef(true);
  const selectTimeoutRef = React.useRef();
  const state = React.useRef({
    isMouseOutside: false
  });
  const [controlledScrolling, setControlledScrolling] = React.useState(false);
  const [fallback, setFallback] = React.useState(false);
  const [innerOffset, setInnerOffset] = React.useState(0);
  const [blockSelection, setBlockSelection] = React.useState(false);
  const floatingStyle = React.useRef({});
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    queueMicrotask(() => {
      if (!open) {
        setScrollTop(0);
        setFallback(false);
        setActiveIndex(null);
        setControlledScrolling(false);
      }
    });
  }, [open, setActiveIndex]);
  if (import_core.isWeb && import_core.isClient) {
    (0, import_core.useIsomorphicLayoutEffect)(() => {
      if (!open)
        return;
      const mouseUp = (e) => {
        if (state.current.isMouseOutside) {
          setOpen(false);
        }
      };
      document.addEventListener("mouseup", mouseUp);
      return () => {
        document.removeEventListener("mouseup", mouseUp);
      };
    }, [open]);
  }
  const updateFloatingSize = (0, import_react.size)({
    apply({
      availableHeight,
      rects: {
        reference: { width }
      }
    }) {
      floatingStyle.current = {
        width,
        maxHeight: availableHeight
      };
    },
    padding: import_constants.WINDOW_PADDING
  });
  const { x, y, strategy, context, refs, update } = (0, import_react.useFloating)({
    open,
    onOpenChange: setOpen,
    placement: "bottom-start",
    middleware: fallback ? [
      (0, import_react.offset)(5),
      ...[
        touch ? (0, import_react.shift)({ crossAxis: true, padding: import_constants.WINDOW_PADDING }) : (0, import_react.flip)({ padding: import_constants.WINDOW_PADDING })
      ],
      updateFloatingSize
    ] : [
      (0, import_react.inner)({
        listRef: listItemsRef,
        overflowRef,
        index: selectedIndex,
        offset: innerOffset,
        onFallbackChange: setFallback,
        padding: 10,
        minItemsVisible: touch ? 10 : 4,
        referenceOverflowThreshold: 20
      }),
      updateFloatingSize
    ]
  });
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    window.addEventListener("resize", update);
    if (open) {
      update();
    }
    return () => window.removeEventListener("resize", update);
  }, [update, open]);
  const floatingRef = refs.floating;
  const showUpArrow = open && scrollTop > import_constants.SCROLL_ARROW_THRESHOLD;
  const showDownArrow = open && floatingRef.current && scrollTop < floatingRef.current.scrollHeight - floatingRef.current.clientHeight - import_constants.SCROLL_ARROW_THRESHOLD;
  const interactions = (0, import_react.useInteractions)([
    (0, import_react.useClick)(context, { event: "mousedown" }),
    (0, import_react.useDismiss)(context, { outsidePress: false }),
    (0, import_react.useRole)(context, { role: "listbox" }),
    (0, import_react.useInnerOffset)(context, {
      enabled: !fallback,
      onChange: setInnerOffset,
      overflowRef,
      scrollRef: refs.floating
    }),
    (0, import_react.useListNavigation)(context, {
      listRef: listItemsRef,
      activeIndex: activeIndex || 0,
      selectedIndex,
      onNavigate: setActiveIndex
    }),
    (0, import_react.useTypeahead)(context, {
      listRef: listContentRef,
      onMatch: open ? setActiveIndex : setSelectedIndex,
      selectedIndex,
      activeIndex
    })
  ]);
  const interactionsContext = React.useMemo(() => {
    return {
      ...interactions,
      getReferenceProps() {
        return interactions.getReferenceProps({
          ref: refs.reference,
          className: "SelectTrigger",
          onKeyDown(event) {
            if (event.key === "Enter" || event.key === " " && !context.dataRef.current.typing) {
              event.preventDefault();
              setOpen(true);
            }
          }
        });
      },
      getFloatingProps(props2) {
        return interactions.getFloatingProps({
          ref: refs.floating,
          className: "Select",
          ...props2,
          style: {
            position: strategy,
            top: y ?? "",
            left: x ?? "",
            outline: 0,
            scrollbarWidth: "none",
            ...floatingStyle.current,
            ...props2 == null ? void 0 : props2.style
          },
          onPointerEnter() {
            setControlledScrolling(false);
            state.current.isMouseOutside = false;
          },
          onPointerLeave() {
            state.current.isMouseOutside = true;
          },
          onPointerMove() {
            state.current.isMouseOutside = false;
            setControlledScrolling(false);
          },
          onKeyDown() {
            setControlledScrolling(true);
          },
          onContextMenu(e) {
            e.preventDefault();
          },
          onScroll(event) {
            (0, import_react_dom.flushSync)(() => setScrollTop(event.currentTarget.scrollTop));
          }
        });
      }
    };
  }, [refs.reference.current, refs.floating.current, y, x, interactions]);
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    if (open) {
      selectTimeoutRef.current = setTimeout(() => {
        allowSelectRef.current = true;
      }, 300);
      return () => {
        clearTimeout(selectTimeoutRef.current);
      };
    } else {
      allowSelectRef.current = false;
      allowMouseUpRef.current = true;
      setInnerOffset(0);
      setFallback(false);
      setBlockSelection(false);
    }
  }, [open]);
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    if (!open && state.current.isMouseOutside) {
      state.current.isMouseOutside = false;
    }
  }, [open]);
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    function onPointerDown(e) {
      var _a, _b, _c;
      const target = e.target;
      if (!(((_a = refs.floating.current) == null ? void 0 : _a.contains(target)) || ((_b = upArrowRef.current) == null ? void 0 : _b.contains(target)) || ((_c = downArrowRef.current) == null ? void 0 : _c.contains(target)))) {
        setOpen(false);
        setControlledScrolling(false);
      }
    }
    if (open) {
      document.addEventListener("pointerdown", onPointerDown);
      return () => {
        document.removeEventListener("pointerdown", onPointerDown);
      };
    }
  }, [open, refs, setOpen]);
  React.useEffect(() => {
    var _a, _b;
    if (open && controlledScrolling) {
      if (activeIndex != null) {
        (_a = listItemsRef.current[activeIndex]) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
      }
    }
    setScrollTop(((_b = refs.floating.current) == null ? void 0 : _b.scrollTop) ?? 0);
  }, [open, refs, controlledScrolling, activeIndex]);
  React.useEffect(() => {
    var _a;
    if (open && fallback) {
      if (selectedIndex != null) {
        (_a = listItemsRef.current[selectedIndex]) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
      }
    }
  }, [open, fallback, selectedIndex]);
  (0, import_core.useIsomorphicLayoutEffect)(() => {
    if (refs.floating.current && fallback) {
      refs.floating.current.style.maxHeight = "";
    }
  }, [refs, fallback]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_context.SelectProvider,
    {
      scope: __scopeSelect,
      ...selectContext,
      setScrollTop,
      setInnerOffset,
      fallback,
      floatingContext: context,
      activeIndex,
      canScrollDown: !!showDownArrow,
      canScrollUp: !!showUpArrow,
      controlledScrolling,
      blockSelection,
      upArrowRef,
      downArrowRef,
      update,
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_context.SelectItemParentProvider,
        {
          scope: __scopeSelect,
          ...selectItemParentContext,
          allowMouseUpRef,
          allowSelectRef,
          dataRef: context.dataRef,
          interactions: interactionsContext,
          listRef: listItemsRef,
          selectTimeoutRef,
          children
        }
      )
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SelectInlineImpl
});
//# sourceMappingURL=SelectImpl.js.map
