"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SheetImplementationCustom_exports = {};
__export(SheetImplementationCustom_exports, {
  SheetImplementationCustom: () => SheetImplementationCustom
});
module.exports = __toCommonJS(SheetImplementationCustom_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_adapt = require("@tamagui/adapt");
var import_animate_presence = require("@tamagui/animate-presence");
var import_compose_refs = require("@tamagui/compose-refs");
var import_core = require("@tamagui/core");
var import_portal = require("@tamagui/portal");
var import_use_keyboard_visible = require("@tamagui/use-keyboard-visible");
var import_react = require("react");
var import_react_native = require("react-native");
var import_constants = require("./constants");
var import_contexts = require("./contexts");
var import_helpers = require("./helpers");
var import_SheetContext = require("./SheetContext");
var import_useSheetOpenState = require("./useSheetOpenState");
var import_useSheetProviderProps = require("./useSheetProviderProps");
let hiddenSize = 10000.1;
const SheetImplementationCustom = (0, import_core.themeable)(
  (0, import_react.forwardRef)(function SheetImplementationCustom2(props, forwardedRef) {
    const parentSheet = (0, import_react.useContext)(import_contexts.ParentSheetContext);
    const {
      animationConfig,
      modal = false,
      zIndex = parentSheet.zIndex + 1,
      moveOnKeyboardChange = false,
      unmountChildrenWhenHidden = false,
      portalProps
    } = props;
    const keyboardIsVisible = (0, import_use_keyboard_visible.useKeyboardVisible)();
    const state = (0, import_useSheetOpenState.useSheetOpenState)(props);
    const [overlayComponent, setOverlayComponent] = (0, import_react.useState)(null);
    const providerProps = (0, import_useSheetProviderProps.useSheetProviderProps)(props, state, {
      onOverlayComponent: setOverlayComponent
    });
    const {
      frameSize,
      setFrameSize,
      snapPoints,
      snapPointsMode,
      hasFit,
      position,
      setPosition,
      scrollBridge,
      screenSize,
      setMaxContentSize,
      maxSnapPoint
    } = providerProps;
    const { open, controller, isHidden } = state;
    const sheetRef = (0, import_react.useRef)(null);
    const ref = (0, import_compose_refs.useComposedRefs)(forwardedRef, sheetRef);
    const [isShowingInnerSheet, setIsShowingInnerSheet] = (0, import_react.useState)(false);
    const shouldHideParentSheet = !import_core.isWeb && modal && isShowingInnerSheet;
    const parentSheetContext = (0, import_react.useContext)(import_contexts.SheetInsideSheetContext);
    const onInnerSheet = (0, import_react.useCallback)((hasChild) => {
      setIsShowingInnerSheet(hasChild);
    }, []);
    const positions = (0, import_react.useMemo)(
      () => snapPoints.map(
        (point) => getYPositions(snapPointsMode, point, screenSize, frameSize)
      ),
      [screenSize, frameSize, snapPoints, snapPointsMode]
    );
    const driver = (0, import_core.useAnimationDriver)();
    const { useAnimatedNumber, useAnimatedNumberStyle, useAnimatedNumberReaction } = driver;
    const AnimatedView = driver.View;
    (0, import_core.useIsomorphicLayoutEffect)(() => {
      if (!(parentSheetContext && open))
        return;
      parentSheetContext(true);
      return () => {
        parentSheetContext(false);
      };
    }, [parentSheetContext, open]);
    const nextParentContext = (0, import_react.useMemo)(
      () => ({
        zIndex
      }),
      [zIndex]
    );
    const animatedNumber = useAnimatedNumber(hiddenSize);
    const at = (0, import_react.useRef)(hiddenSize);
    useAnimatedNumberReaction(
      {
        value: animatedNumber,
        hostRef: sheetRef
      },
      (0, import_react.useCallback)((value) => {
        if (!driver.isReactNative)
          return;
        at.current = value;
        scrollBridge.paneY = value;
      }, [])
    );
    function stopSpring() {
      animatedNumber.stop();
      if (scrollBridge.onFinishAnimate) {
        scrollBridge.onFinishAnimate();
        scrollBridge.onFinishAnimate = void 0;
      }
    }
    const hasntMeasured = at.current === hiddenSize;
    const animateTo = (0, import_core.useEvent)((position2) => {
      if (frameSize === 0)
        return;
      let toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
      if (at.current === toValue)
        return;
      at.current = toValue;
      stopSpring();
      if (hasntMeasured || isHidden) {
        animatedNumber.setValue(screenSize, {
          type: "timing",
          duration: 0
        });
        if (isHidden) {
          return;
        }
        toValue = positions[position2];
        at.current = toValue;
      }
      animatedNumber.setValue(toValue, {
        type: "spring",
        ...animationConfig
      });
    });
    (0, import_core.useIsomorphicLayoutEffect)(() => {
      if (screenSize && hasntMeasured) {
        animatedNumber.setValue(screenSize, {
          type: "timing",
          duration: 0
        });
      }
    }, [hasntMeasured, screenSize]);
    (0, import_core.useIsomorphicLayoutEffect)(() => {
      if (!frameSize || !screenSize || isHidden || hasntMeasured && !open) {
        return;
      }
      animateTo(position);
    }, [isHidden, frameSize, screenSize, open, position]);
    const disableDrag = props.disableDrag ?? (controller == null ? void 0 : controller.disableDrag);
    const themeName = (0, import_core.useThemeName)();
    const panResponder = (0, import_react.useMemo)(
      () => {
        if (disableDrag)
          return;
        if (!frameSize)
          return;
        if (isShowingInnerSheet)
          return;
        const minY = positions[0];
        scrollBridge.paneMinY = minY;
        let startY = at.current;
        function makeUnselectable(val) {
          if (!import_constants.SHEET_HIDDEN_STYLESHEET)
            return;
          if (!val) {
            import_constants.SHEET_HIDDEN_STYLESHEET.innerText = "";
          } else {
            import_constants.SHEET_HIDDEN_STYLESHEET.innerText = ":root * { user-select: none !important; -webkit-user-select: none !important; }";
          }
        }
        const release = ({ vy, dragAt }) => {
          isExternalDrag = false;
          previouslyScrolling = false;
          makeUnselectable(false);
          const at2 = dragAt + startY;
          const end = at2 + frameSize * vy * 0.2;
          let closestPoint = 0;
          let dist = Infinity;
          for (let i = 0; i < positions.length; i++) {
            const position2 = positions[i];
            const curDist = end > position2 ? end - position2 : position2 - end;
            if (curDist < dist) {
              dist = curDist;
              closestPoint = i;
            }
          }
          setPosition(closestPoint);
          animateTo(closestPoint);
        };
        const finish = (_e, state2) => {
          release({
            vy: state2.vy,
            dragAt: state2.dy
          });
        };
        let previouslyScrolling = false;
        const onMoveShouldSet = (_e, { dy }) => {
          const isScrolled = scrollBridge.y !== 0;
          const isDraggingUp = dy < 0;
          const isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
          if (isScrolled) {
            previouslyScrolling = true;
            return false;
          }
          if (isNearTop) {
            if (!isScrolled && isDraggingUp) {
              return false;
            }
          }
          return Math.abs(dy) > 5;
        };
        const grant = () => {
          makeUnselectable(true);
          stopSpring();
          startY = at.current;
        };
        let isExternalDrag = false;
        scrollBridge.drag = (dy) => {
          if (!isExternalDrag) {
            isExternalDrag = true;
            grant();
          }
          const to = dy + startY;
          animatedNumber.setValue((0, import_helpers.resisted)(to, minY), { type: "direct" });
        };
        scrollBridge.release = release;
        return import_react_native.PanResponder.create({
          onMoveShouldSetPanResponder: onMoveShouldSet,
          onPanResponderGrant: grant,
          onPanResponderMove: (_e, { dy }) => {
            const toFull = dy + startY;
            const to = (0, import_helpers.resisted)(toFull, minY);
            animatedNumber.setValue(to, { type: "direct" });
          },
          onPanResponderEnd: finish,
          onPanResponderTerminate: finish,
          onPanResponderRelease: finish
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [disableDrag, isShowingInnerSheet, animateTo, frameSize, positions, setPosition]
    );
    const handleAnimationViewLayout = (0, import_react.useCallback)(
      (e) => {
        const next = (() => {
          var _a;
          let _ = (_a = e.nativeEvent) == null ? void 0 : _a.layout.height;
          if (import_core.isWeb && import_core.isTouchable && !open) {
            _ += 100;
          }
          return _;
        })();
        if (!next)
          return;
        setFrameSize(next);
      },
      [keyboardIsVisible]
    );
    const handleMaxContentViewLayout = (0, import_react.useCallback)(
      (e) => {
        var _a;
        const next = (_a = e.nativeEvent) == null ? void 0 : _a.layout.height;
        if (!next)
          return;
        setMaxContentSize(next);
      },
      [keyboardIsVisible]
    );
    const animatedStyle = useAnimatedNumberStyle(animatedNumber, (val) => {
      "worklet";
      const translateY = frameSize === 0 ? hiddenSize : val;
      return {
        transform: [{ translateY }]
      };
    });
    const sizeBeforeKeyboard = (0, import_react.useRef)(null);
    (0, import_react.useEffect)(() => {
      if (import_core.isWeb || !moveOnKeyboardChange)
        return;
      const keyboardDidShowListener = import_react_native.Keyboard.addListener("keyboardDidShow", (e) => {
        if (sizeBeforeKeyboard.current !== null)
          return;
        sizeBeforeKeyboard.current = animatedNumber.getValue();
        animatedNumber.setValue(
          Math.max(animatedNumber.getValue() - e.endCoordinates.height, 0)
        );
      });
      const keyboardDidHideListener = import_react_native.Keyboard.addListener("keyboardDidHide", () => {
        if (sizeBeforeKeyboard.current === null)
          return;
        animatedNumber.setValue(sizeBeforeKeyboard.current);
        sizeBeforeKeyboard.current = null;
      });
      return () => {
        keyboardDidHideListener.remove();
        keyboardDidShowListener.remove();
      };
    }, [moveOnKeyboardChange]);
    const [opacity, setOpacity] = (0, import_react.useState)(open ? 1 : 0);
    if (open && opacity === 0) {
      setOpacity(1);
    }
    (0, import_react.useEffect)(() => {
      if (!open) {
        const tm = setTimeout(() => {
          setOpacity(0);
        }, 400);
        return () => {
          clearTimeout(tm);
        };
      }
    }, [open]);
    const forcedContentHeight = hasFit ? frameSize : snapPointsMode === "percent" ? `${maxSnapPoint}%` : maxSnapPoint;
    const contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_contexts.ParentSheetContext.Provider, { value: nextParentContext, children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_SheetContext.SheetProvider, { ...providerProps, children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_animate_presence.AnimatePresence, { enterExitVariant: "open", children: shouldHideParentSheet || !open ? null : overlayComponent }),
      snapPointsMode !== "percent" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_react_native.View,
        {
          style: {
            opacity: 0,
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            pointerEvents: "none"
          },
          pointerEvents: "none",
          onLayout: handleMaxContentViewLayout
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        AnimatedView,
        {
          ref,
          ...panResponder == null ? void 0 : panResponder.panHandlers,
          onLayout: hasFit ? void 0 : handleAnimationViewLayout,
          pointerEvents: open && !shouldHideParentSheet ? "auto" : "none",
          animation: props.animation,
          style: [
            {
              position: "absolute",
              zIndex,
              width: "100%",
              height: forcedContentHeight,
              minHeight: forcedContentHeight,
              opacity
            },
            animatedStyle
          ],
          children: props.children
        }
      )
    ] }) });
    const adaptContext = (0, import_react.useContext)(import_adapt.AdaptParentContext);
    const shouldMountChildren = Boolean(opacity || !unmountChildrenWhenHidden);
    if (modal) {
      const modalContents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.Portal, { zIndex, ...portalProps, children: shouldMountChildren && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_core.Theme, { forceClassName: true, name: themeName, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_adapt.AdaptParentContext.Provider, { value: adaptContext, children: contents }) }) });
      if (import_core.isWeb) {
        return modalContents;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_contexts.SheetInsideSheetContext.Provider, { value: onInnerSheet, children: modalContents });
    }
    return contents;
  })
);
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize)
    return 0;
  if (mode === "mixed") {
    if (typeof point === "number") {
      return screenSize - Math.min(screenSize, Math.max(0, point));
    }
    if (point === "fit") {
      return screenSize - frameSize;
    }
    if (point.endsWith("%")) {
      const pct2 = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct2)) {
        console.warn("Invalid snapPoint percentage string");
        return 0;
      }
      const next = Math.round(screenSize - pct2 * screenSize);
      return next;
    }
    console.warn("Invalid snapPoint unknown value");
    return 0;
  }
  if (mode === "fit") {
    if (point === 0)
      return screenSize;
    return screenSize - Math.min(screenSize, frameSize);
  }
  if (mode === "constant" && typeof point === "number") {
    return screenSize - Math.min(screenSize, Math.max(0, point));
  }
  const pct = Math.min(100, Math.max(0, Number(point))) / 100;
  if (Number.isNaN(pct)) {
    console.warn("Invalid snapPoint percentage");
    return 0;
  }
  return Math.round(screenSize - pct * screenSize);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SheetImplementationCustom
});
//# sourceMappingURL=SheetImplementationCustom.js.map
