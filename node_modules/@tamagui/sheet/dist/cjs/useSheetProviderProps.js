"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useSheetProviderProps_exports = {};
__export(useSheetProviderProps_exports, {
  useSheetProviderProps: () => useSheetProviderProps
});
module.exports = __toCommonJS(useSheetProviderProps_exports);
var import_core = require("@tamagui/core");
var import_use_constant = require("@tamagui/use-constant");
var import_use_controllable_state = require("@tamagui/use-controllable-state");
var import_react = __toESM(require("react"));
function useSheetProviderProps(props, state, options = {}) {
  const contentRef = import_react.default.useRef(null);
  const [frameSize, setFrameSize] = (0, import_react.useState)(0);
  const [maxContentSize, setMaxContentSize] = (0, import_react.useState)(0);
  const snapPointsMode = props.snapPointsMode ?? "percent";
  const snapPointsProp = props.snapPoints ?? (snapPointsMode === "percent" ? [80] : snapPointsMode === "constant" ? [256] : ["fit"]);
  const hasFit = snapPointsProp[0] === "fit";
  const snapPoints = (0, import_react.useMemo)(
    () => props.dismissOnSnapToBottom ? [...snapPointsProp, 0] : snapPointsProp,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(snapPointsProp), props.dismissOnSnapToBottom]
  );
  const [position_, setPositionImmediate] = (0, import_use_controllable_state.useControllableState)({
    prop: props.position,
    defaultProp: props.defaultPosition || (state.open ? 0 : -1),
    onChange: props.onPositionChange,
    strategy: "most-recent-wins",
    transition: true
  });
  const position = state.open === false ? -1 : position_;
  const { open } = state;
  const setPosition = (0, import_react.useCallback)(
    (next) => {
      if (props.dismissOnSnapToBottom && next === snapPoints.length - 1) {
        state.setOpen(false);
      } else {
        setPositionImmediate(next);
      }
    },
    [props.dismissOnSnapToBottom, snapPoints.length, setPositionImmediate, state.setOpen]
  );
  if (process.env.NODE_ENV === "development") {
    if (snapPointsMode === "mixed" && snapPoints.some((p) => {
      if (typeof p === "string") {
        if (p === "fit") {
          return false;
        }
        if (p.endsWith("%")) {
          const n = Number(p.slice(0, -1));
          return n < 0 || n > 100;
        }
        return true;
      }
      return typeof p !== "number" || p < 0;
    })) {
      console.warn(
        '\u26A0\uFE0F Invalid snapPoint given, snapPoints must be positive numeric values, string percentages between 0-100%, or "fit" when snapPointsMode is mixed'
      );
    }
    if (snapPointsMode === "mixed" && snapPoints.indexOf("fit") > 0) {
      console.warn(
        '\u26A0\uFE0F Invalid snapPoint given, "fit" must be the first/largest snap point when snapPointsMode is mixed'
      );
    }
    if (snapPointsMode === "fit" && (snapPoints.length !== (props.dismissOnSnapToBottom ? 2 : 1) || snapPoints[0] !== "fit")) {
      console.warn(
        "\u26A0\uFE0F Invalid snapPoint given, there are no snap points when snapPointsMode is fit"
      );
    }
    if (snapPointsMode === "constant" && snapPoints.some((p) => typeof p !== "number" || p < 0)) {
      console.warn(
        "\u26A0\uFE0F Invalid snapPoint given, snapPoints must be positive numeric values when snapPointsMode is constant"
      );
    }
    if (snapPointsMode === "percent" && snapPoints.some((p) => typeof p !== "number" || p < 0 || p > 100)) {
      console.warn(
        "\u26A0\uFE0F Invalid snapPoint given, snapPoints must be numeric values between 0 and 100 when snapPointsMode is percent"
      );
    }
  }
  if (open && props.dismissOnSnapToBottom && position === snapPoints.length - 1) {
    setPositionImmediate(0);
  }
  const shouldSetPositionOpen = open && position < 0;
  (0, import_react.useEffect)(() => {
    if (shouldSetPositionOpen) {
      setPosition(0);
    }
  }, [setPosition, shouldSetPositionOpen]);
  const driver = (0, import_core.useAnimationDriver)();
  if (!driver) {
    throw new Error("Must set animations in tamagui.config.ts");
  }
  const scrollBridge = (0, import_use_constant.useConstant)(() => ({
    enabled: false,
    y: 0,
    paneY: 0,
    paneMinY: 0,
    scrollStartY: -1,
    drag: () => {
    },
    release: () => {
    },
    scrollLock: false
  }));
  const removeScrollEnabled = props.forceRemoveScrollEnabled ?? (open && props.modal);
  const maxSnapPoint = snapPoints[0];
  const screenSize = snapPointsMode === "percent" ? frameSize / ((typeof maxSnapPoint === "number" ? maxSnapPoint : 100) / 100) : maxContentSize;
  const providerProps = {
    screenSize,
    maxSnapPoint,
    removeScrollEnabled,
    scrollBridge,
    modal: !!props.modal,
    open: state.open,
    setOpen: state.setOpen,
    hidden: !!state.isHidden,
    contentRef,
    frameSize,
    setFrameSize,
    dismissOnOverlayPress: props.dismissOnOverlayPress ?? true,
    dismissOnSnapToBottom: props.dismissOnSnapToBottom ?? false,
    onOverlayComponent: options.onOverlayComponent,
    scope: props.__scopeSheet,
    hasFit,
    position,
    snapPoints,
    snapPointsMode,
    setMaxContentSize,
    setPosition,
    setPositionImmediate,
    onlyShowFrame: false
  };
  return providerProps;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useSheetProviderProps
});
//# sourceMappingURL=useSheetProviderProps.js.map
