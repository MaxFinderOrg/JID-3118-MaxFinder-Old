import { AdaptParentContext } from "@tamagui/adapt";
import { AnimatePresence } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import {
  Theme,
  isTouchable,
  isWeb,
  themeable,
  useAnimationDriver,
  useEvent,
  useIsomorphicLayoutEffect,
  useThemeName
} from "@tamagui/core";
import { Portal } from "@tamagui/portal";
import { useKeyboardVisible } from "@tamagui/use-keyboard-visible";
import {
  forwardRef,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState
} from "react";
import {
  Keyboard,
  PanResponder,
  View
} from "react-native";
import { SHEET_HIDDEN_STYLESHEET } from "./constants";
import { ParentSheetContext, SheetInsideSheetContext } from "./contexts";
import { resisted } from "./helpers";
import { SheetProvider } from "./SheetContext";
import { useSheetOpenState } from "./useSheetOpenState";
import { useSheetProviderProps } from "./useSheetProviderProps";
let hiddenSize = 10000.1;
const SheetImplementationCustom = themeable(
  forwardRef(function SheetImplementationCustom2(props, forwardedRef) {
    const parentSheet = useContext(ParentSheetContext);
    const {
      animationConfig,
      modal = false,
      zIndex = parentSheet.zIndex + 1,
      moveOnKeyboardChange = false,
      unmountChildrenWhenHidden = false,
      portalProps
    } = props;
    const keyboardIsVisible = useKeyboardVisible();
    const state = useSheetOpenState(props);
    const [overlayComponent, setOverlayComponent] = useState(null);
    const providerProps = useSheetProviderProps(props, state, {
      onOverlayComponent: setOverlayComponent
    });
    const {
      frameSize,
      setFrameSize,
      snapPoints,
      snapPointsMode,
      hasFit,
      position,
      setPosition,
      scrollBridge,
      screenSize,
      setMaxContentSize,
      maxSnapPoint
    } = providerProps;
    const { open, controller, isHidden } = state;
    const sheetRef = useRef(null);
    const ref = useComposedRefs(forwardedRef, sheetRef);
    const [isShowingInnerSheet, setIsShowingInnerSheet] = useState(false);
    const shouldHideParentSheet = !isWeb && modal && isShowingInnerSheet;
    const parentSheetContext = useContext(SheetInsideSheetContext);
    const onInnerSheet = useCallback((hasChild) => {
      setIsShowingInnerSheet(hasChild);
    }, []);
    const positions = useMemo(
      () => snapPoints.map(
        (point) => getYPositions(snapPointsMode, point, screenSize, frameSize)
      ),
      [screenSize, frameSize, snapPoints, snapPointsMode]
    );
    const driver = useAnimationDriver();
    const { useAnimatedNumber, useAnimatedNumberStyle, useAnimatedNumberReaction } = driver;
    const AnimatedView = driver.View;
    useIsomorphicLayoutEffect(() => {
      if (!(parentSheetContext && open))
        return;
      parentSheetContext(true);
      return () => {
        parentSheetContext(false);
      };
    }, [parentSheetContext, open]);
    const nextParentContext = useMemo(
      () => ({
        zIndex
      }),
      [zIndex]
    );
    const animatedNumber = useAnimatedNumber(hiddenSize);
    const at = useRef(hiddenSize);
    useAnimatedNumberReaction(
      {
        value: animatedNumber,
        hostRef: sheetRef
      },
      useCallback((value) => {
        if (!driver.isReactNative)
          return;
        at.current = value;
        scrollBridge.paneY = value;
      }, [])
    );
    function stopSpring() {
      animatedNumber.stop();
      if (scrollBridge.onFinishAnimate) {
        scrollBridge.onFinishAnimate();
        scrollBridge.onFinishAnimate = void 0;
      }
    }
    const hasntMeasured = at.current === hiddenSize;
    const animateTo = useEvent((position2) => {
      if (frameSize === 0)
        return;
      let toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
      if (at.current === toValue)
        return;
      at.current = toValue;
      stopSpring();
      if (hasntMeasured || isHidden) {
        animatedNumber.setValue(screenSize, {
          type: "timing",
          duration: 0
        });
        if (isHidden) {
          return;
        }
        toValue = positions[position2];
        at.current = toValue;
      }
      animatedNumber.setValue(toValue, {
        type: "spring",
        ...animationConfig
      });
    });
    useIsomorphicLayoutEffect(() => {
      if (screenSize && hasntMeasured) {
        animatedNumber.setValue(screenSize, {
          type: "timing",
          duration: 0
        });
      }
    }, [hasntMeasured, screenSize]);
    useIsomorphicLayoutEffect(() => {
      if (!frameSize || !screenSize || isHidden || hasntMeasured && !open) {
        return;
      }
      animateTo(position);
    }, [isHidden, frameSize, screenSize, open, position]);
    const disableDrag = props.disableDrag ?? controller?.disableDrag;
    const themeName = useThemeName();
    const panResponder = useMemo(
      () => {
        if (disableDrag)
          return;
        if (!frameSize)
          return;
        if (isShowingInnerSheet)
          return;
        const minY = positions[0];
        scrollBridge.paneMinY = minY;
        let startY = at.current;
        function makeUnselectable(val) {
          if (!SHEET_HIDDEN_STYLESHEET)
            return;
          if (!val) {
            SHEET_HIDDEN_STYLESHEET.innerText = "";
          } else {
            SHEET_HIDDEN_STYLESHEET.innerText = ":root * { user-select: none !important; -webkit-user-select: none !important; }";
          }
        }
        const release = ({ vy, dragAt }) => {
          isExternalDrag = false;
          previouslyScrolling = false;
          makeUnselectable(false);
          const at2 = dragAt + startY;
          const end = at2 + frameSize * vy * 0.2;
          let closestPoint = 0;
          let dist = Infinity;
          for (let i = 0; i < positions.length; i++) {
            const position2 = positions[i];
            const curDist = end > position2 ? end - position2 : position2 - end;
            if (curDist < dist) {
              dist = curDist;
              closestPoint = i;
            }
          }
          setPosition(closestPoint);
          animateTo(closestPoint);
        };
        const finish = (_e, state2) => {
          release({
            vy: state2.vy,
            dragAt: state2.dy
          });
        };
        let previouslyScrolling = false;
        const onMoveShouldSet = (_e, { dy }) => {
          const isScrolled = scrollBridge.y !== 0;
          const isDraggingUp = dy < 0;
          const isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
          if (isScrolled) {
            previouslyScrolling = true;
            return false;
          }
          if (isNearTop) {
            if (!isScrolled && isDraggingUp) {
              return false;
            }
          }
          return Math.abs(dy) > 5;
        };
        const grant = () => {
          makeUnselectable(true);
          stopSpring();
          startY = at.current;
        };
        let isExternalDrag = false;
        scrollBridge.drag = (dy) => {
          if (!isExternalDrag) {
            isExternalDrag = true;
            grant();
          }
          const to = dy + startY;
          animatedNumber.setValue(resisted(to, minY), { type: "direct" });
        };
        scrollBridge.release = release;
        return PanResponder.create({
          onMoveShouldSetPanResponder: onMoveShouldSet,
          onPanResponderGrant: grant,
          onPanResponderMove: (_e, { dy }) => {
            const toFull = dy + startY;
            const to = resisted(toFull, minY);
            animatedNumber.setValue(to, { type: "direct" });
          },
          onPanResponderEnd: finish,
          onPanResponderTerminate: finish,
          onPanResponderRelease: finish
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [disableDrag, isShowingInnerSheet, animateTo, frameSize, positions, setPosition]
    );
    const handleAnimationViewLayout = useCallback(
      (e) => {
        const next = (() => {
          let _ = e.nativeEvent?.layout.height;
          if (isWeb && isTouchable && !open) {
            _ += 100;
          }
          return _;
        })();
        if (!next)
          return;
        setFrameSize(next);
      },
      [keyboardIsVisible]
    );
    const handleMaxContentViewLayout = useCallback(
      (e) => {
        const next = e.nativeEvent?.layout.height;
        if (!next)
          return;
        setMaxContentSize(next);
      },
      [keyboardIsVisible]
    );
    const animatedStyle = useAnimatedNumberStyle(animatedNumber, (val) => {
      "worklet";
      const translateY = frameSize === 0 ? hiddenSize : val;
      return {
        transform: [{ translateY }]
      };
    });
    const sizeBeforeKeyboard = useRef(null);
    useEffect(() => {
      if (isWeb || !moveOnKeyboardChange)
        return;
      const keyboardDidShowListener = Keyboard.addListener("keyboardDidShow", (e) => {
        if (sizeBeforeKeyboard.current !== null)
          return;
        sizeBeforeKeyboard.current = animatedNumber.getValue();
        animatedNumber.setValue(
          Math.max(animatedNumber.getValue() - e.endCoordinates.height, 0)
        );
      });
      const keyboardDidHideListener = Keyboard.addListener("keyboardDidHide", () => {
        if (sizeBeforeKeyboard.current === null)
          return;
        animatedNumber.setValue(sizeBeforeKeyboard.current);
        sizeBeforeKeyboard.current = null;
      });
      return () => {
        keyboardDidHideListener.remove();
        keyboardDidShowListener.remove();
      };
    }, [moveOnKeyboardChange]);
    const [opacity, setOpacity] = useState(open ? 1 : 0);
    if (open && opacity === 0) {
      setOpacity(1);
    }
    useEffect(() => {
      if (!open) {
        const tm = setTimeout(() => {
          setOpacity(0);
        }, 400);
        return () => {
          clearTimeout(tm);
        };
      }
    }, [open]);
    const forcedContentHeight = hasFit ? frameSize : snapPointsMode === "percent" ? `${maxSnapPoint}%` : maxSnapPoint;
    const contents = <ParentSheetContext.Provider value={nextParentContext}><SheetProvider {...providerProps}>
      <AnimatePresence enterExitVariant="open">{shouldHideParentSheet || !open ? null : overlayComponent}</AnimatePresence>
      {snapPointsMode !== "percent" && <View
        style={{
          opacity: 0,
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          pointerEvents: "none"
        }}
        pointerEvents="none"
        onLayout={handleMaxContentViewLayout}
      />}
      <AnimatedView
        ref={ref}
        {...panResponder?.panHandlers}
        onLayout={hasFit ? void 0 : handleAnimationViewLayout}
        pointerEvents={open && !shouldHideParentSheet ? "auto" : "none"}
        animation={props.animation}
        style={[
          {
            position: "absolute",
            zIndex,
            width: "100%",
            height: forcedContentHeight,
            minHeight: forcedContentHeight,
            opacity
          },
          animatedStyle
        ]}
      >{props.children}</AnimatedView>
    </SheetProvider></ParentSheetContext.Provider>;
    const adaptContext = useContext(AdaptParentContext);
    const shouldMountChildren = Boolean(opacity || !unmountChildrenWhenHidden);
    if (modal) {
      const modalContents = <Portal zIndex={zIndex} {...portalProps}>{shouldMountChildren && <Theme forceClassName name={themeName}><AdaptParentContext.Provider value={adaptContext}>{contents}</AdaptParentContext.Provider></Theme>}</Portal>;
      if (isWeb) {
        return modalContents;
      }
      return <SheetInsideSheetContext.Provider value={onInnerSheet}>{modalContents}</SheetInsideSheetContext.Provider>;
    }
    return contents;
  })
);
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize)
    return 0;
  if (mode === "mixed") {
    if (typeof point === "number") {
      return screenSize - Math.min(screenSize, Math.max(0, point));
    }
    if (point === "fit") {
      return screenSize - frameSize;
    }
    if (point.endsWith("%")) {
      const pct2 = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct2)) {
        console.warn("Invalid snapPoint percentage string");
        return 0;
      }
      const next = Math.round(screenSize - pct2 * screenSize);
      return next;
    }
    console.warn("Invalid snapPoint unknown value");
    return 0;
  }
  if (mode === "fit") {
    if (point === 0)
      return screenSize;
    return screenSize - Math.min(screenSize, frameSize);
  }
  if (mode === "constant" && typeof point === "number") {
    return screenSize - Math.min(screenSize, Math.max(0, point));
  }
  const pct = Math.min(100, Math.max(0, Number(point))) / 100;
  if (Number.isNaN(pct)) {
    console.warn("Invalid snapPoint percentage");
    return 0;
  }
  return Math.round(screenSize - pct * screenSize);
}
export {
  SheetImplementationCustom
};
//# sourceMappingURL=SheetImplementationCustom.js.map
