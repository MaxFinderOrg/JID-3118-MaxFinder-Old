import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import { useEvent } from "@tamagui/use-event";
import NextHead from "next/head";
import * as React from "react";
import { memo, useEffect, useMemo, useRef, useState } from "react";
import { MEDIA, colorSchemes } from "./constants";
import { getSystemTheme, getTheme } from "./helpers";
import { ThemeSettingContext } from "./ThemeSettingContext";
import { useIsomorphicLayoutEffect } from "./useIsomorphicLayoutEffect";
const NextThemeProvider = memo(
  ({
    forcedTheme,
    disableTransitionOnChange = true,
    enableSystem = true,
    enableColorScheme = true,
    storageKey = "theme",
    themes = colorSchemes,
    defaultTheme = enableSystem ? "system" : "light",
    attribute = "class",
    skipNextHead,
    onChangeTheme,
    value = {
      dark: "t_dark",
      light: "t_light"
    },
    children
  }) => {
    const [theme, setThemeState] = useState(() => getTheme(storageKey, defaultTheme));
    const [resolvedTheme, setResolvedTheme] = useState(() => getTheme(storageKey));
    const attrs = !value ? themes : Object.values(value);
    const handleMediaQuery = useEvent((e) => {
      const systemTheme2 = getSystemTheme(e);
      React.startTransition(() => {
        setResolvedTheme(systemTheme2);
      });
      if (theme === "system" && !forcedTheme) {
        handleChangeTheme(systemTheme2, false);
      }
    });
    const mediaListener = useRef(handleMediaQuery);
    mediaListener.current = handleMediaQuery;
    const handleChangeTheme = useEvent(
      (theme2, updateStorage = true, updateDOM = true) => {
        let name = (value == null ? void 0 : value[theme2]) || theme2;
        if (updateStorage) {
          try {
            localStorage.setItem(storageKey, theme2);
          } catch (e) {
          }
        }
        if (theme2 === "system" && enableSystem) {
          const resolved = getSystemTheme();
          name = (value == null ? void 0 : value[resolved]) || resolved;
        }
        onChangeTheme == null ? void 0 : onChangeTheme(name.replace("t_", ""));
        if (updateDOM) {
          const d = document.documentElement;
          if (attribute === "class") {
            d.classList.remove(...attrs);
            d.classList.add(name);
          } else {
            d.setAttribute(attribute, name);
          }
        }
      }
    );
    useIsomorphicLayoutEffect(() => {
      const handler = (...args) => mediaListener.current(...args);
      const media = window.matchMedia(MEDIA);
      media.addListener(handler);
      handler(media);
      return () => {
        media.removeListener(handler);
      };
    }, []);
    const set = useEvent((newTheme) => {
      if (forcedTheme) {
        handleChangeTheme(newTheme, true, false);
      } else {
        handleChangeTheme(newTheme);
      }
      setThemeState(newTheme);
    });
    useEffect(() => {
      const handleStorage = (e) => {
        if (e.key !== storageKey) {
          return;
        }
        const theme2 = e.newValue || defaultTheme;
        set(theme2);
      };
      window.addEventListener("storage", handleStorage);
      return () => {
        window.removeEventListener("storage", handleStorage);
      };
    }, [defaultTheme, set, storageKey]);
    useIsomorphicLayoutEffect(() => {
      if (!enableColorScheme)
        return;
      const colorScheme = (
        // If theme is forced to light or dark, use that
        forcedTheme && colorSchemes.includes(forcedTheme) ? forcedTheme : (
          // If regular theme is light or dark
          theme && colorSchemes.includes(theme) ? theme : (
            // If theme is system, use the resolved version
            theme === "system" ? resolvedTheme || null : null
          )
        )
      );
      const userPrefers = typeof window !== "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      const wePrefer = colorScheme || "light";
      if (userPrefers !== wePrefer) {
        document.documentElement.style.setProperty("color-scheme", colorScheme);
      }
    }, [enableColorScheme, theme, resolvedTheme, forcedTheme]);
    const toggle = useEvent(() => {
      const order = resolvedTheme === "dark" ? ["system", "light", "dark"] : ["system", "dark", "light"];
      const next = order[(order.indexOf(theme) + 1) % order.length];
      set(next);
    });
    const contextResolvedTheme = theme === "system" ? resolvedTheme : theme;
    const systemTheme = enableSystem ? resolvedTheme : void 0;
    const contextValue = useMemo(() => {
      const value2 = {
        theme,
        current: theme,
        set,
        toggle,
        forcedTheme,
        resolvedTheme: contextResolvedTheme,
        themes: enableSystem ? [...themes, "system"] : themes,
        systemTheme
      };
      return value2;
    }, [
      theme,
      set,
      toggle,
      forcedTheme,
      contextResolvedTheme,
      enableSystem,
      themes,
      systemTheme
    ]);
    return /* @__PURE__ */ jsxs(ThemeSettingContext.Provider, { value: contextValue, children: [
      /* @__PURE__ */ jsx(
        ThemeScript,
        {
          ...{
            forcedTheme,
            storageKey,
            systemTheme: resolvedTheme,
            attribute,
            value,
            enableSystem,
            defaultTheme,
            attrs,
            skipNextHead
          }
        }
      ),
      useMemo(() => children, [children])
    ] });
  }
);
const ThemeScript = memo(
  ({
    forcedTheme,
    storageKey,
    attribute,
    enableSystem,
    defaultTheme,
    value,
    attrs,
    skipNextHead
  }) => {
    const optimization = (() => {
      if (attribute === "class") {
        const removeClasses = attrs.map((t) => `d.remove('${t}')`).join(";");
        return `var d=document.documentElement.classList;${removeClasses};`;
      } else {
        return `var d=document.documentElement;`;
      }
    })();
    const updateDOM = (name, literal) => {
      name = (value == null ? void 0 : value[name]) || name;
      const val = literal ? name : `'${name}'`;
      if (attribute === "class") {
        return `d.add(${val})`;
      }
      return `d.setAttribute('${attribute}', ${val})`;
    };
    const defaultSystem = defaultTheme === "system";
    const contents = /* @__PURE__ */ jsx(Fragment, { children: forcedTheme ? /* @__PURE__ */ jsx(
      "script",
      {
        dangerouslySetInnerHTML: {
          // These are minified via Terser and then updated by hand, don't recommend
          __html: `!function(){${optimization}${updateDOM(forcedTheme)}}()`
        }
      },
      "next-themes-script"
    ) : enableSystem ? /* @__PURE__ */ jsx(
      "script",
      {
        dangerouslySetInnerHTML: {
          __html: `!function(){try {${optimization}var e=localStorage.getItem('${storageKey}');${!defaultSystem ? updateDOM(defaultTheme) + ";" : ""}if("system"===e||(!e&&${defaultSystem})){var t="${MEDIA}",m=window.matchMedia(t);m.media!==t||m.matches?${updateDOM(
            "dark"
          )}:${updateDOM("light")}}else if(e) ${value ? `var x=${JSON.stringify(value)};` : ""}${updateDOM(value ? "x[e]" : "e", true)}}catch(e){}}()`
        }
      },
      "next-themes-script"
    ) : /* @__PURE__ */ jsx(
      "script",
      {
        dangerouslySetInnerHTML: {
          __html: `!function(){try{${optimization}var e=localStorage.getItem("${storageKey}");if(e){${value ? `var x=${JSON.stringify(value)};` : ""}${updateDOM(value ? "x[e]" : "e", true)}}else{${updateDOM(
            defaultTheme
          )};}}catch(t){}}();`
        }
      },
      "next-themes-script"
    ) });
    if (skipNextHead)
      return contents;
    return /* @__PURE__ */ jsx(NextHead, { children: contents });
  },
  (prevProps, nextProps) => {
    if (prevProps.forcedTheme !== nextProps.forcedTheme)
      return false;
    return true;
  }
);
export {
  NextThemeProvider
};
//# sourceMappingURL=NextThemeProvider.js.map
