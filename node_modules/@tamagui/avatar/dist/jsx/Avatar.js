import {
  getTokens,
  getVariableValue,
  styled,
  withStaticProperties
} from "@tamagui/core";
import { createContextScope } from "@tamagui/create-context";
import { Image } from "@tamagui/image";
import { Square, getShapeSize } from "@tamagui/shapes";
import { YStack } from "@tamagui/stacks";
import * as React from "react";
const AVATAR_NAME = "Avatar";
const [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);
const [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
const IMAGE_NAME = "AvatarImage";
const AvatarImage = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, src, onLoadingStatusChange = () => {
    }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const [status, setStatus] = React.useState("idle");
    const shapeSize = getVariableValue(
      getShapeSize(
        context.size,
        // @ts-expect-error
        { tokens: getTokens() }
      )?.width
    );
    React.useEffect(() => {
      setStatus("idle");
    }, [JSON.stringify(src)]);
    React.useEffect(() => {
      onLoadingStatusChange(status);
      context.onImageLoadingStatusChange(status);
    }, [status]);
    return <YStack fullscreen zIndex={1}><Image
      fullscreen
      {...typeof shapeSize === "number" && !isNaN(shapeSize) && {
        width: shapeSize,
        height: shapeSize
      }}
      {...imageProps}
      ref={forwardedRef}
      src={src}
      onError={() => {
        setStatus("error");
      }}
      onLoad={() => {
        setStatus("loaded");
      }}
    /></YStack>;
  }
);
AvatarImage.displayName = IMAGE_NAME;
const FALLBACK_NAME = "AvatarFallback";
const AvatarFallbackFrame = styled(YStack, {
  name: FALLBACK_NAME,
  position: "absolute",
  fullscreen: true,
  zIndex: 0
});
const AvatarFallback = AvatarFallbackFrame.extractable(
  React.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, delayMs, ...fallbackProps } = props;
      const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
      const [canRender, setCanRender] = React.useState(delayMs === void 0);
      React.useEffect(() => {
        if (delayMs !== void 0) {
          const timerId = setTimeout(() => setCanRender(true), delayMs);
          return () => clearTimeout(timerId);
        }
      }, [delayMs]);
      return canRender && context.imageLoadingStatus !== "loaded" ? <AvatarFallbackFrame {...fallbackProps} ref={forwardedRef} /> : null;
    }
  )
);
AvatarFallback.displayName = FALLBACK_NAME;
const AvatarFrame = styled(Square, {
  name: AVATAR_NAME,
  position: "relative",
  overflow: "hidden"
});
const Avatar = withStaticProperties(
  React.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, size = "$true", ...avatarProps } = props;
      const [imageLoadingStatus, setImageLoadingStatus] = React.useState("idle");
      return <AvatarProvider
        size={size}
        scope={__scopeAvatar}
        imageLoadingStatus={imageLoadingStatus}
        onImageLoadingStatusChange={setImageLoadingStatus}
      ><AvatarFrame size={size} {...avatarProps} ref={forwardedRef} /></AvatarProvider>;
    }
  ),
  {
    Image: AvatarImage,
    Fallback: AvatarFallback
  }
);
Avatar.displayName = AVATAR_NAME;
export {
  Avatar,
  AvatarFallback,
  AvatarFallbackFrame,
  AvatarFrame,
  AvatarImage,
  createAvatarScope
};
//# sourceMappingURL=Avatar.js.map
