"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Popover_exports = {};
__export(Popover_exports, {
  Popover: () => Popover,
  PopoverAnchor: () => PopoverAnchor,
  PopoverArrow: () => PopoverArrow,
  PopoverClose: () => PopoverClose,
  PopoverContent: () => PopoverContent,
  PopoverContext: () => PopoverContext,
  PopoverTrigger: () => PopoverTrigger,
  usePopoverContext: () => usePopoverContext
});
module.exports = __toCommonJS(Popover_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_polyfill_dev = require("@tamagui/polyfill-dev");
var import_adapt = require("@tamagui/adapt");
var import_animate = require("@tamagui/animate");
var import_aria_hidden = require("@tamagui/aria-hidden");
var import_compose_refs = require("@tamagui/compose-refs");
var import_core = require("@tamagui/core");
var import_floating = require("@tamagui/floating");
var import_focus_scope = require("@tamagui/focus-scope");
var import_popper = require("@tamagui/popper");
var import_portal = require("@tamagui/portal");
var import_remove_scroll = require("@tamagui/remove-scroll");
var import_sheet = require("@tamagui/sheet");
var import_stacks = require("@tamagui/stacks");
var import_use_controllable_state = require("@tamagui/use-controllable-state");
var React = __toESM(require("react"));
var import_react_freeze = require("react-freeze");
var import_react_native = require("react-native");
var import_useFloatingContext = require("./useFloatingContext");
const PopoverContext = (0, import_core.createStyledContext)({});
const usePopoverContext = () => React.useContext(PopoverContext);
const PopoverAnchor = React.forwardRef(
  function PopoverAnchor2(props, forwardedRef) {
    const context = usePopoverContext();
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.PopperAnchor, { ...props, ref: forwardedRef });
  }
);
const PopoverTrigger = React.forwardRef(
  function PopoverTrigger2(props, forwardedRef) {
    const context = usePopoverContext();
    const composedTriggerRef = (0, import_compose_refs.useComposedRefs)(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_core.View,
      {
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "data-state": getState(context.open),
        ...props,
        ref: composedTriggerRef,
        onPress: (0, import_core.composeEventHandlers)(props.onPress, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.PopperAnchor, { asChild: true, children: trigger });
  }
);
const PopoverContent = import_popper.PopperContentFrame.extractable(
  React.forwardRef(
    function PopoverContent2(props, forwardedRef) {
      const {
        allowPinchZoom,
        trapFocus,
        disableRemoveScroll = true,
        zIndex,
        ...contentImplProps
      } = props;
      const context = usePopoverContext();
      const contentRef = React.useRef(null);
      const composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, contentRef);
      const isRightClickOutsideRef = React.useRef(false);
      React.useEffect(() => {
        if (!context.open)
          return;
        const content = contentRef.current;
        if (content)
          return (0, import_aria_hidden.hideOthers)(content);
      }, [context.open]);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContentPortal, { zIndex: props.zIndex, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_core.Stack, { pointerEvents: context.open ? "auto" : "none", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        PopoverContentImpl,
        {
          ...contentImplProps,
          disableRemoveScroll,
          ref: composedRefs,
          trapFocus: trapFocus ?? context.open,
          disableOutsidePointerEvents: true,
          onCloseAutoFocus: (0, import_core.composeEventHandlers)(props.onCloseAutoFocus, (event) => {
            var _a;
            event.preventDefault();
            if (!isRightClickOutsideRef.current)
              (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
          }),
          onPointerDownOutside: (0, import_core.composeEventHandlers)(
            props.onPointerDownOutside,
            (event) => {
              const originalEvent = event.detail.originalEvent;
              const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
              const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
              isRightClickOutsideRef.current = isRightClick;
            },
            { checkDefaultPrevented: false }
          ),
          onFocusOutside: (0, import_core.composeEventHandlers)(
            props.onFocusOutside,
            (event) => event.preventDefault(),
            { checkDefaultPrevented: false }
          )
        }
      ) }) });
    }
  )
);
function PopoverRepropagateContext(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.PopperContext.Provider, { ...props.popperContext, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContext.Provider, { ...props.context, children: props.children }) });
}
function PopoverContentPortal(props) {
  const zIndex = props.zIndex ?? 15e4;
  const context = usePopoverContext();
  const popperContext = (0, import_popper.usePopperContext)();
  const themeName = (0, import_core.useThemeName)();
  let contents = props.children;
  if (import_react_native.Platform.OS === "android" || import_react_native.Platform.OS === "ios") {
    contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverRepropagateContext, { popperContext, context, children: props.children });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.Portal, { zIndex, children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_core.Theme, { forceClassName: true, name: themeName, children: [
    !!context.open && !context.breakpointActive && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_stacks.YStack,
      {
        fullscreen: true,
        onPress: (0, import_core.composeEventHandlers)(props.onPress, context.onOpenToggle)
      }
    ),
    contents
  ] }) });
}
const PopoverContentImpl = React.forwardRef(function PopoverContentImpl2(props, forwardedRef) {
  const {
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    disableFocusScope,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    children,
    disableRemoveScroll,
    freezeContentsWhenHidden,
    ...contentProps
  } = props;
  const context = usePopoverContext();
  const { open, keepChildrenMounted } = context;
  const popperContext = (0, import_popper.usePopperContext)();
  const [isFullyHidden, setIsFullyHidden] = React.useState(!context.open);
  const contents = React.useMemo(() => {
    return import_core.isWeb ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { display: "contents" }, children }) : children;
  }, [children]);
  if (open && isFullyHidden) {
    setIsFullyHidden(false);
  }
  if (!keepChildrenMounted) {
    if (isFullyHidden) {
      return null;
    }
  }
  if (context.breakpointActive) {
    const childrenWithoutScrollView = React.Children.toArray(children).map((child) => {
      if (React.isValidElement(child)) {
        if (child.type === import_react_native.ScrollView) {
          return child.props.children;
        }
      }
      return child;
    });
    let content = childrenWithoutScrollView;
    if (import_react_native.Platform.OS === "android" || import_react_native.Platform.OS === "ios") {
      content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.PopperContext.Provider, { ...popperContext, children: childrenWithoutScrollView });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.PortalItem, { hostName: `${context.id}PopoverContents`, children: content });
  }
  const freeze = Boolean(isFullyHidden && freezeContentsWhenHidden);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_animate.Animate,
    {
      type: "presence",
      present: Boolean(open),
      keepChildrenMounted,
      onExitComplete: () => {
        setIsFullyHidden(true);
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        FreezeToLastContents,
        {
          freeze,
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_popper.PopperContent,
            {
              "data-state": getState(open),
              id: context.contentId,
              ref: forwardedRef,
              ...contentProps,
              children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_remove_scroll.RemoveScroll,
                {
                  enabled: disableRemoveScroll ? false : open,
                  allowPinchZoom: true,
                  removeScrollBar: false,
                  style: {
                    display: "contents"
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    import_focus_scope.FocusScope,
                    {
                      loop: true,
                      enabled: disableFocusScope ? false : open,
                      trapped: trapFocus,
                      onMountAutoFocus: onOpenAutoFocus,
                      onUnmountAutoFocus: onCloseAutoFocus,
                      children: contents
                    }
                  )
                }
              )
            },
            context.contentId
          )
        }
      )
    }
  );
});
const FreezeToLastContents = (props) => {
  const last = React.useRef();
  if (!props.freeze) {
    last.current = props.children;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react_freeze.Freeze, { placeholder: last.current, ...props });
};
const PopoverClose = React.forwardRef(
  function PopoverClose2(props, forwardedRef) {
    const context = usePopoverContext();
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_stacks.YStack,
      {
        ...props,
        ref: forwardedRef,
        componentName: "PopoverClose",
        onPress: (0, import_core.composeEventHandlers)(
          props.onPress,
          () => context.onOpenChange(false)
        )
      }
    );
  }
);
const PopoverArrow = React.forwardRef(
  function PopoverArrow2(props, forwardedRef) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.PopperArrow, { componentName: "PopoverArrow", ...props, ref: forwardedRef });
  }
);
const Popover = (0, import_core.withStaticProperties)(
  function Popover2(props) {
    const {
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      keepChildrenMounted,
      ...restProps
    } = props;
    const id = React.useId();
    const { when, AdaptProvider } = (0, import_adapt.useAdaptParent)({
      Contents: React.useCallback(() => {
        return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.PortalHost, { name: `${id}PopoverContents` });
      }, [])
    });
    const sheetBreakpoint = when;
    const triggerRef = React.useRef(null);
    const [hasCustomAnchor, setHasCustomAnchor] = React.useState(false);
    const [open, setOpen] = (0, import_use_controllable_state.useControllableState)({
      prop: openProp,
      defaultProp: defaultOpen || false,
      onChange: onOpenChange
    });
    const breakpointActive = useSheetBreakpointActive(sheetBreakpoint);
    const floatingContext = (0, import_useFloatingContext.useFloatingContext)({ open, setOpen, breakpointActive });
    const popoverContext = {
      id,
      sheetBreakpoint,
      contentId: React.useId(),
      triggerRef,
      open,
      breakpointActive,
      onOpenChange: setOpen,
      onOpenToggle: (0, import_core.useEvent)(() => {
        if (open && breakpointActive) {
          return;
        }
        setOpen(!open);
      }),
      hasCustomAnchor,
      onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(false), []),
      keepChildrenMounted
    };
    const contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.Popper, { stayInFrame: true, ...restProps, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContext.Provider, { ...popoverContext, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverSheetController, { onOpenChange: setOpen, children }) }) });
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AdaptProvider, { children: import_core.isWeb ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_floating.FloatingOverrideContext.Provider, { value: floatingContext, children: contents }) : contents });
  },
  {
    Anchor: PopoverAnchor,
    Arrow: PopoverArrow,
    Trigger: PopoverTrigger,
    Content: PopoverContent,
    Close: PopoverClose,
    Adapt: import_adapt.Adapt,
    ScrollView: import_react_native.ScrollView,
    Sheet: import_sheet.Sheet.Controlled
  }
);
function getState(open) {
  return open ? "open" : "closed";
}
const PopoverSheetController = (props) => {
  const context = usePopoverContext();
  const showSheet = useShowPopoverSheet(context);
  const breakpointActive = context.breakpointActive;
  const getShowSheet = (0, import_core.useGet)(showSheet);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_sheet.SheetController,
    {
      onOpenChange: (val) => {
        if (getShowSheet()) {
          props.onOpenChange(val);
        }
      },
      open: context.open,
      hidden: breakpointActive === false,
      children: props.children
    }
  );
};
const useSheetBreakpointActive = (breakpoint) => {
  const media = (0, import_core.useMedia)();
  if (typeof breakpoint === "boolean" || !breakpoint) {
    return !!breakpoint;
  }
  return media[breakpoint];
};
const useShowPopoverSheet = (context) => {
  const breakpointActive = useSheetBreakpointActive(context.sheetBreakpoint);
  return context.open === false ? false : breakpointActive;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Popover,
  PopoverAnchor,
  PopoverArrow,
  PopoverClose,
  PopoverContent,
  PopoverContext,
  PopoverTrigger,
  usePopoverContext
});
//# sourceMappingURL=Popover.js.map
