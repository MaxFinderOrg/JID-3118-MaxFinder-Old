import "@tamagui/polyfill-dev";
import { Adapt, useAdaptParent } from "@tamagui/adapt";
import { Animate } from "@tamagui/animate";
import { hideOthers } from "@tamagui/aria-hidden";
import { useComposedRefs } from "@tamagui/compose-refs";
import {
  Stack,
  Theme,
  View,
  composeEventHandlers,
  createStyledContext,
  isWeb,
  useEvent,
  useGet,
  useMedia,
  useThemeName,
  withStaticProperties
} from "@tamagui/core";
import { FloatingOverrideContext } from "@tamagui/floating";
import { FocusScope } from "@tamagui/focus-scope";
import {
  Popper,
  PopperAnchor,
  PopperArrow,
  PopperContent,
  PopperContentFrame,
  PopperContext,
  usePopperContext
} from "@tamagui/popper";
import { Portal, PortalHost, PortalItem } from "@tamagui/portal";
import { RemoveScroll } from "@tamagui/remove-scroll";
import { Sheet, SheetController } from "@tamagui/sheet";
import { YStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import * as React from "react";
import { Freeze } from "react-freeze";
import { Platform, ScrollView } from "react-native";
import { useFloatingContext } from "./useFloatingContext";
const PopoverContext = createStyledContext({});
const usePopoverContext = () => React.useContext(PopoverContext);
const PopoverAnchor = React.forwardRef(
  function PopoverAnchor2(props, forwardedRef) {
    const context = usePopoverContext();
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return <PopperAnchor {...props} ref={forwardedRef} />;
  }
);
const PopoverTrigger = React.forwardRef(
  function PopoverTrigger2(props, forwardedRef) {
    const context = usePopoverContext();
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = <View
      aria-haspopup="dialog"
      aria-expanded={context.open}
      data-state={getState(context.open)}
      {...props}
      ref={composedTriggerRef}
      onPress={composeEventHandlers(props.onPress, context.onOpenToggle)}
    />;
    return context.hasCustomAnchor ? trigger : <PopperAnchor asChild>{trigger}</PopperAnchor>;
  }
);
const PopoverContent = PopperContentFrame.extractable(
  React.forwardRef(
    function PopoverContent2(props, forwardedRef) {
      const {
        allowPinchZoom,
        trapFocus,
        disableRemoveScroll = true,
        zIndex,
        ...contentImplProps
      } = props;
      const context = usePopoverContext();
      const contentRef = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, contentRef);
      const isRightClickOutsideRef = React.useRef(false);
      React.useEffect(() => {
        if (!context.open)
          return;
        const content = contentRef.current;
        if (content)
          return hideOthers(content);
      }, [context.open]);
      return <PopoverContentPortal zIndex={props.zIndex}><Stack pointerEvents={context.open ? "auto" : "none"}><PopoverContentImpl
        {...contentImplProps}
        disableRemoveScroll={disableRemoveScroll}
        ref={composedRefs}
        trapFocus={trapFocus ?? context.open}
        disableOutsidePointerEvents
        onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          if (!isRightClickOutsideRef.current)
            context.triggerRef.current?.focus();
        })}
        onPointerDownOutside={composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkDefaultPrevented: false }
        )}
        onFocusOutside={composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkDefaultPrevented: false }
        )}
      /></Stack></PopoverContentPortal>;
    }
  )
);
function PopoverRepropagateContext(props) {
  return <PopperContext.Provider {...props.popperContext}><PopoverContext.Provider {...props.context}>{props.children}</PopoverContext.Provider></PopperContext.Provider>;
}
function PopoverContentPortal(props) {
  const zIndex = props.zIndex ?? 15e4;
  const context = usePopoverContext();
  const popperContext = usePopperContext();
  const themeName = useThemeName();
  let contents = props.children;
  if (Platform.OS === "android" || Platform.OS === "ios") {
    contents = <PopoverRepropagateContext popperContext={popperContext} context={context}>{props.children}</PopoverRepropagateContext>;
  }
  return <Portal zIndex={zIndex}><Theme forceClassName name={themeName}>
    {!!context.open && !context.breakpointActive && <YStack
      fullscreen
      onPress={composeEventHandlers(props.onPress, context.onOpenToggle)}
    />}
    {contents}
  </Theme></Portal>;
}
const PopoverContentImpl = React.forwardRef(function PopoverContentImpl2(props, forwardedRef) {
  const {
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    disableFocusScope,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    children,
    disableRemoveScroll,
    freezeContentsWhenHidden,
    ...contentProps
  } = props;
  const context = usePopoverContext();
  const { open, keepChildrenMounted } = context;
  const popperContext = usePopperContext();
  const [isFullyHidden, setIsFullyHidden] = React.useState(!context.open);
  const contents = React.useMemo(() => {
    return isWeb ? <div style={{ display: "contents" }}>{children}</div> : children;
  }, [children]);
  if (open && isFullyHidden) {
    setIsFullyHidden(false);
  }
  if (!keepChildrenMounted) {
    if (isFullyHidden) {
      return null;
    }
  }
  if (context.breakpointActive) {
    const childrenWithoutScrollView = React.Children.toArray(children).map((child) => {
      if (React.isValidElement(child)) {
        if (child.type === ScrollView) {
          return child.props.children;
        }
      }
      return child;
    });
    let content = childrenWithoutScrollView;
    if (Platform.OS === "android" || Platform.OS === "ios") {
      content = <PopperContext.Provider {...popperContext}>{childrenWithoutScrollView}</PopperContext.Provider>;
    }
    return <PortalItem hostName={`${context.id}PopoverContents`}>{content}</PortalItem>;
  }
  const freeze = Boolean(isFullyHidden && freezeContentsWhenHidden);
  return <Animate
    type="presence"
    present={Boolean(open)}
    keepChildrenMounted={keepChildrenMounted}
    onExitComplete={() => {
      setIsFullyHidden(true);
    }}
  ><FreezeToLastContents
    freeze={freeze}
  ><PopperContent
    key={context.contentId}
    data-state={getState(open)}
    id={context.contentId}
    ref={forwardedRef}
    {...contentProps}
  ><RemoveScroll
    enabled={disableRemoveScroll ? false : open}
    allowPinchZoom
    removeScrollBar={false}
    style={{
      display: "contents"
    }}
  ><FocusScope
    loop
    enabled={disableFocusScope ? false : open}
    trapped={trapFocus}
    onMountAutoFocus={onOpenAutoFocus}
    onUnmountAutoFocus={onCloseAutoFocus}
  >{contents}</FocusScope></RemoveScroll></PopperContent></FreezeToLastContents></Animate>;
});
const FreezeToLastContents = (props) => {
  const last = React.useRef();
  if (!props.freeze) {
    last.current = props.children;
  }
  return <Freeze placeholder={last.current} {...props} />;
};
const PopoverClose = React.forwardRef(
  function PopoverClose2(props, forwardedRef) {
    const context = usePopoverContext();
    return <YStack
      {...props}
      ref={forwardedRef}
      componentName="PopoverClose"
      onPress={composeEventHandlers(
        props.onPress,
        () => context.onOpenChange(false)
      )}
    />;
  }
);
const PopoverArrow = React.forwardRef(
  function PopoverArrow2(props, forwardedRef) {
    return <PopperArrow componentName="PopoverArrow" {...props} ref={forwardedRef} />;
  }
);
const Popover = withStaticProperties(
  function Popover2(props) {
    const {
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      keepChildrenMounted,
      ...restProps
    } = props;
    const id = React.useId();
    const { when, AdaptProvider } = useAdaptParent({
      Contents: React.useCallback(() => {
        return <PortalHost name={`${id}PopoverContents`} />;
      }, [])
    });
    const sheetBreakpoint = when;
    const triggerRef = React.useRef(null);
    const [hasCustomAnchor, setHasCustomAnchor] = React.useState(false);
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen || false,
      onChange: onOpenChange
    });
    const breakpointActive = useSheetBreakpointActive(sheetBreakpoint);
    const floatingContext = useFloatingContext({ open, setOpen, breakpointActive });
    const popoverContext = {
      id,
      sheetBreakpoint,
      contentId: React.useId(),
      triggerRef,
      open,
      breakpointActive,
      onOpenChange: setOpen,
      onOpenToggle: useEvent(() => {
        if (open && breakpointActive) {
          return;
        }
        setOpen(!open);
      }),
      hasCustomAnchor,
      onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(false), []),
      keepChildrenMounted
    };
    const contents = <Popper stayInFrame {...restProps}><PopoverContext.Provider {...popoverContext}><PopoverSheetController onOpenChange={setOpen}>{children}</PopoverSheetController></PopoverContext.Provider></Popper>;
    return <AdaptProvider>{isWeb ? <FloatingOverrideContext.Provider value={floatingContext}>{contents}</FloatingOverrideContext.Provider> : contents}</AdaptProvider>;
  },
  {
    Anchor: PopoverAnchor,
    Arrow: PopoverArrow,
    Trigger: PopoverTrigger,
    Content: PopoverContent,
    Close: PopoverClose,
    Adapt,
    ScrollView,
    Sheet: Sheet.Controlled
  }
);
function getState(open) {
  return open ? "open" : "closed";
}
const PopoverSheetController = (props) => {
  const context = usePopoverContext();
  const showSheet = useShowPopoverSheet(context);
  const breakpointActive = context.breakpointActive;
  const getShowSheet = useGet(showSheet);
  return <SheetController
    onOpenChange={(val) => {
      if (getShowSheet()) {
        props.onOpenChange(val);
      }
    }}
    open={context.open}
    hidden={breakpointActive === false}
  >{props.children}</SheetController>;
};
const useSheetBreakpointActive = (breakpoint) => {
  const media = useMedia();
  if (typeof breakpoint === "boolean" || !breakpoint) {
    return !!breakpoint;
  }
  return media[breakpoint];
};
const useShowPopoverSheet = (context) => {
  const breakpointActive = useSheetBreakpointActive(context.sheetBreakpoint);
  return context.open === false ? false : breakpointActive;
};
export {
  Popover,
  PopoverAnchor,
  PopoverArrow,
  PopoverClose,
  PopoverContent,
  PopoverContext,
  PopoverTrigger,
  usePopoverContext
};
//# sourceMappingURL=Popover.js.map
