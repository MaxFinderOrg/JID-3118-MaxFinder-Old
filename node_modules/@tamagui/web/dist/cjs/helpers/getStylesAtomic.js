"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getStylesAtomic_exports = {};
__export(getStylesAtomic_exports, {
  generateAtomicStyles: () => generateAtomicStyles,
  getStylesAtomic: () => getStylesAtomic,
  styleToCSS: () => styleToCSS
});
module.exports = __toCommonJS(getStylesAtomic_exports);
var import_helpers = require("@tamagui/helpers");
var import_config = require("../config");
var import_defaultOffset = require("./defaultOffset");
var import_normalizeValueWithProperty = require("./normalizeValueWithProperty");
var import_pseudoDescriptors = require("./pseudoDescriptors");
function getStylesAtomic(stylesIn, debug) {
  let res = [];
  for (const pseudoName in import_pseudoDescriptors.pseudoDescriptorsBase) {
    const pseudoStyle = stylesIn[pseudoName];
    if (pseudoStyle) {
      res = [
        ...res,
        ...generateAtomicStyles(pseudoStyle, import_pseudoDescriptors.pseudoDescriptorsBase[pseudoName])
      ];
    }
  }
  res = [...res, ...generateAtomicStyles(stylesIn)];
  if (process.env.NODE_ENV === "development" && debug === "verbose") {
    console.log(` \u{1FAAE} getStylesAtomic`, { stylesIn, res });
  }
  return res;
}
let conf;
const generateAtomicStyles = (style, pseudo) => {
  if (!style)
    return [];
  conf = conf || (0, import_config.getConfig)();
  styleToCSS(style);
  const out = [];
  for (const key in style) {
    if (key in import_pseudoDescriptors.pseudoDescriptors)
      continue;
    let val = style[key];
    if (val == null)
      continue;
    if (key === "transform" && Array.isArray(style.transform)) {
      val = val.map(
        // { scale: 2 } => 'scale(2)'
        // { translateX: 20 } => 'translateX(20px)'
        // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
        (transform) => {
          const type = Object.keys(transform)[0];
          const value2 = transform[type];
          if (type === "matrix" || type === "matrix3d") {
            return `${type}(${value2.join(",")})`;
          }
          return `${type}(${(0, import_normalizeValueWithProperty.normalizeValueWithProperty)(value2, type)})`;
        }
      ).join(" ");
    }
    const value = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(val, key);
    const hash = (0, import_helpers.simpleHash)(`${value}`);
    const pseudoPrefix = pseudo ? `0${pseudo.name}-` : "";
    const shortProp = conf.inverseShorthands[key] || key;
    const identifier = `_${shortProp}-${pseudoPrefix}${hash}`;
    const rules = createAtomicRules(identifier, key, value, pseudo);
    const styleObject = {
      property: key,
      pseudo: pseudo == null ? void 0 : pseudo.name,
      identifier,
      rules,
      value
    };
    out.push(styleObject);
  }
  return out;
};
function styleToCSS(style) {
  const { shadowOffset, shadowRadius, shadowColor } = style;
  if (style.shadowRadius) {
    const offset = shadowOffset || import_defaultOffset.defaultOffset;
    const width = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(offset.width);
    const height = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(offset.height);
    const radius = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(shadowRadius);
    const shadow = `${width} ${height} ${radius} ${shadowColor}`;
    style.boxShadow = style.boxShadow ? `${style.boxShadow}, ${shadow}` : shadow;
    delete style.shadowOffset;
    delete style.shadowRadius;
    delete style.shadowColor;
    delete style.shadowOpacity;
  }
  const { textShadowColor, textShadowOffset, textShadowRadius } = style;
  if (textShadowColor || textShadowOffset || textShadowRadius) {
    const { height, width } = textShadowOffset || import_defaultOffset.defaultOffset;
    const radius = textShadowRadius || 0;
    const color = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(textShadowColor, "textShadowColor");
    if (color && (height !== 0 || width !== 0 || radius !== 0)) {
      const blurRadius = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(radius);
      const offsetX = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(width);
      const offsetY = (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(height);
      style.textShadow = `${offsetX} ${offsetY} ${blurRadius} ${color}`;
    }
    delete style.textShadowColor;
    delete style.textShadowOffset;
    delete style.textShadowRadius;
  }
}
function createDeclarationBlock(style, important = false) {
  let next = "";
  for (const [key, value] of style) {
    next += `${hyphenateStyleName(key)}:${value}${important ? " !important" : ""};`;
  }
  return `{${next}}`;
}
const hcache = {};
const toHyphenLower = (match) => `-${match.toLowerCase()}`;
const hyphenateStyleName = (key) => {
  if (key in hcache)
    return hcache[key];
  const val = key.replace(/[A-Z]/g, toHyphenLower);
  hcache[key] = val;
  return val;
};
const pseudoSelectorPrefixes = (() => {
  const res = {};
  for (const key in import_pseudoDescriptors.pseudoDescriptors) {
    const pseudo = import_pseudoDescriptors.pseudoDescriptors[key];
    res[pseudo.name] = `${[...Array(pseudo.priority)].map(() => ":root").join("")} `;
  }
  return res;
})();
function createAtomicRules(identifier, property, value, pseudo) {
  const selector = pseudo ? (
    // adding one more :root so we always override react native web styles :/
    `${pseudoSelectorPrefixes[pseudo.name]} .${identifier}:${pseudo.name}`
  ) : `:root .${identifier}`;
  const important = !!pseudo;
  let rules = [];
  switch (property) {
    case "placeholderTextColor": {
      const block = createDeclarationBlock(
        [
          ["color", value],
          ["opacity", 1]
        ],
        important
      );
      rules.push(`${selector}::placeholder${block}`);
      break;
    }
    case "backgroundClip":
    case "userSelect": {
      const propertyCapitalized = `${property[0].toUpperCase()}${property.slice(1)}`;
      const webkitProperty = `Webkit${propertyCapitalized}`;
      const block = createDeclarationBlock(
        [
          [property, value],
          [webkitProperty, value]
        ],
        important
      );
      rules.push(`${selector}${block}`);
      break;
    }
    case "pointerEvents": {
      let finalValue = value;
      if (value === "auto" || value === "box-only") {
        finalValue = "auto";
        if (value === "box-only") {
          rules.push(`${selector}>*${boxOnly}`);
        }
      } else if (value === "none" || value === "box-none") {
        finalValue = "none";
        if (value === "box-none") {
          rules.push(`${selector}>*${boxNone}`);
        }
      }
      const block = createDeclarationBlock([["pointerEvents", finalValue]], true);
      rules.push(`${selector}${block}`);
      break;
    }
    default: {
      const block = createDeclarationBlock([[property, value]], important);
      rules.push(`${selector}${block}`);
      break;
    }
  }
  if ((pseudo == null ? void 0 : pseudo.name) === "hover") {
    rules = rules.map((r) => `@media not all and (hover: none) { ${r} }`);
  }
  return rules;
}
const boxNone = createDeclarationBlock([["pointerEvents", "auto"]], true);
const boxOnly = createDeclarationBlock([["pointerEvents", "none"]], true);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateAtomicStyles,
  getStylesAtomic,
  styleToCSS
});
//# sourceMappingURL=getStylesAtomic.js.map
