"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ThemeManager_exports = {};
__export(ThemeManager_exports, {
  ThemeManager: () => ThemeManager,
  getHasThemeUpdatingProps: () => getHasThemeUpdatingProps,
  getNonComponentParentManager: () => getNonComponentParentManager
});
module.exports = __toCommonJS(ThemeManager_exports);
var import_constants = require("@tamagui/constants");
var import_config = require("../config");
var import_constants2 = require("../constants/constants");
const emptyState = { name: "" };
function getHasThemeUpdatingProps(props) {
  return props.name || props.componentName || props.inverse || props.reset;
}
let uid = 0;
class ThemeManager {
  constructor(props = {}, parentManagerIn) {
    this.props = props;
    this.id = uid++;
    this.isComponent = false;
    this.themeListeners = /* @__PURE__ */ new Set();
    this.parentManager = null;
    this.state = emptyState;
    this.scheme = null;
    this._allKeys = null;
    if (parentManagerIn === "root") {
      this.updateStateFromProps(props, false);
      return;
    }
    if (!parentManagerIn) {
      if (process.env.NODE_ENV !== "production") {
        throw new Error(
          `No parent manager given, this is likely due to duplicated Tamagui dependencies. Check your lockfile for mis-matched versions. It could also be from an error somewhere else in your stack causing Tamagui to recieve undefined context, you can try putting some ErrorBoundary components around other areas of your app, or a Suspense boundary.`
        );
      }
      throw `\u274C 0`;
    }
    this.parentManager = parentManagerIn;
    if (this.updateStateFromProps(props, false)) {
      return;
    }
    return parentManagerIn || this;
  }
  updateStateFromProps(props = this.props || {}, shouldNotify = true) {
    this.props = props;
    if (props.forceTheme) {
      this.state.theme = props.forceTheme;
      this.state.name = props.name || "";
      return true;
    }
    const nextState = this.getStateIfChanged(props);
    if (nextState) {
      this.updateState(nextState, shouldNotify);
      return nextState;
    }
  }
  updateState(nextState, shouldNotify = true) {
    this.state = nextState;
    const names = this.state.name.split("_");
    const lastName = names[names.length - 1][0];
    this.isComponent = lastName[0] === lastName[0].toUpperCase();
    this._allKeys = null;
    this.scheme = names[0] === "light" ? "light" : names[0] === "dark" ? "dark" : null;
    if (process.env.NODE_ENV === "development") {
      this["_numChangeEventsSent"] ?? (this["_numChangeEventsSent"] = 0);
      this["_numChangeEventsSent"]++;
    }
    if (shouldNotify) {
      queueMicrotask(() => {
        this.notify();
      });
    }
  }
  getStateIfChanged(props = this.props, state = this.state, parentManager = this.parentManager) {
    const _ = this.getState(props, parentManager);
    if (state && state !== emptyState && !_) {
      return parentManager == null ? void 0 : parentManager.state;
    }
    if (this.getStateShouldChange(_, state)) {
      return _;
    }
  }
  getStateShouldChange(nextState, state = this.state) {
    if (!(nextState == null ? void 0 : nextState.theme) || nextState.theme === (state == null ? void 0 : state.theme)) {
      return false;
    }
    return true;
  }
  getState(props = this.props, parentManager = this.parentManager) {
    const next = getState(props, parentManager) || (process.env.TAMAGUI_TARGET === "native" ? (parentManager == null ? void 0 : parentManager.state) || null : null);
    return next;
  }
  get allKeys() {
    var _a;
    this._allKeys || (this._allKeys = /* @__PURE__ */ new Set([
      ...((_a = this.parentManager) == null ? void 0 : _a.allKeys) || [],
      ...Object.keys(this.state.theme || {})
    ]));
    return this._allKeys;
  }
  notify(forced = false) {
    this.themeListeners.forEach((cb) => cb(this.state.name, this, forced));
  }
  onChangeTheme(cb, debugId) {
    if (process.env.NODE_ENV === "development" && debugId) {
      this._listeningIds ?? (this._listeningIds = /* @__PURE__ */ new Set());
      this._listeningIds.add(debugId);
    }
    this.themeListeners.add(cb);
    return () => {
      this.themeListeners.delete(cb);
    };
  }
}
function getNextThemeClassName(name) {
  const next = `t_sub_theme ${import_constants2.THEME_CLASSNAME_PREFIX}${name}`;
  return next.replace("light_", "").replace("dark_", "");
}
function getState(props, parentManager) {
  var _a, _b, _c, _d, _e, _f;
  const validManagerAndAllComponentThemes = getNonComponentParentManager(parentManager);
  parentManager = validManagerAndAllComponentThemes[0];
  const allComponentThemes = validManagerAndAllComponentThemes[1];
  const themes = (0, import_config.getThemes)();
  const isDirectParentAComponentTheme = allComponentThemes.length > 0;
  if (props.name && props.reset) {
    throw new Error("Cannot reset + set new name");
  }
  if (!props.name && !props.inverse && !props.reset && !props.componentName) {
    return null;
  }
  if (props.reset && !isDirectParentAComponentTheme && !(parentManager == null ? void 0 : parentManager.parentManager)) {
    if (process.env.NODE_ENV === "development") {
      console.warn("Cannot reset no grandparent exists");
    }
    return null;
  }
  let result = null;
  const nextName = props.reset ? isDirectParentAComponentTheme ? ((_a = parentManager == null ? void 0 : parentManager.state) == null ? void 0 : _a.name) || "" : ((_c = (_b = parentManager == null ? void 0 : parentManager.parentManager) == null ? void 0 : _b.state) == null ? void 0 : _c.name) || "" : props.name || "";
  const { componentName } = props;
  const parentName = props.reset ? isDirectParentAComponentTheme ? (
    // here because parentManager already skipped componentTheme so we have to only go up once
    ((_d = parentManager == null ? void 0 : parentManager.parentManager) == null ? void 0 : _d.state.name) || ""
  ) : ((_f = (_e = parentManager == null ? void 0 : parentManager.parentManager) == null ? void 0 : _e.parentManager) == null ? void 0 : _f.state.name) || "" : isDirectParentAComponentTheme ? allComponentThemes[0] || "" : (parentManager == null ? void 0 : parentManager.state.name) || "";
  if (props.reset && isDirectParentAComponentTheme) {
    allComponentThemes.shift();
  }
  const base = parentName.split(import_constants2.THEME_NAME_SEPARATOR);
  const lastSegment = base[base.length - 1];
  const isParentComponentTheme = parentName && lastSegment[0].toUpperCase() === lastSegment[0];
  if (isParentComponentTheme) {
    base.pop();
  }
  const parentBaseTheme = isParentComponentTheme ? base.slice(0, base.length).join(import_constants2.THEME_NAME_SEPARATOR) : parentName;
  const max = base.length;
  const min = componentName && !nextName ? max : 0;
  if (process.env.NODE_ENV === "development" && typeof props.debug === "string") {
    console.groupCollapsed("ThemeManager.getState()");
    console.log({
      props,
      parentName,
      parentBaseTheme,
      base,
      min,
      max,
      isParentComponentTheme
    });
  }
  for (let i = max; i >= min; i--) {
    let prefix = base.slice(0, i).join(import_constants2.THEME_NAME_SEPARATOR);
    if (props.inverse) {
      prefix = inverseThemeName(prefix);
    }
    let potentials = [];
    if (prefix && prefix !== parentBaseTheme) {
      potentials.push(prefix);
    }
    if (nextName) {
      potentials.unshift(prefix ? `${prefix}_${nextName}` : nextName);
    }
    if (i === 1) {
      const lastSegment2 = potentials.findIndex((x) => !x.includes("_"));
      if (lastSegment2 > 0) {
        potentials.splice(lastSegment2, 0, nextName);
      }
    }
    if (componentName) {
      let componentPotentials = [];
      if (nextName) {
        const beforeSeparator = prefix.slice(0, prefix.indexOf(import_constants2.THEME_NAME_SEPARATOR));
        componentPotentials.push(`${beforeSeparator}_${nextName}_${componentName}`);
      }
      componentPotentials.push(`${prefix}_${componentName}`);
      if (nextName) {
        const prefixLessOne = base.slice(0, i - 1).join(import_constants2.THEME_NAME_SEPARATOR);
        if (prefixLessOne) {
          const lessSpecific = `${prefixLessOne}_${nextName}_${componentName}`;
          componentPotentials.unshift(lessSpecific);
        }
        const moreSpecific = `${prefix}_${nextName}_${componentName}`;
        componentPotentials.unshift(moreSpecific);
      }
      potentials = [...componentPotentials, ...potentials, ...allComponentThemes];
    }
    const found = potentials.find((t) => t in themes);
    if (process.env.NODE_ENV === "development" && typeof props.debug === "string") {
      console.log(" - ", { found, potentials, parentManager });
    }
    if (found) {
      result = {
        name: found,
        theme: themes[found],
        className: import_constants.isWeb ? getNextThemeClassName(found) : "",
        parentName,
        componentName,
        inverse: props.inverse
      };
      break;
    }
  }
  if (process.env.NODE_ENV === "development" && typeof props.debug === "string" && typeof window !== "undefined") {
    console.warn("ThemeManager.getState():", {
      result
    });
    console.trace();
    console.groupEnd();
  }
  return result;
}
const inverseThemeName = (themeName) => {
  return themeName.startsWith("light") ? themeName.replace(/^light/, "dark") : themeName.replace(/^dark/, "light");
};
function getNonComponentParentManager(themeManager) {
  var _a;
  let res = themeManager;
  let componentThemeNames = [];
  while (res) {
    if (res == null ? void 0 : res.isComponent) {
      componentThemeNames.push((_a = res == null ? void 0 : res.state) == null ? void 0 : _a.name);
      res = res.parentManager;
    } else {
      break;
    }
  }
  return [res || null, componentThemeNames];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ThemeManager,
  getHasThemeUpdatingProps,
  getNonComponentParentManager
});
//# sourceMappingURL=ThemeManager.js.map
