"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var getThemeCSSRules_exports = {};
__export(getThemeCSSRules_exports, {
  getThemeCSSRules: () => getThemeCSSRules
});
module.exports = __toCommonJS(getThemeCSSRules_exports);
var import_helpers = require("@tamagui/helpers");
var import_constants = require("../constants/constants");
var import_createVariable = require("../createVariable");
var import_registerCSSVariable = require("./registerCSSVariable");
function getThemeCSSRules(props) {
  const cssRuleSets = [];
  if (!process.env.TAMAGUI_DOES_SSR_CSS || process.env.TAMAGUI_DOES_SSR_CSS === "mutates-themes" || process.env.TAMAGUI_DOES_SSR_CSS === "false") {
    const { config, themeName, theme, names } = props;
    const hasDarkLight = "light" in config.themes || "dark" in config.themes;
    const CNP = `.${import_constants.THEME_CLASSNAME_PREFIX}`;
    let vars = "";
    for (const themeKey in theme) {
      const variable = theme[themeKey];
      let value = null;
      if (!import_registerCSSVariable.tokensValueToVariable.has(variable.val)) {
        value = variable.val;
      } else {
        value = import_registerCSSVariable.tokensValueToVariable.get(variable.val).variable;
      }
      vars += `--${(0, import_helpers.simpleHash)(themeKey, 40)}:${value};`;
    }
    const isDarkBase = themeName === "dark";
    const isLightBase = themeName === "light";
    const baseSelectors = names.map((name) => `${CNP}${name}`);
    const selectorsSet = new Set(baseSelectors);
    if (hasDarkLight) {
      const maxDepth = config.maxDarkLightNesting ?? 3;
      for (const subName of names) {
        const isDark = isDarkBase || subName.startsWith("dark_");
        const isLight = !isDark && (isLightBase || subName.startsWith("light_"));
        if (!(isDark || isLight)) {
          selectorsSet.add(`:root:root ${CNP}${subName}`);
          continue;
        }
        const childSelector = `${CNP}${subName.replace(/^(dark|light)_/, "")}`;
        const order = isDark ? ["dark", "light"] : ["light", "dark"];
        const [stronger, weaker] = order;
        const numSelectors = Math.round(maxDepth * 1.5);
        for (let depth = 0; depth < numSelectors; depth++) {
          const isOdd = depth % 2 === 1;
          if (isOdd && depth < 3) {
            continue;
          }
          const parents = new Array(depth + 1).fill(0).map((_, psi) => {
            return `${CNP}${psi % 2 === 0 ? stronger : weaker}`;
          });
          let parentSelectors = parents.length > 1 ? parents.slice(1) : parents;
          if (isOdd) {
            const [_first, second, ...rest] = parentSelectors;
            parentSelectors = [second, ...rest, second];
          }
          const lastParentSelector = parentSelectors[parentSelectors.length - 1];
          const nextChildSelector = childSelector === lastParentSelector ? "" : childSelector;
          selectorsSet.add(`${parentSelectors.join(" ")} ${nextChildSelector}`.trim());
          selectorsSet.add(
            `${parentSelectors.join(" ")} ${nextChildSelector}.is_inversed`.trim()
          );
        }
      }
    }
    const selectors = [...selectorsSet].sort((a, b) => a.localeCompare(b));
    const selectorsString = selectors.map((x) => {
      const rootSep = isBaseTheme(x) && config.themeClassNameOnRoot ? "" : " ";
      return `:root${rootSep}${x}`;
    }).join(", ");
    const css = `${selectorsString} {${vars}}`;
    cssRuleSets.push(css);
    if (config.shouldAddPrefersColorThemes) {
      const bgString = theme.background ? `background:${(0, import_createVariable.variableToString)(theme.background)};` : "";
      const fgString = theme.color ? `color:${(0, import_createVariable.variableToString)(theme.color)}` : "";
      const bodyRules = `body{${bgString}${fgString}}`;
      const isDark = themeName.startsWith("dark");
      const baseName = isDark ? "dark" : "light";
      const lessSpecificSelectors = selectors.map((x) => {
        if (x == darkSelector || x === lightSelector)
          return `:root`;
        if (isDark && x.startsWith(lightSelector) || !isDark && x.startsWith(darkSelector)) {
          return;
        }
        return x.replace(/^\.t_(dark|light) /, "").trim();
      }).filter(Boolean).join(", ");
      const themeRules = `${lessSpecificSelectors} {${vars}}`;
      const prefersMediaSelectors = `@media(prefers-color-scheme:${baseName}){
    ${bodyRules}
    ${themeRules}
  }`;
      cssRuleSets.push(prefersMediaSelectors);
    }
    if (config.selectionStyles) {
      const selectionSelectors = baseSelectors.map((s) => `${s} ::selection`).join(", ");
      const rules = config.selectionStyles(theme);
      if (rules) {
        const styles = Object.entries(rules).flatMap(
          ([k, v]) => v ? `${k === "backgroundColor" ? "background" : k}:${(0, import_createVariable.variableToString)(v)}` : []
        ).join(";");
        const css2 = `${selectionSelectors} {${styles}}`;
        cssRuleSets.push(css2);
      }
    }
  }
  return cssRuleSets;
}
const darkSelector = ".t_dark";
const lightSelector = ".t_light";
const isBaseTheme = (x) => x === darkSelector || x === lightSelector || x.startsWith(".t_dark ") || x.startsWith(".t_light ");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getThemeCSSRules
});
//# sourceMappingURL=getThemeCSSRules.js.map
