"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var propMapper_exports = {};
__export(propMapper_exports, {
  getFontFamilyFromNameOrVariable: () => getFontFamilyFromNameOrVariable,
  getPropMappedFontFamily: () => getPropMappedFontFamily,
  propMapper: () => propMapper
});
module.exports = __toCommonJS(propMapper_exports);
var import_constants = require("@tamagui/constants");
var import_helpers = require("@tamagui/helpers");
var import_isDevTools = require("../constants/isDevTools");
var import_createVariable = require("../createVariable");
var import_expandStyle = require("./expandStyle");
var import_expandStyles = require("./expandStyles");
var import_getVariantExtras = require("./getVariantExtras");
var import_isObj = require("./isObj");
var import_pseudoDescriptors = require("./pseudoDescriptors");
const propMapper = (key, value, styleStateIn, subPropsIn) => {
  if (!(process.env.TAMAGUI_TARGET === "native" && import_constants.isAndroid)) {
    if (key === "elevationAndroid")
      return;
  }
  const subProps = styleStateIn.styleProps.fallbackProps || subPropsIn;
  const styleState = subProps ? new Proxy(styleStateIn, {
    get(_, k) {
      return k === "curProps" ? subProps : Reflect.get(_, k);
    }
  }) : styleStateIn;
  const { conf, styleProps, fontFamily, staticConfig } = styleState;
  const { variants } = staticConfig;
  if (process.env.NODE_ENV === "development" && fontFamily && fontFamily[0] === "$" && !(fontFamily in conf.fontsParsed)) {
    console.warn(
      `Warning: no fontFamily "${fontFamily}" found in config: ${Object.keys(conf.fontsParsed).join(
        ", "
      )}`
    );
  }
  if (variants && key in variants) {
    styleState.curProps[key] = value;
    const variantValue = resolveVariants(key, value, styleProps, styleState, "");
    if (variantValue) {
      return variantValue;
    }
  }
  let shouldReturn = false;
  if (key in conf.shorthands) {
    shouldReturn = true;
    key = conf.shorthands[key];
  }
  if (value) {
    if (value[0] === "$") {
      value = getToken(key, value, styleProps, styleState);
    } else if ((0, import_createVariable.isVariable)(value)) {
      value = resolveVariableValue(value, styleProps);
    }
  }
  if (shouldReturn || value != null) {
    return (0, import_expandStyle.expandStyle)(key, value) || [[key, value]];
  }
};
const resolveVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  const { staticConfig, conf, debug } = styleState;
  const { variants } = staticConfig;
  if (!variants)
    return;
  let variantValue = getVariantDefinition(variants[key], key, value, conf);
  if (process.env.NODE_ENV === "development" && debug === "verbose") {
    console.groupCollapsed(`\u2666\uFE0F\u2666\uFE0F\u2666\uFE0F resolve variant ${key}`);
    console.log({
      key,
      value,
      variantValue,
      variants,
      curProps: { ...styleState.curProps }
    });
    console.groupEnd();
  }
  if (!variantValue) {
    if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1") {
      if (typeof value !== "boolean") {
        const name = staticConfig.componentName || "[UnnamedComponent]";
        console.warn(
          `No variant found: ${name} has variant "${key}", but no matching value "${value}"`
        );
      }
    }
    return;
  }
  if (typeof variantValue === "function") {
    const fn = variantValue;
    const extras = (0, import_getVariantExtras.getVariantExtras)(styleState);
    variantValue = fn(value, extras);
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      console.groupCollapsed("   expanded functional variant", key);
      console.log({ fn, variantValue, extras });
      console.groupEnd();
    }
  }
  let fontFamilyResult;
  if ((0, import_isObj.isObj)(variantValue)) {
    const fontFamilyUpdate = variantValue.fontFamily || variantValue[conf.inverseShorthands.fontFamily];
    if (fontFamilyUpdate) {
      fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf);
      styleState.fontFamily = fontFamilyResult;
      if (process.env.NODE_ENV === "development" && debug === "verbose") {
        console.log(`   updating font family`, fontFamilyResult);
      }
    }
    variantValue = resolveTokensAndVariants(
      key,
      variantValue,
      styleProps,
      styleState,
      parentVariantKey
    );
  }
  if (variantValue) {
    const expanded = (0, import_expandStyles.expandStylesAndRemoveNullishValues)(variantValue);
    const next = Object.entries(expanded);
    if (fontFamilyResult && fontFamilyResult[0] === "$") {
      fontFamilyCache.set(next, (0, import_createVariable.getVariableValue)(fontFamilyResult));
    }
    return next;
  }
};
function getFontFamilyFromNameOrVariable(input, conf) {
  if ((0, import_createVariable.isVariable)(input)) {
    const val = variableToFontNameCache.get(input);
    if (val)
      return val;
    for (const key in conf.fontsParsed) {
      const familyVariable = conf.fontsParsed[key].family;
      if ((0, import_createVariable.isVariable)(familyVariable)) {
        variableToFontNameCache.set(familyVariable, key);
        if (familyVariable === input) {
          return key;
        }
      }
    }
  } else if (typeof input === "string") {
    if (input[0] === "$") {
      return input;
    }
  }
}
const variableToFontNameCache = /* @__PURE__ */ new WeakMap();
const fontFamilyCache = /* @__PURE__ */ new WeakMap();
const getPropMappedFontFamily = (expanded) => {
  return expanded && fontFamilyCache.get(expanded);
};
const resolveTokensAndVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  var _a;
  const { conf, staticConfig, debug, theme } = styleState;
  const { variants } = staticConfig;
  const res = {};
  if (process.env.NODE_ENV === "development" && debug === "verbose") {
    console.log(`   - resolveTokensAndVariants`, key, value);
  }
  for (const rKey in value) {
    const fKey = conf.shorthands[rKey] || rKey;
    const val = value[rKey];
    if (variants && fKey in variants) {
      styleState.curProps[fKey] = val;
      if (parentVariantKey && parentVariantKey === key) {
        res[fKey] = // SYNC WITH *1
        val[0] === "$" ? getToken(fKey, val, styleProps, styleState) : val;
      } else {
        const variantOut = resolveVariants(fKey, val, styleProps, styleState, key);
        if (variantOut) {
          for (const [key2, val2] of variantOut) {
            if (val2 == null)
              continue;
            if (key2 in import_pseudoDescriptors.pseudoDescriptors) {
              res[key2] ?? (res[key2] = {});
              Object.assign(res[key2], val2);
            } else {
              res[key2] = val2;
            }
          }
        }
      }
      continue;
    }
    if ((0, import_createVariable.isVariable)(val)) {
      res[fKey] = resolveVariableValue(val, styleProps);
      continue;
    }
    if (typeof val === "string") {
      const fVal = (
        // SYNC WITH *1
        val[0] === "$" ? getToken(fKey, val, styleProps, styleState) : val
      );
      res[fKey] = fVal;
      continue;
    }
    if ((0, import_isObj.isObj)(val)) {
      const subObject = resolveTokensAndVariants(fKey, val, styleProps, styleState, key);
      if (process.env.NODE_ENV === "development" && debug === "verbose") {
        console.log(`object`, fKey, subObject);
      }
      res[fKey] ?? (res[fKey] = {});
      Object.assign(res[fKey], subObject);
    } else {
      res[fKey] = val;
    }
    if (process.env.NODE_ENV === "development") {
      if (debug) {
        if (((_a = res[fKey]) == null ? void 0 : _a[0]) === "$") {
          console.warn(`\u26A0\uFE0F Missing token in theme ${theme.name}:`, fKey, res[fKey], theme);
        }
      }
    }
  }
  return res;
};
const tokenCats = ["size", "color", "radius", "space", "zIndex"].map((name) => ({
  name,
  spreadName: `...${name}`
}));
function getVariantDefinition(variant, key, value, conf) {
  if (typeof variant === "function") {
    return variant;
  }
  if (variant[value]) {
    return variant[value];
  }
  const { tokensParsed } = conf;
  for (const { name, spreadName } of tokenCats) {
    if (spreadName in variant && value in tokensParsed[name]) {
      return variant[spreadName];
    }
  }
  const fontSizeVariant = variant["...fontSize"];
  if (fontSizeVariant && conf.fontSizeTokens.has(value)) {
    return fontSizeVariant;
  }
  return variant[`:${typeof value}`] || variant["..."] || variant["...size"];
}
const fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
};
const getToken = (key, value, styleProps, styleState) => {
  var _a, _b;
  const { theme, conf, context, fontFamily } = styleState;
  const tokensParsed = conf.tokensParsed;
  let valOrVar;
  let hasSet = false;
  if (value in theme) {
    if (process.env.NODE_ENV === "development" && styleState.debug === "verbose") {
      console.log(` - getting theme value for ${key} from ${value}`);
    }
    valOrVar = theme[value];
    hasSet = true;
  } else {
    if (value in conf.specificTokens) {
      hasSet = true;
      valOrVar = conf.specificTokens[value];
    } else {
      switch (key) {
        case "fontFamily": {
          const fontsParsed = (context == null ? void 0 : context.language) ? (0, import_getVariantExtras.getFontsForLanguage)(conf.fontsParsed, context.language) : conf.fontsParsed;
          valOrVar = ((_a = fontsParsed[value]) == null ? void 0 : _a.family) || value;
          hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          const fam = fontFamily || styleState.conf.defaultFont;
          if (fam) {
            const fontsParsed = (context == null ? void 0 : context.language) ? (0, import_getVariantExtras.getFontsForLanguage)(conf.fontsParsed, context.language) : conf.fontsParsed;
            const font = fontsParsed[fam];
            valOrVar = ((_b = font == null ? void 0 : font[fontShorthand[key] || key]) == null ? void 0 : _b[value]) || value;
            hasSet = true;
          }
          break;
        }
      }
      for (const cat in import_helpers.tokenCategories) {
        if (key in import_helpers.tokenCategories[cat]) {
          const res = tokensParsed[cat][value];
          if (res != null) {
            valOrVar = res;
            hasSet = true;
          }
        }
      }
      if (!hasSet) {
        const spaceVar = tokensParsed.space[value];
        if (spaceVar != null) {
          valOrVar = spaceVar;
          hasSet = true;
        }
      }
    }
  }
  if (hasSet) {
    const out = resolveVariableValue(valOrVar, styleProps);
    return out;
  }
  if (process.env.NODE_ENV === "development" && import_isDevTools.isDevTools && styleState.debug === "verbose") {
    console.groupCollapsed("  \uFE52 propMap (val)", key, value);
    console.log({ valOrVar, theme, hasSet }, theme[key]);
    console.groupEnd();
  }
  return value;
};
function resolveVariableValue(valOrVar, { resolveVariablesAs }) {
  if ((0, import_createVariable.isVariable)(valOrVar)) {
    if (!import_constants.isWeb || resolveVariablesAs === "value") {
      return valOrVar.val;
    }
    return valOrVar.variable;
  }
  return valOrVar;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getFontFamilyFromNameOrVariable,
  getPropMappedFontFamily,
  propMapper
});
//# sourceMappingURL=propMapper.js.map
