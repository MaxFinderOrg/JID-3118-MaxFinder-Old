"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useTheme_exports = {};
__export(useTheme_exports, {
  activeThemeManagers: () => activeThemeManagers,
  getThemeProxied: () => getThemeProxied,
  useChangeThemeEffect: () => useChangeThemeEffect,
  useTheme: () => useTheme,
  useThemeWithState: () => useThemeWithState
});
module.exports = __toCommonJS(useTheme_exports);
var import_constants = require("@tamagui/constants");
var import_react = require("react");
var import_config = require("../config");
var import_createVariable = require("../createVariable");
var import_createProxy = require("../helpers/createProxy");
var import_ThemeManager = require("../helpers/ThemeManager");
var import_ThemeManagerContext = require("../helpers/ThemeManagerContext");
var import_getThemeUnwrapped = require("./getThemeUnwrapped");
const emptyProps = { name: null };
let cached;
function getDefaultThemeProxied() {
  if (cached)
    return cached;
  const config = (0, import_config.getConfig)();
  const defaultTheme = config.themes.light ?? config.themes[Object.keys(config.themes)[0]];
  cached = getThemeProxied(defaultTheme);
  return cached;
}
const useTheme = (props = emptyProps) => {
  const [_, theme] = useThemeWithState(props);
  const res = theme || getDefaultThemeProxied();
  return res;
};
const useThemeWithState = (props) => {
  const keys = (0, import_react.useRef)([]);
  const changedThemeState = useChangeThemeEffect(
    props,
    false,
    keys.current,
    !import_constants.isServer ? () => {
      var _a, _b;
      const next = ((_a = props.shouldUpdate) == null ? void 0 : _a.call(props)) ?? (keys.current.length > 0 ? true : void 0);
      if (process.env.NODE_ENV === "development" && props.debug && props.debug !== "profile") {
        console.log(`  \u{1F3A8} useTheme() shouldUpdate?`, next, {
          shouldUpdateProp: (_b = props.shouldUpdate) == null ? void 0 : _b.call(props),
          keys: [...keys.current]
        });
      }
      return next;
    } : void 0
  );
  const { themeManager, state } = changedThemeState;
  const { theme, name, className } = state;
  if (!theme) {
    if (process.env.NODE_ENV === "development") {
      throw new Error(
        `No theme found given props ${JSON.stringify(
          props
        )}. Themes given to tamagui are: ${Object.keys((0, import_config.getConfig)().themes)}`
      );
    }
    throw `\u274C 1`;
  }
  const themeProxied = (0, import_react.useMemo)(() => {
    return getThemeProxied(theme, themeManager, keys.current, props.debug);
  }, [theme, name, className, themeManager]);
  if (process.env.NODE_ENV === "development" && props.debug === "verbose") {
    console.groupCollapsed("  \u{1F539} useTheme =>", name);
    console.log("returning state", changedThemeState, "from props", props);
    console.groupEnd();
  }
  return [changedThemeState, themeProxied];
};
function getThemeProxied(theme, themeManager, keys, debug) {
  return (0, import_createProxy.createProxy)(theme, {
    has(_, key) {
      if (Reflect.has(theme, key)) {
        return true;
      }
      if (typeof key === "string") {
        if (key[0] === "$")
          key = key.slice(1);
        return themeManager == null ? void 0 : themeManager.allKeys.has(key);
      }
    },
    get(_, key) {
      if (key === import_getThemeUnwrapped.GetThemeUnwrapped) {
        return theme;
      }
      if (
        // dont ask me, idk why but on hermes you can see that useTheme()[undefined] passes in STRING undefined to proxy
        // if someone is crazy enough to use "undefined" as a theme key then this not working is on them
        key !== "undefined" && typeof key === "string"
      ) {
        const keyString = key[0] === "$" ? key.slice(1) : key;
        const val = theme[keyString];
        if (val && typeof val === "object") {
          return new Proxy(val, {
            // when they touch the actual value we only track it
            // if its a variable (web), its ignored!
            get(_2, subkey) {
              if (keys) {
                if ((subkey === "val" || subkey === "get" && !import_constants.isWeb) && !keys.includes(keyString)) {
                  keys.push(keyString);
                  if (process.env.NODE_ENV === "development" && debug) {
                    console.log(` \u{1F3A8} useTheme() tracking new key: ${keyString}`);
                  }
                }
              }
              if (subkey === "get") {
                return () => (0, import_createVariable.getVariable)(val);
              }
              return Reflect.get(val, subkey);
            }
          });
        }
      }
      return Reflect.get(_, key);
    }
  });
}
const activeThemeManagers = /* @__PURE__ */ new Set();
const useChangeThemeEffect = (props, root = false, keys, shouldUpdate) => {
  const {
    // @ts-expect-error internal use only
    disable
  } = props;
  const parentManager = (0, import_react.useContext)(import_ThemeManagerContext.ThemeManagerContext);
  if (disable) {
    if (!parentManager)
      throw `\u274C 2`;
    return {
      isNewTheme: false,
      state: parentManager.state,
      themeManager: parentManager
    };
  }
  const [themeState, setThemeState] = (0, import_react.useState)(createState);
  const { state, mounted, isNewTheme, themeManager } = themeState;
  const isInversingOnMount = Boolean(!themeState.mounted && props.inverse);
  function getShouldUpdateTheme(manager = themeManager, nextState, prevState = state, forceShouldChange = false) {
    const forceUpdate = shouldUpdate == null ? void 0 : shouldUpdate();
    if (!forceShouldChange && forceUpdate === false)
      return;
    const next = nextState || manager.getState(props, parentManager);
    if (forceShouldChange)
      return next;
    if (!next)
      return;
    if (forceUpdate !== true && !manager.getStateShouldChange(next, prevState)) {
      return;
    }
    return next;
  }
  if (!import_constants.isServer) {
    (0, import_react.useLayoutEffect)(() => {
      if (props.inverse && !mounted) {
        setThemeState({ ...themeState, mounted: true });
        return;
      }
      if (isNewTheme && themeManager) {
        activeThemeManagers.add(themeManager);
      }
      if (isNewTheme || getShouldUpdateTheme(themeManager)) {
        setThemeState(createState);
      }
      const selfListenerDispose = themeManager.onChangeTheme((_a, _b, forced) => {
        if (forced) {
          setThemeState((prev) => createState(prev, true));
        }
      });
      const disposeChangeListener = parentManager == null ? void 0 : parentManager.onChangeTheme((name, manager) => {
        const force = shouldUpdate == null ? void 0 : shouldUpdate();
        const doUpdate = force ?? Boolean((keys == null ? void 0 : keys.length) || isNewTheme);
        if (process.env.NODE_ENV === "development" && props.debug) {
          console.log(` \u{1F538} onChange`, themeManager.id, {
            force,
            doUpdate,
            props,
            name,
            manager,
            keys
          });
        }
        if (doUpdate) {
          setThemeState(createState);
        }
      }, themeManager.id);
      return () => {
        selfListenerDispose();
        disposeChangeListener == null ? void 0 : disposeChangeListener();
        activeThemeManagers.delete(themeManager);
      };
    }, [
      themeManager,
      parentManager,
      isNewTheme,
      props.componentName,
      props.inverse,
      props.name,
      props.reset,
      mounted
    ]);
    if (process.env.NODE_ENV === "development" && props.debug !== "profile") {
      (0, import_react.useEffect)(() => {
        globalThis["TamaguiThemeManagers"] ?? (globalThis["TamaguiThemeManagers"] = /* @__PURE__ */ new Set());
        globalThis["TamaguiThemeManagers"].add(themeManager);
        return () => {
          globalThis["TamaguiThemeManagers"].delete(themeManager);
        };
      }, [themeManager]);
    }
  }
  if (isInversingOnMount) {
    if (!parentManager)
      throw "\u274C 3";
    return {
      isNewTheme: false,
      themeManager: parentManager,
      state: {
        ...parentManager.state,
        className: ""
      }
    };
  }
  return {
    state,
    isNewTheme,
    themeManager
  };
  function createState(prev, force = false) {
    if (prev && (shouldUpdate == null ? void 0 : shouldUpdate()) === false) {
      return prev;
    }
    let themeManager2 = parentManager;
    let state2;
    const hasThemeUpdatingProps = (0, import_ThemeManager.getHasThemeUpdatingProps)(props);
    if (hasThemeUpdatingProps) {
      const getNewThemeManager = () => {
        return new import_ThemeManager.ThemeManager(props, root ? "root" : parentManager);
      };
      if (prev == null ? void 0 : prev.themeManager) {
        themeManager2 = prev.themeManager;
        const forceChange = Boolean(keys == null ? void 0 : keys.length);
        const next = themeManager2.getState(props, parentManager);
        const nextState = getShouldUpdateTheme(
          themeManager2,
          next,
          prev.state,
          forceChange
        );
        if (nextState) {
          state2 = nextState;
          if (!prev.isNewTheme || !import_constants.isWeb) {
            themeManager2 = getNewThemeManager();
          } else {
            themeManager2.updateState(nextState);
          }
        } else {
          if (prev.isNewTheme) {
            if (parentManager && !next) {
              themeManager2 = parentManager;
            }
          }
        }
      } else {
        themeManager2 = getNewThemeManager();
        state2 = { ...themeManager2.state };
      }
    }
    const isNewTheme2 = Boolean(themeManager2 !== parentManager || props.inverse);
    const mounted2 = !props.inverse ? true : root || (prev == null ? void 0 : prev.mounted);
    if (!state2) {
      if (isNewTheme2) {
        state2 = themeManager2.state;
      } else {
        state2 = parentManager.state;
        themeManager2 = parentManager;
      }
    }
    if (!force && state2.name === (prev == null ? void 0 : prev.state.name)) {
      return prev;
    }
    const response = {
      state: state2,
      themeManager: themeManager2,
      isNewTheme: isNewTheme2,
      mounted: mounted2
    };
    if (process.env.NODE_ENV === "development" && props["debug"] && import_constants.isClient) {
      console.groupCollapsed(` \u{1F537} ${themeManager2.id} useChangeThemeEffect createState`);
      const parentState = { ...parentManager == null ? void 0 : parentManager.state };
      const parentId = parentManager == null ? void 0 : parentManager.id;
      const themeManagerState = { ...themeManager2.state };
      console.log({
        props,
        parentState,
        parentId,
        themeManager: themeManager2,
        prev,
        response,
        themeManagerState
      });
      console.groupEnd();
    }
    return response;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activeThemeManagers,
  getThemeProxied,
  useChangeThemeEffect,
  useTheme,
  useThemeWithState
});
//# sourceMappingURL=useTheme.js.map
