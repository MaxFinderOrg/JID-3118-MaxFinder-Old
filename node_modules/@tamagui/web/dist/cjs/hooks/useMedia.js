"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useMedia_exports = {};
__export(useMedia_exports, {
  configureMedia: () => configureMedia,
  getInitialMediaState: () => getInitialMediaState,
  getMedia: () => getMedia,
  getMediaImportanceIfMoreImportant: () => getMediaImportanceIfMoreImportant,
  getMediaKeyImportance: () => getMediaKeyImportance,
  isMediaKey: () => isMediaKey,
  mediaKeyMatch: () => mediaKeyMatch,
  mediaKeyToQuery: () => mediaKeyToQuery,
  mediaKeys: () => mediaKeys,
  mediaObjectToString: () => mediaObjectToString,
  mediaQueryConfig: () => mediaQueryConfig,
  mediaState: () => mediaState,
  mergeMediaByImportance: () => mergeMediaByImportance,
  setMediaShouldUpdate: () => setMediaShouldUpdate,
  setupMediaListeners: () => setupMediaListeners,
  useMedia: () => useMedia,
  useMediaListeners: () => useMediaListeners,
  useMediaPropsActive: () => useMediaPropsActive
});
module.exports = __toCommonJS(useMedia_exports);
var import_constants = require("@tamagui/constants");
var import_react = require("react");
var import_config = require("../config");
var import_createProxy = require("../helpers/createProxy");
var import_matchMedia = require("../helpers/matchMedia");
var import_pseudoDescriptors = require("../helpers/pseudoDescriptors");
let mediaState = (
  // development only safeguard
  process.env.NODE_ENV === "development" ? (0, import_createProxy.createProxy)(
    {},
    {
      get(target, key) {
        if (typeof key === "string" && key[0] === "$" && // dont error on $$typeof
        key[1] !== "$") {
          throw new Error(`Access mediaState should not use "$": ${key}`);
        }
        return Reflect.get(target, key);
      }
    }
  ) : {}
);
const mediaQueryConfig = {};
const getMedia = () => mediaState;
const mediaKeys = /* @__PURE__ */ new Set();
const isMediaKey = (key) => mediaKeys.has(key) || key[0] === "$" && (key.startsWith("$platform-") || key.startsWith("$theme-") || key.startsWith("$group-"));
let initState;
const getInitialMediaState = () => {
  return ((0, import_config.getConfig)().disableSSR ? mediaState : initState) || {};
};
const defaultMediaImportance = Object.keys(import_pseudoDescriptors.pseudoDescriptors).length;
let mediaKeysOrdered;
const getMediaKeyImportance = (key) => {
  if (process.env.NODE_ENV === "development" && key[0] === "$") {
    throw new Error("use short key");
  }
  const conf = (0, import_config.getConfig)();
  if (conf.settings.mediaPropOrder) {
    return defaultMediaImportance;
  }
  return mediaKeysOrdered.indexOf(key) + 100;
};
const dispose = /* @__PURE__ */ new Set();
const configureMedia = (config) => {
  const { media, mediaQueryDefaultActive } = config;
  if (!media)
    return;
  for (const key in media) {
    mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false;
    mediaKeys.add(`$${key}`);
  }
  Object.assign(mediaQueryConfig, media);
  initState = { ...mediaState };
  updateCurrentState();
  mediaKeysOrdered = Object.keys(media);
  if (config.disableSSR) {
    setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach((cb) => cb());
  dispose.clear();
}
let configuredKey = "";
function setupMediaListeners() {
  const nextKey = JSON.stringify(mediaQueryConfig);
  if (nextKey === configuredKey)
    return;
  configuredKey = nextKey;
  unlisten();
  for (const key in mediaQueryConfig) {
    let update2 = function() {
      const next = !!getMatch().matches;
      if (next === mediaState[key])
        return;
      mediaState = { ...mediaState, [key]: next };
      updateCurrentState();
    };
    var update = update2;
    const str = mediaObjectToString(mediaQueryConfig[key], key);
    const getMatch = () => (0, import_matchMedia.matchMedia)(str);
    const match = getMatch();
    if (!match) {
      throw new Error("\u26A0\uFE0F No match");
    }
    match.addListener(update2);
    dispose.add(() => {
      match.removeListener(update2);
    });
    update2();
  }
}
function useMediaListeners(config) {
  if (config.disableSSR)
    return;
  (0, import_constants.useIsomorphicLayoutEffect)(() => {
    setupMediaListeners();
  }, []);
}
const listeners = /* @__PURE__ */ new Set();
let flushing = false;
function updateCurrentState() {
  if (flushing)
    return;
  flushing = true;
  Promise.resolve().then(() => {
    flushing = false;
    listeners.forEach((cb) => cb(mediaState));
  });
}
const shouldUpdate = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, props) {
  return shouldUpdate.set(ref, props);
}
function subscribe(subscriber) {
  listeners.add(subscriber);
  return () => listeners.delete(subscriber);
}
function useMedia(uid) {
  const internal = (0, import_react.useRef)();
  const state = (0, import_react.useSyncExternalStore)(
    subscribe,
    () => {
      if (!internal.current) {
        return initState;
      }
      const { touched, prev } = internal.current;
      const componentState = uid ? shouldUpdate.get(uid) : void 0;
      if (componentState && componentState.enabled === false) {
        return prev;
      }
      const testKeys = (componentState == null ? void 0 : componentState.keys) ?? ((!componentState || componentState.enabled) && touched ? [...touched] : null);
      const hasntUpdated = !testKeys || (testKeys == null ? void 0 : testKeys.every((key) => mediaState[key] === prev[key]));
      if (hasntUpdated) {
        return prev;
      }
      internal.current.prev = mediaState;
      return mediaState;
    },
    () => initState
  );
  return new Proxy(state, {
    get(_, key) {
      var _a;
      if (typeof key === "string") {
        internal.current || (internal.current = { prev: initState });
        (_a = internal.current).touched || (_a.touched = /* @__PURE__ */ new Set());
        internal.current.touched.add(key);
      }
      return Reflect.get(state, key);
    }
  });
}
function useMediaPropsActive(props, opts) {
  const media = useMedia();
  const shouldExpandShorthands = opts == null ? void 0 : opts.expandShorthands;
  return (0, import_react.useMemo)(() => {
    const config = (0, import_config.getConfig)();
    const next = {};
    const importancesUsed = {};
    const propNames = Object.keys(props);
    const len = propNames.length;
    for (let i = 0; i < len; i++) {
      let key = propNames[i];
      const val = props[key];
      if (key[0] === "$") {
        const mediaKey = key.slice(1);
        if (!media[mediaKey])
          continue;
        if (val && typeof val === "object") {
          const subKeys = Object.keys(val);
          for (let j = subKeys.length; j--; j >= 0) {
            let subKey = subKeys[j];
            const value = val[subKey];
            if (shouldExpandShorthands) {
              subKey = config.shorthands[subKey] || subKey;
            }
            mergeMediaByImportance(next, mediaKey, subKey, value, importancesUsed, true);
          }
        }
      } else {
        if (shouldExpandShorthands) {
          key = config.shorthands[key] || key;
        }
        mergeMediaByImportance(next, "", key, val, importancesUsed, true);
      }
    }
    return next;
  }, [media, props]);
}
const getMediaImportanceIfMoreImportant = (mediaKey, key, importancesUsed, isSizeMedia) => {
  const conf = (0, import_config.getConfig)();
  const importance = isSizeMedia && !conf.settings.mediaPropOrder ? getMediaKeyImportance(mediaKey) : defaultMediaImportance;
  return !importancesUsed[key] || importance > importancesUsed[key] ? importance : null;
};
function mergeMediaByImportance(onto, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump) {
  let importance = getMediaImportanceIfMoreImportant(
    mediaKey,
    key,
    importancesUsed,
    isSizeMedia
  );
  if (importanceBump) {
    importance = (importance || 0) + importanceBump;
  }
  if (importance === null) {
    return false;
  }
  importancesUsed[key] = importance;
  onto[key] = value;
  return true;
}
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).toLowerCase();
}
const cache = /* @__PURE__ */ new WeakMap();
const cachedMediaKeyToQuery = {};
function mediaObjectToString(query, key) {
  if (typeof query === "string") {
    return query;
  }
  if (cache.has(query)) {
    return cache.get(query);
  }
  const res = Object.entries(query).map(([feature, value]) => {
    feature = camelToHyphen(feature);
    if (typeof value === "string") {
      return `(${feature}: ${value})`;
    }
    if (typeof value === "number" && /[height|width]$/.test(feature)) {
      value = `${value}px`;
    }
    return `(${feature}: ${value})`;
  }).join(" and ");
  if (key) {
    cachedMediaKeyToQuery[key] = res;
  }
  cache.set(query, res);
  return res;
}
function mediaKeyToQuery(key) {
  return cachedMediaKeyToQuery[key] || mediaObjectToString(mediaQueryConfig[key], key);
}
function mediaKeyMatch(key, dimensions) {
  const mediaQueries = mediaQueryConfig[key];
  const result = Object.keys(mediaQueries).every((query) => {
    const expectedVal = +mediaQueries[query];
    const isMax = query.startsWith("max");
    const isWidth = query.endsWith("Width");
    const givenVal = dimensions[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  configureMedia,
  getInitialMediaState,
  getMedia,
  getMediaImportanceIfMoreImportant,
  getMediaKeyImportance,
  isMediaKey,
  mediaKeyMatch,
  mediaKeyToQuery,
  mediaKeys,
  mediaObjectToString,
  mediaQueryConfig,
  mediaState,
  mergeMediaByImportance,
  setMediaShouldUpdate,
  setupMediaListeners,
  useMedia,
  useMediaListeners,
  useMediaPropsActive
});
//# sourceMappingURL=useMedia.js.map
