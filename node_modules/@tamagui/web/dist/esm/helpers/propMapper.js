import { isAndroid, isWeb } from "@tamagui/constants";
import { tokenCategories } from "@tamagui/helpers";
import { isDevTools } from "../constants/isDevTools";
import { getVariableValue, isVariable } from "../createVariable";
import { expandStyle } from "./expandStyle";
import { expandStylesAndRemoveNullishValues } from "./expandStyles";
import { getFontsForLanguage, getVariantExtras } from "./getVariantExtras";
import { isObj } from "./isObj";
import { pseudoDescriptors } from "./pseudoDescriptors";
const propMapper = (key, value, styleStateIn, subPropsIn) => {
  if (!(process.env.TAMAGUI_TARGET === "native" && isAndroid)) {
    if (key === "elevationAndroid")
      return;
  }
  const subProps = styleStateIn.styleProps.fallbackProps || subPropsIn;
  const styleState = subProps ? new Proxy(styleStateIn, {
    get(_, k) {
      return k === "curProps" ? subProps : Reflect.get(_, k);
    }
  }) : styleStateIn;
  const { conf, styleProps, fontFamily, staticConfig } = styleState;
  const { variants } = staticConfig;
  if (process.env.NODE_ENV === "development" && fontFamily && fontFamily[0] === "$" && !(fontFamily in conf.fontsParsed)) {
    console.warn(
      `Warning: no fontFamily "${fontFamily}" found in config: ${Object.keys(conf.fontsParsed).join(
        ", "
      )}`
    );
  }
  if (variants && key in variants) {
    styleState.curProps[key] = value;
    const variantValue = resolveVariants(key, value, styleProps, styleState, "");
    if (variantValue) {
      return variantValue;
    }
  }
  let shouldReturn = false;
  if (key in conf.shorthands) {
    shouldReturn = true;
    key = conf.shorthands[key];
  }
  if (value) {
    if (value[0] === "$") {
      value = getToken(key, value, styleProps, styleState);
    } else if (isVariable(value)) {
      value = resolveVariableValue(value, styleProps);
    }
  }
  if (shouldReturn || value != null) {
    return expandStyle(key, value) || [[key, value]];
  }
};
const resolveVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  const { staticConfig, conf, debug } = styleState;
  const { variants } = staticConfig;
  if (!variants)
    return;
  let variantValue = getVariantDefinition(variants[key], key, value, conf);
  if (process.env.NODE_ENV === "development" && debug === "verbose") {
    console.groupCollapsed(`\u2666\uFE0F\u2666\uFE0F\u2666\uFE0F resolve variant ${key}`);
    console.log({
      key,
      value,
      variantValue,
      variants,
      curProps: { ...styleState.curProps }
    });
    console.groupEnd();
  }
  if (!variantValue) {
    if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1") {
      if (typeof value !== "boolean") {
        const name = staticConfig.componentName || "[UnnamedComponent]";
        console.warn(
          `No variant found: ${name} has variant "${key}", but no matching value "${value}"`
        );
      }
    }
    return;
  }
  if (typeof variantValue === "function") {
    const fn = variantValue;
    const extras = getVariantExtras(styleState);
    variantValue = fn(value, extras);
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      console.groupCollapsed("   expanded functional variant", key);
      console.log({ fn, variantValue, extras });
      console.groupEnd();
    }
  }
  let fontFamilyResult;
  if (isObj(variantValue)) {
    const fontFamilyUpdate = variantValue.fontFamily || variantValue[conf.inverseShorthands.fontFamily];
    if (fontFamilyUpdate) {
      fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf);
      styleState.fontFamily = fontFamilyResult;
      if (process.env.NODE_ENV === "development" && debug === "verbose") {
        console.log(`   updating font family`, fontFamilyResult);
      }
    }
    variantValue = resolveTokensAndVariants(
      key,
      variantValue,
      styleProps,
      styleState,
      parentVariantKey
    );
  }
  if (variantValue) {
    const expanded = expandStylesAndRemoveNullishValues(variantValue);
    const next = Object.entries(expanded);
    if (fontFamilyResult && fontFamilyResult[0] === "$") {
      fontFamilyCache.set(next, getVariableValue(fontFamilyResult));
    }
    return next;
  }
};
function getFontFamilyFromNameOrVariable(input, conf) {
  if (isVariable(input)) {
    const val = variableToFontNameCache.get(input);
    if (val)
      return val;
    for (const key in conf.fontsParsed) {
      const familyVariable = conf.fontsParsed[key].family;
      if (isVariable(familyVariable)) {
        variableToFontNameCache.set(familyVariable, key);
        if (familyVariable === input) {
          return key;
        }
      }
    }
  } else if (typeof input === "string") {
    if (input[0] === "$") {
      return input;
    }
  }
}
const variableToFontNameCache = /* @__PURE__ */ new WeakMap();
const fontFamilyCache = /* @__PURE__ */ new WeakMap();
const getPropMappedFontFamily = (expanded) => {
  return expanded && fontFamilyCache.get(expanded);
};
const resolveTokensAndVariants = (key, value, styleProps, styleState, parentVariantKey) => {
  var _a;
  const { conf, staticConfig, debug, theme } = styleState;
  const { variants } = staticConfig;
  const res = {};
  if (process.env.NODE_ENV === "development" && debug === "verbose") {
    console.log(`   - resolveTokensAndVariants`, key, value);
  }
  for (const rKey in value) {
    const fKey = conf.shorthands[rKey] || rKey;
    const val = value[rKey];
    if (variants && fKey in variants) {
      styleState.curProps[fKey] = val;
      if (parentVariantKey && parentVariantKey === key) {
        res[fKey] = // SYNC WITH *1
        val[0] === "$" ? getToken(fKey, val, styleProps, styleState) : val;
      } else {
        const variantOut = resolveVariants(fKey, val, styleProps, styleState, key);
        if (variantOut) {
          for (const [key2, val2] of variantOut) {
            if (val2 == null)
              continue;
            if (key2 in pseudoDescriptors) {
              res[key2] ??= {};
              Object.assign(res[key2], val2);
            } else {
              res[key2] = val2;
            }
          }
        }
      }
      continue;
    }
    if (isVariable(val)) {
      res[fKey] = resolveVariableValue(val, styleProps);
      continue;
    }
    if (typeof val === "string") {
      const fVal = (
        // SYNC WITH *1
        val[0] === "$" ? getToken(fKey, val, styleProps, styleState) : val
      );
      res[fKey] = fVal;
      continue;
    }
    if (isObj(val)) {
      const subObject = resolveTokensAndVariants(fKey, val, styleProps, styleState, key);
      if (process.env.NODE_ENV === "development" && debug === "verbose") {
        console.log(`object`, fKey, subObject);
      }
      res[fKey] ??= {};
      Object.assign(res[fKey], subObject);
    } else {
      res[fKey] = val;
    }
    if (process.env.NODE_ENV === "development") {
      if (debug) {
        if (((_a = res[fKey]) == null ? void 0 : _a[0]) === "$") {
          console.warn(`\u26A0\uFE0F Missing token in theme ${theme.name}:`, fKey, res[fKey], theme);
        }
      }
    }
  }
  return res;
};
const tokenCats = ["size", "color", "radius", "space", "zIndex"].map((name) => ({
  name,
  spreadName: `...${name}`
}));
function getVariantDefinition(variant, key, value, conf) {
  if (typeof variant === "function") {
    return variant;
  }
  if (variant[value]) {
    return variant[value];
  }
  const { tokensParsed } = conf;
  for (const { name, spreadName } of tokenCats) {
    if (spreadName in variant && value in tokensParsed[name]) {
      return variant[spreadName];
    }
  }
  const fontSizeVariant = variant["...fontSize"];
  if (fontSizeVariant && conf.fontSizeTokens.has(value)) {
    return fontSizeVariant;
  }
  return variant[`:${typeof value}`] || variant["..."] || variant["...size"];
}
const fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
};
const getToken = (key, value, styleProps, styleState) => {
  var _a, _b;
  const { theme, conf, context, fontFamily } = styleState;
  const tokensParsed = conf.tokensParsed;
  let valOrVar;
  let hasSet = false;
  if (value in theme) {
    if (process.env.NODE_ENV === "development" && styleState.debug === "verbose") {
      console.log(` - getting theme value for ${key} from ${value}`);
    }
    valOrVar = theme[value];
    hasSet = true;
  } else {
    if (value in conf.specificTokens) {
      hasSet = true;
      valOrVar = conf.specificTokens[value];
    } else {
      switch (key) {
        case "fontFamily": {
          const fontsParsed = (context == null ? void 0 : context.language) ? getFontsForLanguage(conf.fontsParsed, context.language) : conf.fontsParsed;
          valOrVar = ((_a = fontsParsed[value]) == null ? void 0 : _a.family) || value;
          hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          const fam = fontFamily || styleState.conf.defaultFont;
          if (fam) {
            const fontsParsed = (context == null ? void 0 : context.language) ? getFontsForLanguage(conf.fontsParsed, context.language) : conf.fontsParsed;
            const font = fontsParsed[fam];
            valOrVar = ((_b = font == null ? void 0 : font[fontShorthand[key] || key]) == null ? void 0 : _b[value]) || value;
            hasSet = true;
          }
          break;
        }
      }
      for (const cat in tokenCategories) {
        if (key in tokenCategories[cat]) {
          const res = tokensParsed[cat][value];
          if (res != null) {
            valOrVar = res;
            hasSet = true;
          }
        }
      }
      if (!hasSet) {
        const spaceVar = tokensParsed.space[value];
        if (spaceVar != null) {
          valOrVar = spaceVar;
          hasSet = true;
        }
      }
    }
  }
  if (hasSet) {
    const out = resolveVariableValue(valOrVar, styleProps);
    return out;
  }
  if (process.env.NODE_ENV === "development" && isDevTools && styleState.debug === "verbose") {
    console.groupCollapsed("  \uFE52 propMap (val)", key, value);
    console.log({ valOrVar, theme, hasSet }, theme[key]);
    console.groupEnd();
  }
  return value;
};
function resolveVariableValue(valOrVar, { resolveVariablesAs }) {
  if (isVariable(valOrVar)) {
    if (!isWeb || resolveVariablesAs === "value") {
      return valOrVar.val;
    }
    return valOrVar.variable;
  }
  return valOrVar;
}
export {
  getFontFamilyFromNameOrVariable,
  getPropMappedFontFamily,
  propMapper
};
//# sourceMappingURL=propMapper.js.map
