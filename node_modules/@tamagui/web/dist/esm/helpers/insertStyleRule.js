import { isClient } from "@tamagui/constants";
import { createVariable } from "../createVariable";
const scannedCache = /* @__PURE__ */ new WeakMap();
const totalSelectorsInserted = /* @__PURE__ */ new Map();
const allSelectors = {};
const allRules = {};
const insertedTransforms = {};
const getAllSelectors = () => allSelectors;
const getAllRules = () => Object.values(allRules);
const getAllTransforms = () => insertedTransforms;
function addTransform(identifier, css, rule) {
  const s = css.indexOf("transform:");
  if (s === -1) {
    if (process.env.NODE_ENV === "development") {
      console.error(`\u274C Invalid transform, likely used deg/% improperly ${identifier}`);
    }
    return;
  }
  const startI = s + "transform:".length;
  const endI = css.indexOf(";");
  const value = css.slice(startI, endI);
  if (!insertedTransforms[identifier]) {
    insertedTransforms[identifier] = value;
    return true;
  }
}
function listenForSheetChanges() {
  if (!isClient)
    return;
  const mo = new MutationObserver((entries) => {
    for (const entry of entries) {
      if (entry instanceof HTMLStyleElement && entry.sheet || entry instanceof HTMLLinkElement && entry.href.endsWith(".css")) {
        scanAllSheets();
        break;
      }
    }
  });
  mo.observe(document.head, {
    childList: true
  });
}
let lastScannedSheets = null;
function scanAllSheets(collectThemes = false, tokens) {
  if (process.env.NODE_ENV === "test")
    return;
  if (!isClient)
    return;
  let themes;
  const sheets = document.styleSheets || [];
  const prev = lastScannedSheets;
  const current = new Set(sheets);
  if (document.styleSheets) {
    for (const sheet2 of current) {
      if (sheet2) {
        const out = updateSheetStyles(sheet2, false, collectThemes, tokens);
        if (out) {
          themes = out;
        }
      }
    }
    lastScannedSheets = current;
  }
  if (prev) {
    for (const sheet2 of prev) {
      if (sheet2 && !current.has(sheet2)) {
        updateSheetStyles(sheet2, true);
      }
    }
  }
  return themes;
}
function track(id, remove = false) {
  const next = (totalSelectorsInserted.get(id) || 0) + (remove ? -1 : 1);
  totalSelectorsInserted.set(id, next);
  return next;
}
const bailAfterEnv = process.env.TAMAGUI_BAIL_AFTER_SCANNING_X_CSS_RULES;
const bailAfter = bailAfterEnv ? +bailAfterEnv : 250;
function updateSheetStyles(sheet2, remove = false, collectThemes = false, tokens) {
  var _a, _b;
  let rules;
  try {
    rules = sheet2.cssRules;
    if (!rules) {
      return;
    }
  } catch {
    return;
  }
  const firstSelector = (_a = getTamaguiSelector(rules[0], collectThemes)) == null ? void 0 : _a[0];
  const lastSelector = (_b = getTamaguiSelector(rules[rules.length - 1], collectThemes)) == null ? void 0 : _b[0];
  const cacheKey = `${rules.length}${firstSelector}${lastSelector}`;
  const lastScanned = scannedCache.get(sheet2);
  if (!remove) {
    if (lastScanned === cacheKey) {
      return;
    }
  }
  const len = rules.length;
  let fails = 0;
  let dedupedThemes;
  for (let i = 0; i < len; i++) {
    const rule = rules[i];
    if (!(rule instanceof CSSStyleRule))
      continue;
    const response = getTamaguiSelector(rule, collectThemes);
    if (response) {
      fails = 0;
    } else {
      fails++;
      if (fails > bailAfter) {
        return;
      }
      continue;
    }
    const [identifier, cssRule, isTheme] = response;
    if (isTheme) {
      const deduped = addThemesFromCSS(cssRule, tokens);
      if (deduped) {
        dedupedThemes ||= [];
        dedupedThemes.push(deduped);
      }
      continue;
    }
    const total = track(identifier, remove);
    if (remove) {
      if (total === 0) {
        delete allSelectors[identifier];
      }
    } else if (!(identifier in allSelectors)) {
      const isTransform = identifier.startsWith("_transform");
      const shouldInsert = isTransform ? addTransform(identifier, cssRule.cssText, cssRule) : true;
      if (shouldInsert) {
        allSelectors[identifier] = cssRule.cssText;
      }
    }
  }
  scannedCache.set(sheet2, cacheKey);
  return dedupedThemes;
}
let colorVarToVal;
let rootComputedStyle = null;
function addThemesFromCSS(cssStyleRule, tokens) {
  const selectors = cssStyleRule.selectorText.split(",");
  if (!selectors.length)
    return;
  if (tokens && !colorVarToVal) {
    colorVarToVal = {};
    for (const key in tokens.color) {
      const token = tokens.color[key];
      colorVarToVal[token.name] = token.val;
    }
  }
  const rulesWithBraces = (cssStyleRule.cssText || "").slice(cssStyleRule.selectorText.length + 2, -1).trim();
  const rules = rulesWithBraces.split(";");
  const values = {};
  for (const rule of rules) {
    const sepI = rule.indexOf(":");
    if (sepI === -1)
      continue;
    const key = rule.slice(rule.indexOf("--") + 2, sepI);
    const val = rule.slice(sepI + 2);
    let value;
    if (val[3] === "(") {
      const varName = val.slice(6, -1);
      const tokenVal = colorVarToVal[varName];
      if (tokenVal) {
        value = tokenVal;
      } else {
        rootComputedStyle ||= getComputedStyle(document.body);
        value = rootComputedStyle.getPropertyValue("--" + varName);
      }
    } else {
      value = val;
    }
    values[key] = createVariable(
      {
        key,
        name: key,
        val: value
      },
      true
    );
  }
  const dedupedEntry = {
    names: [],
    theme: values
  };
  for (const selector of selectors) {
    let scheme = selector.includes("t_dark") ? "dark" : selector.includes("t_light") ? "light" : "";
    let name = selector.slice(selector.lastIndexOf(".t_") + 3);
    if (name.startsWith(scheme)) {
      name = name.slice(scheme.length + 1);
    }
    if (scheme === name) {
      scheme = "";
    }
    const themeName = `${scheme}${scheme && name ? "_" : ""}${name}`;
    if (dedupedEntry.names.includes(themeName)) {
      continue;
    }
    dedupedEntry.names.push(themeName);
  }
  return dedupedEntry;
}
function getTamaguiSelector(rule, collectThemes = false) {
  if (rule instanceof CSSStyleRule) {
    const text = rule.selectorText;
    if (text[0] === ":" && text[1] === "r") {
      if (text.startsWith(":root ._")) {
        return [getIdentifierFromTamaguiSelector(text), rule];
      }
      if (collectThemes) {
        if (text.startsWith(":root.t_") || text.startsWith(":root .t_")) {
          return [
            text.slice(0, 20),
            // just used as uid
            rule,
            true
          ];
        }
      }
    }
  } else if (rule instanceof CSSMediaRule) {
    if (rule.cssRules.length > 1)
      return;
    return getTamaguiSelector(rule.cssRules[0]);
  }
}
const getIdentifierFromTamaguiSelector = (selector) => {
  let res = selector.slice(7);
  if (selector.includes(":")) {
    return res.replace(/:[a-z]+$/, "");
  }
  return res;
};
const sheet = isClient ? document.head.appendChild(document.createElement("style")).sheet : null;
function updateRules(identifier, rules) {
  if (identifier in allRules) {
    return false;
  }
  allRules[identifier] = rules.join(" ");
  if (identifier.startsWith("_transform")) {
    return addTransform(identifier, rules[0]);
  }
  return true;
}
function insertStyleRules(rulesToInsert) {
  if (!rulesToInsert.length || !sheet) {
    return;
  }
  for (const { identifier, rules } of rulesToInsert) {
    if (!shouldInsertStyleRules(identifier)) {
      continue;
    }
    allSelectors[identifier] = rules.join("\n");
    track(identifier);
    updateRules(identifier, rules);
    for (const rule of rules) {
      if (process.env.NODE_ENV === "production") {
        sheet.insertRule(rule, sheet.cssRules.length);
      } else {
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (err) {
          console.groupCollapsed(
            `Error inserting rule into CSSStyleSheet: ${String(err)}`
          );
          console.log({ rule, rulesToInsert });
          console.trace();
          console.groupEnd();
        }
      }
    }
  }
}
function shouldInsertStyleRules(identifier) {
  if (process.env.IS_STATIC === "is_static") {
    return true;
  }
  const total = totalSelectorsInserted.get(identifier);
  if (process.env.NODE_ENV === "development") {
    if (totalSelectorsInserted.size > +(process.env.TAMAGUI_STYLE_INSERTION_WARNING_LIMIT || 5e4)) {
      console.warn(
        `Warning: inserting many CSS rules, you may be animating something and generating many CSS insertions, which can degrade performance. Instead, try using the "disableClassName" property on elements that change styles often. To disable this warning set TAMAGUI_STYLE_INSERTION_WARNING_LIMIT from 50000 to something higher`
      );
    }
  }
  return total === void 0 || total < 2;
}
export {
  getAllRules,
  getAllSelectors,
  getAllTransforms,
  insertStyleRules,
  insertedTransforms,
  listenForSheetChanges,
  scanAllSheets,
  shouldInsertStyleRules,
  updateRules
};
//# sourceMappingURL=insertStyleRule.js.map
