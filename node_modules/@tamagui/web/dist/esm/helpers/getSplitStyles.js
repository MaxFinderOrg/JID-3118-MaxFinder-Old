import {
  currentPlatform,
  isAndroid,
  isClient,
  isServer,
  isWeb,
  useIsomorphicLayoutEffect
} from "@tamagui/constants";
import {
  stylePropsText,
  stylePropsTransform,
  validPseudoKeys,
  validStyles,
  validStylesOnBaseProps
} from "@tamagui/helpers";
import { useInsertionEffect } from "react";
import { getConfig, getFont } from "../config";
import {
  accessibilityDirectMap,
  accessibilityWebRoleToNativeRole,
  nativeAccessibilityState,
  nativeAccessibilityValue,
  webToNativeAccessibilityDirectMap
} from "../constants/accessibilityDirectMap";
import { isDevTools } from "../constants/isDevTools";
import {
  getMediaImportanceIfMoreImportant,
  mediaState as globalMediaState,
  isMediaKey,
  mediaKeyMatch,
  mediaQueryConfig,
  mergeMediaByImportance
} from "../hooks/useMedia";
import { createMediaStyle } from "./createMediaStyle";
import { fixStyles } from "./expandStyles";
import { getGroupPropParts } from "./getGroupPropParts";
import { generateAtomicStyles, getStylesAtomic, styleToCSS } from "./getStylesAtomic";
import {
  insertStyleRules,
  insertedTransforms,
  scanAllSheets,
  shouldInsertStyleRules,
  updateRules
} from "./insertStyleRule";
import {
  normalizeValueWithProperty,
  reverseMapClassNameToValue
} from "./normalizeValueWithProperty";
import { getPropMappedFontFamily, propMapper } from "./propMapper";
import { pseudoDescriptors, pseudoPriorities } from "./pseudoDescriptors";
const fontFamilyKey = "fontFamily";
const IS_STATIC = process.env.IS_STATIC === "is_static";
let conf;
const PROP_SPLIT = "-";
const getSplitStyles = (props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) => {
  var _a, _b, _c, _d, _e, _f, _g;
  conf = conf || getConfig();
  const { shorthands } = conf;
  const {
    isHOC,
    isText,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig;
  const validStyleProps = isText ? stylePropsText : validStyles;
  const viewProps = {};
  const mediaState = styleProps.mediaState || globalMediaState;
  const usedKeys = {};
  const shouldDoClasses = acceptsClassName && isWeb && !styleProps.noClassNames;
  const rulesToInsert = [];
  const classNames = {};
  const transforms = {};
  let pseudos = null;
  let space = props.space;
  let hasMedia = false;
  let dynamicThemeAccess;
  let pseudoGroups;
  let mediaGroups;
  let style = {};
  let className = "";
  let mediaStylesSeen = 0;
  const styleState = {
    curProps: Object.assign({}, props),
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  if (process.env.NODE_ENV === "development" && debug && debug !== "profile" && isClient) {
    console.groupCollapsed("getSplitStyles (collapsed)");
    console.log({
      props,
      staticConfig,
      shouldDoClasses,
      styleProps,
      componentState,
      styleState,
      theme: { ...theme }
    });
    console.groupEnd();
  }
  if (process.env.TAMAGUI_TARGET === "web" && typeof props.className === "string") {
    for (const cn of props.className.split(" ")) {
      if (cn[0] === "_") {
        const [shorthand, mediaOrPseudo] = cn.slice(1).split("-");
        const isMedia = mediaOrPseudo[0] === "_";
        const isPseudo = mediaOrPseudo[0] === "0";
        const isMediaOrPseudo = isMedia || isPseudo;
        let fullKey = shorthands[shorthand];
        if (isMedia) {
          let mediaShortKey = mediaOrPseudo.slice(1);
          mediaShortKey = mediaShortKey.slice(0, mediaShortKey.indexOf("_"));
          fullKey += `${PROP_SPLIT}${mediaShortKey}`;
        } else if (isPseudo) {
          const pseudoShortKey = mediaOrPseudo.slice(1);
          fullKey += `${PROP_SPLIT}${pseudoShortKey}`;
        }
        usedKeys[fullKey] = 1;
        mergeClassName(transforms, classNames, fullKey, cn, isMediaOrPseudo);
      } else if (cn) {
        className += ` ${cn}`;
      }
    }
  }
  for (const keyOg in props) {
    let keyInit = keyOg;
    let valInit = props[keyOg];
    if (keyInit in shorthands) {
      keyInit = shorthands[keyInit];
    }
    if (keyInit === "className")
      continue;
    if (keyInit in usedKeys)
      continue;
    if (keyInit in skipProps && !isHOC) {
      if (keyInit === "group") {
        if (process.env.TAMAGUI_TARGET === "web") {
          const identifier = `t_group_${valInit}`;
          const containerCSS = {
            identifier,
            property: "container",
            rules: [
              `.${identifier} { container-name: ${valInit}; container-type: inline-size; }`
            ]
          };
          addStyleToInsertRules(rulesToInsert, containerCSS);
        }
      }
      continue;
    }
    const valInitType = typeof valInit;
    styleState.curProps[keyInit] = valInit;
    if (process.env.TAMAGUI_TARGET === "web") {
      if (valInitType === "string" && valInit[0] === "_") {
        if (keyInit in validStyleProps || keyInit.includes("-")) {
          if (process.env.NODE_ENV === "development" && debug) {
            console.log(`Adding compiled style ${keyInit}: ${valInit}`);
          }
          if (shouldDoClasses) {
            classNames[keyInit] = valInit;
            delete style[keyInit];
          } else {
            style[keyInit] = reverseMapClassNameToValue(keyInit, valInit);
            delete className[keyInit];
          }
          continue;
        }
      }
    }
    if (process.env.TAMAGUI_TARGET === "native") {
      if (!isAndroid) {
        if (keyInit === "elevationAndroid")
          continue;
      }
      if (keyInit === "userSelect") {
        keyInit = "selectable";
        valInit = valInit === "none" ? false : true;
      } else if (keyInit === "role") {
        viewProps["accessibilityRole"] = accessibilityWebRoleToNativeRole[valInit];
        continue;
      } else if (keyInit.startsWith("aria-")) {
        if (webToNativeAccessibilityDirectMap[keyInit]) {
          const nativeA11yProp = webToNativeAccessibilityDirectMap[keyInit];
          if (keyInit === "aria-hidden") {
            viewProps["aria-hidden"] = valInit;
          }
          viewProps[nativeA11yProp] = valInit;
          continue;
        } else if (nativeAccessibilityValue[keyInit]) {
          let field = nativeAccessibilityValue[keyInit];
          if (viewProps["accessibilityValue"]) {
            viewProps["accessibilityValue"][field] = valInit;
          } else {
            viewProps["accessibilityValue"] = {
              [field]: valInit
            };
          }
        } else if (nativeAccessibilityState[keyInit]) {
          let field = nativeAccessibilityState[keyInit];
          if (viewProps["accessibilityState"]) {
            viewProps["accessibilityState"][field] = valInit;
          } else {
            viewProps["accessibilityState"] = {
              [field]: valInit
            };
          }
        }
        continue;
      } else if (keyInit.startsWith("data-")) {
        continue;
      }
    }
    if (keyInit === "dataSet") {
      for (const keyInit2 in valInit) {
        viewProps[`data-${hyphenate(keyInit2)}`] = valInit[keyInit2];
      }
      continue;
    }
    if (keyInit[0] === "_" && keyInit.startsWith("_style")) {
      mergeStyleProp(styleState, valInit);
      continue;
    }
    if (process.env.TAMAGUI_TARGET === "web") {
      if (keyInit === "disabled" && valInit === true) {
        viewProps["aria-disabled"] = true;
        if (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") {
          viewProps.disabled = true;
        }
        if (!(variants == null ? void 0 : variants.disabled)) {
          continue;
        }
      }
      if (keyInit === "testID") {
        viewProps[isReactNative ? keyInit : "data-testid"] = valInit;
        continue;
      }
      if (keyInit === "id" || keyInit === "nativeID") {
        if (isReactNative) {
          viewProps.nativeID = valInit;
        } else {
          viewProps.id = valInit;
        }
        continue;
      }
      let didUseKeyInit = false;
      if (isReactNative) {
        if (keyInit in accessibilityDirectMap || keyInit.startsWith("accessibility")) {
          viewProps[keyInit] = valInit;
          continue;
        }
      } else {
        didUseKeyInit = true;
        if (keyInit in accessibilityDirectMap) {
          viewProps[accessibilityDirectMap[keyInit]] = valInit;
          continue;
        } else {
          switch (keyInit) {
            case "accessibilityRole": {
              if (valInit === "none") {
                viewProps.role = "presentation";
              } else {
                viewProps.role = accessibilityRoleToWebRole[valInit] || valInit;
              }
              continue;
            }
            case "accessibilityLabelledBy":
            case "accessibilityFlowTo":
            case "accessibilityControls":
            case "accessibilityDescribedBy": {
              viewProps[`aria-${keyInit.replace("accessibility", "").toLowerCase()}`] = processIDRefList(valInit);
              continue;
            }
            case "accessibilityKeyShortcuts": {
              if (Array.isArray(valInit)) {
                viewProps["aria-keyshortcuts"] = valInit.join(" ");
              }
              continue;
            }
            case "accessibilityLiveRegion": {
              viewProps["aria-live"] = valInit === "none" ? "off" : valInit;
              continue;
            }
            case "accessibilityReadOnly": {
              viewProps["aria-readonly"] = valInit;
              if (elementType === "input" || elementType === "select" || elementType === "textarea") {
                viewProps.readOnly = true;
              }
              continue;
            }
            case "accessibilityRequired": {
              viewProps["aria-required"] = valInit;
              if (elementType === "input" || elementType === "select" || elementType === "textarea") {
                viewProps.required = valInit;
              }
              continue;
            }
            default: {
              didUseKeyInit = false;
            }
          }
        }
      }
      if (didUseKeyInit) {
        continue;
      }
      if (valInit && valInit[0] === "_") {
        const isValidClassName = keyInit in validStyles;
        const isMediaOrPseudo2 = !isValidClassName && keyInit.includes(PROP_SPLIT) && validStyles[keyInit.split(PROP_SPLIT)[0]];
        if (isValidClassName || isMediaOrPseudo2) {
          if (process.env.NODE_ENV === "development" && debug) {
            console.log("tamagui classname prop", keyInit, valInit);
          }
          if (shouldDoClasses) {
            mergeClassName(transforms, classNames, keyInit, valInit, isMediaOrPseudo2);
            delete style[keyInit];
          } else {
            style[keyInit] = reverseMapClassNameToValue(keyInit, valInit);
            delete className[keyInit];
          }
          continue;
        }
      }
    }
    const isValidStyleKeyInit = keyInit in validStyleProps;
    const isShorthand = keyInit in shorthands;
    let isVariant = !isValidStyleKeyInit && variants && keyInit in variants;
    const isStyleLikeKey = isShorthand || isValidStyleKeyInit || isVariant;
    let isPseudo = keyInit in validPseudoKeys;
    let isMedia = !isStyleLikeKey && !isPseudo && isMediaKey(keyInit);
    let isMediaOrPseudo = isMedia || isPseudo;
    const isStyleProp = isMediaOrPseudo || isVariant || isValidStyleKeyInit || isShorthand;
    if (isStyleProp && props.asChild === "except-style") {
      continue;
    }
    const shouldPassProp = !isStyleProp || // is in parent variants
    isHOC && (parentStaticConfig == null ? void 0 : parentStaticConfig.variants) && keyInit in parentStaticConfig.variants || (inlineProps == null ? void 0 : inlineProps.has(keyInit));
    const isHOCShouldPassThrough = Boolean(
      isHOC && (isShorthand || isValidStyleKeyInit || isMediaOrPseudo || ((_a = parentStaticConfig == null ? void 0 : parentStaticConfig.variants) == null ? void 0 : _a[keyInit]) || keyInit in skipProps)
    );
    const shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      console.groupCollapsed(
        `\u{1F539}\u{1F539}\u{1F539}\u{1F539} ${keyOg}${keyInit !== keyOg ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""} \u{1F539}\u{1F539}\u{1F539}\u{1F539}`
      );
      console.log({ isVariant, valInit, shouldPassProp });
      if (isClient) {
        console.log({
          variants,
          variant: variants == null ? void 0 : variants[keyInit],
          isVariant,
          isHOCShouldPassThrough,
          curProps: { ...styleState.curProps },
          parentStaticConfig
        });
      }
      console.groupEnd();
    }
    if (shouldPassThrough) {
      passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo);
      if (!isVariant) {
        continue;
      }
    }
    if (keyInit in skipProps)
      continue;
    if (isText) {
      if (valInit && (keyInit === fontFamilyKey || keyInit === shorthands[fontFamilyKey]) && valInit in conf.fontsParsed) {
        styleState.fontFamily = valInit;
      }
    }
    if (process.env.TAMAGUI_TARGET === "native" && isValidStyleKeyInit && !variants && (valInitType === "number" || valInitType === "string" && valInit[0] !== "$")) {
      style[keyInit] = valInit;
      continue;
    }
    const avoidPropMap = isMediaOrPseudo || !isVariant && !isValidStyleKeyInit;
    const expanded = avoidPropMap ? [[keyInit, valInit]] : propMapper(keyInit, valInit, styleState);
    const next = getPropMappedFontFamily(expanded);
    if (next) {
      styleState.fontFamily = next;
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      console.groupCollapsed("  \u{1F4A0} expanded", keyInit, valInit);
      try {
        if (!isServer && isDevTools) {
          console.log({
            expanded,
            styleProps,
            componentState,
            isVariant,
            variant: variants == null ? void 0 : variants[keyInit],
            shouldPassProp,
            isHOCShouldPassThrough,
            theme,
            usedKeys: { ...usedKeys },
            curProps: { ...styleState.curProps }
          });
          console.log("expanded", expanded, "\nusedKeys", { ...usedKeys }, "\ncurrent", {
            ...style
          });
        }
      } catch {
      }
      console.groupEnd();
    }
    if (!expanded)
      continue;
    for (const [key, val] of expanded) {
      if (val == null)
        continue;
      if (key in usedKeys)
        continue;
      isPseudo = key in validPseudoKeys;
      isMedia = !isPseudo && !isValidStyleKeyInit && isMediaKey(key);
      isMediaOrPseudo = isMedia || isPseudo;
      isVariant = variants && key in variants;
      if ((inlineProps == null ? void 0 : inlineProps.has(key)) || IS_STATIC && (inlineWhenUnflattened == null ? void 0 : inlineWhenUnflattened.has(key))) {
        viewProps[key] = props[key] ?? val;
      }
      const isHOCShouldPassThrough2 = isHOC && (isMediaOrPseudo || ((_b = parentStaticConfig == null ? void 0 : parentStaticConfig.variants) == null ? void 0 : _b[keyInit]));
      if (isHOCShouldPassThrough2) {
        passDownProp(viewProps, key, val, isMediaOrPseudo);
        if (process.env.NODE_ENV === "development" && debug === "verbose") {
          console.groupCollapsed(` - passing down prop ${key}`);
          console.log({ val, after: { ...viewProps[key] } });
          console.groupEnd();
        }
        continue;
      }
      if (isPseudo) {
        if (!val)
          continue;
        const pseudoStyleObject = getSubStyle(
          styleState,
          key,
          val,
          styleProps.noClassNames
        );
        const descriptor = pseudoDescriptors[key];
        const isEnter = key === "enterStyle";
        const isExit = key === "exitStyle";
        if (process.env.NODE_ENV === "development" && !styleProps.isAnimated && !componentState.unmounted && (isEnter || isExit)) {
          console.warn(
            `No animation prop given to component ${staticConfig.componentName || ""} with enterStyle / exitStyle, these styles will be ignore.`
          );
        }
        if (!descriptor || isExit && !styleProps.isExiting) {
          continue;
        }
        if (!shouldDoClasses || IS_STATIC) {
          pseudos ||= {};
          pseudos[key] ||= {};
          if (IS_STATIC) {
            Object.assign(pseudos[key], pseudoStyleObject);
          }
        }
        if (shouldDoClasses && !isEnter && !isExit) {
          const pseudoStyles = generateAtomicStyles(pseudoStyleObject, descriptor);
          if (process.env.NODE_ENV === "development" && debug === "verbose") {
            console.groupCollapsed("pseudo (classes)", key);
            console.log({ pseudoStyleObject, pseudoStyles });
            console.groupEnd();
          }
          for (const psuedoStyle of pseudoStyles) {
            const fullKey = `${psuedoStyle.property}${PROP_SPLIT}${descriptor.name}`;
            if (fullKey in usedKeys)
              continue;
            addStyleToInsertRules(rulesToInsert, psuedoStyle);
            mergeClassName(
              transforms,
              classNames,
              fullKey,
              psuedoStyle.identifier,
              isMediaOrPseudo,
              true
            );
          }
        } else {
          const descriptorKey = descriptor.stateKey || descriptor.name;
          const pseudoState = componentState[descriptorKey];
          let isDisabled = isExit ? !styleProps.isExiting : !pseudoState;
          if (isWeb && !isClient && isEnter) {
            isDisabled = false;
          }
          if (process.env.NODE_ENV === "development" && debug === "verbose") {
            console.groupCollapsed("pseudo", key, { isDisabled });
            console.log(pseudoStyleObject, {
              isDisabled,
              descriptorKey,
              descriptor,
              pseudoState,
              state: { ...componentState }
            });
            console.groupEnd();
          }
          const importance = descriptor.priority;
          for (const pkey in pseudoStyleObject) {
            const val2 = pseudoStyleObject[pkey];
            if (isDisabled) {
              if (pkey in animatableDefaults && !(pkey in usedKeys)) {
                const defaultVal = animatableDefaults[pkey];
                mergeStyle(styleState, pkey, defaultVal);
              }
            } else {
              const curImportance = usedKeys[importance] || 0;
              const shouldMerge = importance >= curImportance;
              if (shouldMerge) {
                pseudos ||= {};
                pseudos[key] ||= {};
                pseudos[key][pkey] = val2;
                mergeStyle(styleState, pkey, val2);
                usedKeys[pkey] ||= 1;
              }
              if (process.env.NODE_ENV === "development" && debug === "verbose") {
                console.log("    subKey", pkey, shouldMerge, {
                  importance,
                  curImportance,
                  pkey,
                  val: val2
                });
              }
            }
          }
          if (!isDisabled) {
            for (const key2 in val) {
              const k = shorthands[key2] || key2;
              usedKeys[k] = Math.max(importance, usedKeys[k] || 0);
            }
          }
        }
        continue;
      } else if (isMedia) {
        if (!val)
          continue;
        const isPlatformMedia = key.startsWith("$platform-");
        if (isPlatformMedia) {
          const platform = key.slice(10);
          if (
            // supports web, ios, android
            platform !== currentPlatform && // supports web, native
            platform !== process.env.TAMAGUI_TARGET
          ) {
            continue;
          }
        }
        hasMedia ||= true;
        const mediaStyle = getSubStyle(
          styleState,
          key,
          val,
          // TODO try true like pseudo
          false
        );
        const mediaKeyShort = key.slice(1);
        if (process.env.NODE_ENV === "development" && debug === "verbose") {
          console.log(`  \u{1F4FA} ${key}`, { key, val, mediaStyle, props, shouldDoClasses, componentState });
        }
        const hasSpace = val["space"];
        if (hasSpace || !shouldDoClasses) {
          if (!Array.isArray(hasMedia)) {
            hasMedia = [];
          }
          hasMedia.push(mediaKeyShort);
        }
        if (shouldDoClasses) {
          if (hasSpace) {
            delete mediaStyle["space"];
            if (mediaState[mediaKeyShort]) {
              const importance = getMediaImportanceIfMoreImportant(
                mediaKeyShort,
                "space",
                usedKeys,
                true
              );
              if (importance) {
                space = val["space"];
                usedKeys["space"] = importance;
                if (process.env.NODE_ENV === "development" && debug === "verbose") {
                  console.log(
                    `Found more important space for current media ${mediaKeyShort}: ${val} (importance: ${importance})`
                  );
                }
              }
            }
          }
          const mediaStyles = getStylesAtomic(mediaStyle, debug);
          const priority = mediaStylesSeen;
          mediaStylesSeen += 1;
          for (const style2 of mediaStyles) {
            const out = createMediaStyle(
              style2,
              mediaKeyShort,
              mediaQueryConfig,
              false,
              priority
            );
            const fullKey = `${style2.property}${PROP_SPLIT}${mediaKeyShort}`;
            if (fullKey in usedKeys)
              continue;
            addStyleToInsertRules(rulesToInsert, out);
            mergeClassName(transforms, classNames, fullKey, out.identifier, true, true);
          }
        } else {
          const isThemeMedia = !isPlatformMedia && mediaKeyShort.startsWith("theme-");
          const isGroupMedia = !isPlatformMedia && !isThemeMedia && mediaKeyShort.startsWith("group-");
          if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
            if (!mediaState[mediaKeyShort]) {
              continue;
            }
          }
          let importanceBump = 0;
          if (isThemeMedia) {
            dynamicThemeAccess = true;
            const mediaThemeName = mediaKeyShort.slice(6);
            if (!(themeName === mediaThemeName || themeName.startsWith(mediaThemeName))) {
              continue;
            }
          } else if (isGroupMedia) {
            const groupInfo = getGroupPropParts(mediaKeyShort);
            const groupName = groupInfo.name;
            const groupContext = context == null ? void 0 : context.groups.state[groupName];
            if (!groupContext) {
              if (process.env.NODE_ENV === "development" && debug) {
                console.warn(`No parent with group prop, skipping styles: ${groupName}`);
              }
              continue;
            }
            const groupPseudoKey = groupInfo.pseudo;
            const groupMediaKey = groupInfo.media;
            const componentGroupState = (_c = componentState.group) == null ? void 0 : _c[groupName];
            if (groupMediaKey) {
              mediaGroups ||= /* @__PURE__ */ new Set();
              mediaGroups.add(groupMediaKey);
              const mediaState2 = componentGroupState == null ? void 0 : componentGroupState.media;
              let isActive = mediaState2 == null ? void 0 : mediaState2[groupMediaKey];
              if (!mediaState2 && groupContext.layout) {
                isActive = mediaKeyMatch(groupMediaKey, groupContext.layout);
              }
              if (!isActive)
                continue;
              importanceBump = 2;
            }
            if (groupPseudoKey) {
              pseudoGroups ||= /* @__PURE__ */ new Set();
              pseudoGroups.add(groupName);
              const componentGroupPseudoState = (componentGroupState || // fallback to context initially
              context.groups.state[groupName]).pseudo;
              const isActive = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey];
              if (!isActive)
                continue;
              const priority = pseudoPriorities[groupPseudoKey];
              importanceBump = priority;
            }
          }
          for (const subKey in mediaStyle) {
            if (subKey === "space") {
              space = valInit.space;
              continue;
            }
            mergeMediaByImportance(
              style,
              mediaKeyShort,
              subKey,
              mediaStyle[subKey],
              usedKeys,
              mediaState[mediaKeyShort],
              importanceBump
            );
            if (key === fontFamilyKey) {
              styleState.fontFamily = mediaStyle.fontFamily;
            }
          }
        }
        continue;
      }
      if (process.env.TAMAGUI_TARGET === "native") {
        if (key === "pointerEvents") {
          viewProps[key] = val;
          continue;
        }
      }
      if (
        // is HOC we can just pass through the styles as props
        // this fixes issues where style prop got merged with wrong priority
        !isHOC && (key in validStyleProps || process.env.TAMAGUI_TARGET === "native" && isAndroid && key === "elevation")
      ) {
        mergeStyle(styleState, key, val);
        continue;
      }
      if (!isVariant) {
        viewProps[key] = val;
      }
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      console.groupCollapsed(` \u2714\uFE0F expand complete`, keyInit);
      try {
        console.log("style", { ...style });
        console.log("viewProps", { ...viewProps });
      } catch {
      }
      console.groupEnd();
    }
  }
  if (props.style) {
    mergeStyleProp(styleState, props.style);
  }
  fixStyles(style);
  if (isWeb && !staticConfig.isReactNative) {
    styleToCSS(style);
  }
  if (styleState.transforms) {
    Object.entries(styleState.transforms).sort(([a], [b]) => a.localeCompare(b)).forEach(([key, val]) => {
      mergeTransform(style, key, val, true);
    });
  }
  if (parentSplitStyles) {
    if (process.env.TAMAGUI_TARGET === "web") {
      if (shouldDoClasses) {
        for (const key in parentSplitStyles.classNames) {
          const val = parentSplitStyles.classNames[key];
          if (key in style || key in classNames)
            continue;
          classNames[key] = val;
        }
      }
    }
    if (!shouldDoClasses) {
      for (const key in parentSplitStyles.style) {
        if (key in classNames || key in style)
          continue;
        style[key] = parentSplitStyles.style[key];
      }
    }
  }
  if (process.env.TAMAGUI_TARGET === "web") {
    if (shouldDoClasses) {
      let retainedStyles;
      let shouldRetain = false;
      if (style["$$css"]) {
      } else {
        const atomic = getStylesAtomic(style);
        for (const atomicStyle of atomic) {
          const key = atomicStyle.property;
          const isAnimatedAndAnimateOnly = styleProps.isAnimated && styleProps.noClassNames && (!props.animateOnly || props.animateOnly.includes(key));
          const nonAnimatedAnimateOnly = !isAnimatedAndAnimateOnly && !styleProps.isAnimated && ((_d = props.animateOnly) == null ? void 0 : _d.includes(key));
          if (isAnimatedAndAnimateOnly) {
            retainedStyles ||= {};
            retainedStyles[key] = style[key];
          } else if (nonAnimatedAnimateOnly) {
            retainedStyles ||= {};
            retainedStyles[key] = atomicStyle.value;
            shouldRetain = true;
          } else {
            addStyleToInsertRules(rulesToInsert, atomicStyle);
            mergeClassName(
              transforms,
              classNames,
              key,
              atomicStyle.identifier,
              false,
              true
            );
          }
        }
        if (shouldRetain || !IS_STATIC && !styleProps.keepStyleSSR) {
          style = retainedStyles || {};
        }
      }
    }
    if (transforms) {
      for (const namespace in transforms) {
        if (!transforms[namespace]) {
          if (process.env.NODE_ENV === "development") {
            console.warn("Error no transform", transforms, namespace);
          }
          continue;
        }
        const [hash, val] = transforms[namespace];
        const identifier = `_transform${hash}`;
        if (isClient && !insertedTransforms[identifier]) {
          const rule = `.${identifier} { transform: ${val}; }`;
          addStyleToInsertRules(rulesToInsert, {
            identifier,
            rules: [rule],
            property: namespace
          });
        }
        classNames[namespace] = identifier;
      }
    }
    if (isWeb && !isReactNative) {
      if (viewProps.tabIndex == null) {
        const isFocusable = viewProps.focusable ?? viewProps.accessible;
        if (viewProps.focusable) {
          delete viewProps.focusable;
        }
        const role = viewProps.role;
        if (isFocusable === false) {
          viewProps.tabIndex = "-1";
        }
        if (
          // These native elements are focusable by default
          elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea"
        ) {
          if (isFocusable === false || props.accessibilityDisabled === true) {
            viewProps.tabIndex = "-1";
          }
        } else if (
          // These roles are made focusable by default
          role === "button" || role === "checkbox" || role === "link" || role === "radio" || // @ts-expect-error (consistent with RNW)
          role === "textbox" || role === "switch"
        ) {
          if (isFocusable !== false) {
            viewProps.tabIndex = "0";
          }
        }
        if (isFocusable) {
          viewProps.tabIndex = "0";
          delete viewProps.focusable;
        }
      }
    }
  }
  const result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    // @ts-expect-error
    style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  };
  if (process.env.TAMAGUI_TARGET === "native") {
    if (style.fontFamily) {
      const faceInfo = (_e = getFont(style.fontFamily)) == null ? void 0 : _e.face;
      if (faceInfo) {
        const overrideFace = (_g = (_f = faceInfo[style.fontWeight]) == null ? void 0 : _f[style.fontStyle || "normal"]) == null ? void 0 : _g.val;
        if (overrideFace) {
          style.fontFamily = overrideFace;
          styleState.fontFamily = overrideFace;
          delete style.fontWeight;
          delete style.fontStyle;
        }
      }
      if (process.env.NODE_ENV === "development" && debug && debug !== "profile") {
        console.log(`Found fontFamily native: ${style.fontFamily}`, faceInfo);
      }
    }
  }
  if (className) {
    classNames.className = className;
  }
  if (process.env.NODE_ENV === "development" && debug === "verbose") {
    if (isDevTools) {
      console.groupCollapsed("  \u{1F539} ===>");
      try {
        const logs = {
          ...result,
          componentState,
          transforms,
          viewProps,
          viewPropsOrder: Object.keys(viewProps),
          rulesToInsert,
          parentSplitStyles
        };
        for (const key in logs) {
          console.log(key, logs[key]);
        }
      } catch {
      }
      console.groupEnd();
    }
  }
  return result;
};
function mergeClassName(transforms, classNames, key, val, isMediaOrPseudo = false, isInsertingNow = false) {
  if (process.env.TAMAGUI_TARGET === "web") {
    if (!val)
      return;
    if (!isInsertingNow && val[0] === "_" && val.startsWith("_transform-")) {
      const ns = isMediaOrPseudo ? key : "transform";
      let transform = insertedTransforms[val];
      if (isClient && !transform) {
        scanAllSheets();
        transform = insertedTransforms[val];
        if (!transform && isWeb && val[0] !== "_") {
          transform = val;
        }
      }
      transforms[ns] ||= ["", ""];
      transforms[ns][0] += val.replace("_transform", "");
      if (transform) {
        transforms[ns][1] += transform;
      }
    } else {
      classNames[key] = val;
    }
  }
}
function mergeStyle(styleState, key, val) {
  const { classNames, viewProps, style, usedKeys } = styleState;
  if (isWeb && (val == null ? void 0 : val[0]) === "_") {
    classNames[key] = val;
    usedKeys[key] ||= 1;
  } else if (key in stylePropsTransform) {
    styleState.transforms ||= {};
    styleState.transforms[key] = val;
  } else {
    const out = isWeb ? normalizeValueWithProperty(val, key) : val;
    if (key in validStylesOnBaseProps) {
      viewProps[key] = out;
    } else {
      style[key] = out;
    }
  }
}
const getSubStyle = (styleState, subKey, styleIn, avoidMergeTransform) => {
  const { staticConfig, props, conf: conf2 } = styleState;
  const styleOut = {};
  for (let key in styleIn) {
    const val = styleIn[key];
    key = conf2.shorthands[key] || key;
    const expanded = propMapper(key, val, styleState, { ...props, ...props[subKey] });
    if (!expanded || !staticConfig.isHOC && key in skipProps) {
      continue;
    }
    for (const [skey, sval] of expanded) {
      if (!avoidMergeTransform && skey in stylePropsTransform) {
        mergeTransform(styleOut, skey, sval);
      } else {
        styleOut[skey] = normalizeValueWithProperty(sval, key);
      }
    }
  }
  fixStyles(styleOut);
  return styleOut;
};
function mergeStyleProp(styleState, val) {
  if (!val)
    return;
  const styles = [].concat(val).flat();
  for (const cur of styles) {
    if (!cur)
      continue;
    const isRNW = cur["$$css"];
    if (isRNW) {
      Object.assign(styleState.classNames, cur);
    } else {
      for (const key in cur) {
        if (key in styleState.usedKeys) {
          continue;
        }
        mergeStyle(styleState, key, cur[key]);
      }
    }
  }
}
const useInsertEffectCompat = isWeb ? useInsertionEffect || useIsomorphicLayoutEffect : () => {
};
const useSplitStyles = (...args) => {
  const res = getSplitStyles(...args);
  useInsertEffectCompat(() => {
    insertStyleRules(res.rulesToInsert);
  }, [res.rulesToInsert]);
  return res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  if (process.env.TAMAGUI_TARGET === "web") {
    if (!shouldInsertStyleRules(styleObject.identifier)) {
      return;
    }
    updateRules(styleObject.identifier, styleObject.rules);
    rulesToInsert.push(styleObject);
  }
}
function processIDRefList(idRefList) {
  return Array.isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
const animatableDefaults = {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0
};
const lowercaseHyphenate = (match) => `-${match.toLowerCase()}`;
const hyphenate = (str) => str.replace(/[A-Z]/g, lowercaseHyphenate);
const mergeTransform = (obj, key, val, backwards = false) => {
  if (typeof obj.transform === "string") {
    return;
  }
  obj.transform ||= [];
  obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  });
};
const mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
const skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1
};
if (process.env.NODE_ENV === "test") {
  skipProps["data-test-renders"] = 1;
}
if (process.env.TAMAGUI_TARGET === "native") {
  Object.assign(skipProps, {
    whiteSpace: 1,
    wordWrap: 1,
    textOverflow: 1,
    textDecorationDistance: 1,
    cursor: 1,
    contain: 1,
    boxSizing: 1,
    boxShadow: 1,
    outlineStyle: 1,
    outlineOffset: 1,
    outlineWidth: 1,
    outlineColor: 1
  });
} else {
  Object.assign(skipProps, {
    elevationAndroid: 1,
    allowFontScaling: true,
    adjustsFontSizeToFit: true
  });
}
const accessibilityRoleToWebRole = {
  adjustable: "slider",
  header: "heading",
  image: "img",
  link: "link",
  none: "presentation",
  summary: "region"
};
function passDownProp(viewProps, key, val, shouldMergeObject = false) {
  if (shouldMergeObject) {
    const next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key];
    viewProps[key] = next;
  } else {
    viewProps[key] = val;
  }
}
export {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
};
//# sourceMappingURL=getSplitStyles.js.map
