import { useIsomorphicLayoutEffect } from "@tamagui/constants";
import { useMemo, useRef, useSyncExternalStore } from "react";
import { getConfig } from "../config";
import { createProxy } from "../helpers/createProxy";
import { matchMedia } from "../helpers/matchMedia";
import { pseudoDescriptors } from "../helpers/pseudoDescriptors";
let mediaState = (
  // development only safeguard
  process.env.NODE_ENV === "development" ? createProxy(
    {},
    {
      get(target, key) {
        if (typeof key === "string" && key[0] === "$" && // dont error on $$typeof
        key[1] !== "$") {
          throw new Error(`Access mediaState should not use "$": ${key}`);
        }
        return Reflect.get(target, key);
      }
    }
  ) : {}
);
const mediaQueryConfig = {};
const getMedia = () => mediaState;
const mediaKeys = /* @__PURE__ */ new Set();
const isMediaKey = (key) => mediaKeys.has(key) || key[0] === "$" && (key.startsWith("$platform-") || key.startsWith("$theme-") || key.startsWith("$group-"));
let initState;
const getInitialMediaState = () => {
  return (getConfig().disableSSR ? mediaState : initState) || {};
};
const defaultMediaImportance = Object.keys(pseudoDescriptors).length;
let mediaKeysOrdered;
const getMediaKeyImportance = (key) => {
  if (process.env.NODE_ENV === "development" && key[0] === "$") {
    throw new Error("use short key");
  }
  const conf = getConfig();
  if (conf.settings.mediaPropOrder) {
    return defaultMediaImportance;
  }
  return mediaKeysOrdered.indexOf(key) + 100;
};
const dispose = /* @__PURE__ */ new Set();
const configureMedia = (config) => {
  const { media, mediaQueryDefaultActive } = config;
  if (!media)
    return;
  for (const key in media) {
    mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false;
    mediaKeys.add(`$${key}`);
  }
  Object.assign(mediaQueryConfig, media);
  initState = { ...mediaState };
  updateCurrentState();
  mediaKeysOrdered = Object.keys(media);
  if (config.disableSSR) {
    setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach((cb) => cb());
  dispose.clear();
}
let configuredKey = "";
function setupMediaListeners() {
  const nextKey = JSON.stringify(mediaQueryConfig);
  if (nextKey === configuredKey)
    return;
  configuredKey = nextKey;
  unlisten();
  for (const key in mediaQueryConfig) {
    let update2 = function() {
      const next = !!getMatch().matches;
      if (next === mediaState[key])
        return;
      mediaState = { ...mediaState, [key]: next };
      updateCurrentState();
    };
    var update = update2;
    const str = mediaObjectToString(mediaQueryConfig[key], key);
    const getMatch = () => matchMedia(str);
    const match = getMatch();
    if (!match) {
      throw new Error("\u26A0\uFE0F No match");
    }
    match.addListener(update2);
    dispose.add(() => {
      match.removeListener(update2);
    });
    update2();
  }
}
function useMediaListeners(config) {
  if (config.disableSSR)
    return;
  useIsomorphicLayoutEffect(() => {
    setupMediaListeners();
  }, []);
}
const listeners = /* @__PURE__ */ new Set();
let flushing = false;
function updateCurrentState() {
  if (flushing)
    return;
  flushing = true;
  Promise.resolve().then(() => {
    flushing = false;
    listeners.forEach((cb) => cb(mediaState));
  });
}
const shouldUpdate = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, props) {
  return shouldUpdate.set(ref, props);
}
function subscribe(subscriber) {
  listeners.add(subscriber);
  return () => listeners.delete(subscriber);
}
function useMedia(uid) {
  const internal = useRef();
  const state = useSyncExternalStore(
    subscribe,
    () => {
      if (!internal.current) {
        return initState;
      }
      const { touched, prev } = internal.current;
      const componentState = uid ? shouldUpdate.get(uid) : void 0;
      if (componentState && componentState.enabled === false) {
        return prev;
      }
      const testKeys = (componentState == null ? void 0 : componentState.keys) ?? ((!componentState || componentState.enabled) && touched ? [...touched] : null);
      const hasntUpdated = !testKeys || (testKeys == null ? void 0 : testKeys.every((key) => mediaState[key] === prev[key]));
      if (hasntUpdated) {
        return prev;
      }
      internal.current.prev = mediaState;
      return mediaState;
    },
    () => initState
  );
  return new Proxy(state, {
    get(_, key) {
      if (typeof key === "string") {
        internal.current ||= { prev: initState };
        internal.current.touched ||= /* @__PURE__ */ new Set();
        internal.current.touched.add(key);
      }
      return Reflect.get(state, key);
    }
  });
}
function useMediaPropsActive(props, opts) {
  const media = useMedia();
  const shouldExpandShorthands = opts == null ? void 0 : opts.expandShorthands;
  return useMemo(() => {
    const config = getConfig();
    const next = {};
    const importancesUsed = {};
    const propNames = Object.keys(props);
    const len = propNames.length;
    for (let i = 0; i < len; i++) {
      let key = propNames[i];
      const val = props[key];
      if (key[0] === "$") {
        const mediaKey = key.slice(1);
        if (!media[mediaKey])
          continue;
        if (val && typeof val === "object") {
          const subKeys = Object.keys(val);
          for (let j = subKeys.length; j--; j >= 0) {
            let subKey = subKeys[j];
            const value = val[subKey];
            if (shouldExpandShorthands) {
              subKey = config.shorthands[subKey] || subKey;
            }
            mergeMediaByImportance(next, mediaKey, subKey, value, importancesUsed, true);
          }
        }
      } else {
        if (shouldExpandShorthands) {
          key = config.shorthands[key] || key;
        }
        mergeMediaByImportance(next, "", key, val, importancesUsed, true);
      }
    }
    return next;
  }, [media, props]);
}
const getMediaImportanceIfMoreImportant = (mediaKey, key, importancesUsed, isSizeMedia) => {
  const conf = getConfig();
  const importance = isSizeMedia && !conf.settings.mediaPropOrder ? getMediaKeyImportance(mediaKey) : defaultMediaImportance;
  return !importancesUsed[key] || importance > importancesUsed[key] ? importance : null;
};
function mergeMediaByImportance(onto, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump) {
  let importance = getMediaImportanceIfMoreImportant(
    mediaKey,
    key,
    importancesUsed,
    isSizeMedia
  );
  if (importanceBump) {
    importance = (importance || 0) + importanceBump;
  }
  if (importance === null) {
    return false;
  }
  importancesUsed[key] = importance;
  onto[key] = value;
  return true;
}
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).toLowerCase();
}
const cache = /* @__PURE__ */ new WeakMap();
const cachedMediaKeyToQuery = {};
function mediaObjectToString(query, key) {
  if (typeof query === "string") {
    return query;
  }
  if (cache.has(query)) {
    return cache.get(query);
  }
  const res = Object.entries(query).map(([feature, value]) => {
    feature = camelToHyphen(feature);
    if (typeof value === "string") {
      return `(${feature}: ${value})`;
    }
    if (typeof value === "number" && /[height|width]$/.test(feature)) {
      value = `${value}px`;
    }
    return `(${feature}: ${value})`;
  }).join(" and ");
  if (key) {
    cachedMediaKeyToQuery[key] = res;
  }
  cache.set(query, res);
  return res;
}
function mediaKeyToQuery(key) {
  return cachedMediaKeyToQuery[key] || mediaObjectToString(mediaQueryConfig[key], key);
}
function mediaKeyMatch(key, dimensions) {
  const mediaQueries = mediaQueryConfig[key];
  const result = Object.keys(mediaQueries).every((query) => {
    const expectedVal = +mediaQueries[query];
    const isMax = query.startsWith("max");
    const isWidth = query.endsWith("Width");
    const givenVal = dimensions[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
  return result;
}
export {
  configureMedia,
  getInitialMediaState,
  getMedia,
  getMediaImportanceIfMoreImportant,
  getMediaKeyImportance,
  isMediaKey,
  mediaKeyMatch,
  mediaKeyToQuery,
  mediaKeys,
  mediaObjectToString,
  mediaQueryConfig,
  mediaState,
  mergeMediaByImportance,
  setMediaShouldUpdate,
  setupMediaListeners,
  useMedia,
  useMediaListeners,
  useMediaPropsActive
};
//# sourceMappingURL=useMedia.js.map
