import { isClient, isServer, isWeb } from "@tamagui/constants";
import { useContext, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { getConfig } from "../config";
import { getVariable } from "../createVariable";
import { createProxy } from "../helpers/createProxy";
import {
  ThemeManager,
  getHasThemeUpdatingProps
} from "../helpers/ThemeManager";
import { ThemeManagerContext } from "../helpers/ThemeManagerContext";
import { GetThemeUnwrapped } from "./getThemeUnwrapped";
const emptyProps = { name: null };
let cached;
function getDefaultThemeProxied() {
  if (cached)
    return cached;
  const config = getConfig();
  const defaultTheme = config.themes.light ?? config.themes[Object.keys(config.themes)[0]];
  cached = getThemeProxied(defaultTheme);
  return cached;
}
const useTheme = (props = emptyProps) => {
  const [_, theme] = useThemeWithState(props);
  const res = theme || getDefaultThemeProxied();
  return res;
};
const useThemeWithState = (props) => {
  const keys = useRef([]);
  const changedThemeState = useChangeThemeEffect(
    props,
    false,
    keys.current,
    !isServer ? () => {
      var _a, _b;
      const next = ((_a = props.shouldUpdate) == null ? void 0 : _a.call(props)) ?? (keys.current.length > 0 ? true : void 0);
      if (process.env.NODE_ENV === "development" && props.debug && props.debug !== "profile") {
        console.log(`  \u{1F3A8} useTheme() shouldUpdate?`, next, {
          shouldUpdateProp: (_b = props.shouldUpdate) == null ? void 0 : _b.call(props),
          keys: [...keys.current]
        });
      }
      return next;
    } : void 0
  );
  const { themeManager, state } = changedThemeState;
  const { theme, name, className } = state;
  if (!theme) {
    if (process.env.NODE_ENV === "development") {
      throw new Error(
        `No theme found given props ${JSON.stringify(
          props
        )}. Themes given to tamagui are: ${Object.keys(getConfig().themes)}`
      );
    }
    throw `\u274C 1`;
  }
  const themeProxied = useMemo(() => {
    return getThemeProxied(theme, themeManager, keys.current, props.debug);
  }, [theme, name, className, themeManager]);
  if (process.env.NODE_ENV === "development" && props.debug === "verbose") {
    console.groupCollapsed("  \u{1F539} useTheme =>", name);
    console.log("returning state", changedThemeState, "from props", props);
    console.groupEnd();
  }
  return [changedThemeState, themeProxied];
};
function getThemeProxied(theme, themeManager, keys, debug) {
  return createProxy(theme, {
    has(_, key) {
      if (Reflect.has(theme, key)) {
        return true;
      }
      if (typeof key === "string") {
        if (key[0] === "$")
          key = key.slice(1);
        return themeManager == null ? void 0 : themeManager.allKeys.has(key);
      }
    },
    get(_, key) {
      if (key === GetThemeUnwrapped) {
        return theme;
      }
      if (
        // dont ask me, idk why but on hermes you can see that useTheme()[undefined] passes in STRING undefined to proxy
        // if someone is crazy enough to use "undefined" as a theme key then this not working is on them
        key !== "undefined" && typeof key === "string"
      ) {
        const keyString = key[0] === "$" ? key.slice(1) : key;
        const val = theme[keyString];
        if (val && typeof val === "object") {
          return new Proxy(val, {
            // when they touch the actual value we only track it
            // if its a variable (web), its ignored!
            get(_2, subkey) {
              if (keys) {
                if ((subkey === "val" || subkey === "get" && !isWeb) && !keys.includes(keyString)) {
                  keys.push(keyString);
                  if (process.env.NODE_ENV === "development" && debug) {
                    console.log(` \u{1F3A8} useTheme() tracking new key: ${keyString}`);
                  }
                }
              }
              if (subkey === "get") {
                return () => getVariable(val);
              }
              return Reflect.get(val, subkey);
            }
          });
        }
      }
      return Reflect.get(_, key);
    }
  });
}
const activeThemeManagers = /* @__PURE__ */ new Set();
const useChangeThemeEffect = (props, root = false, keys, shouldUpdate) => {
  const {
    // @ts-expect-error internal use only
    disable
  } = props;
  const parentManager = useContext(ThemeManagerContext);
  if (disable) {
    if (!parentManager)
      throw `\u274C 2`;
    return {
      isNewTheme: false,
      state: parentManager.state,
      themeManager: parentManager
    };
  }
  const [themeState, setThemeState] = useState(createState);
  const { state, mounted, isNewTheme, themeManager } = themeState;
  const isInversingOnMount = Boolean(!themeState.mounted && props.inverse);
  function getShouldUpdateTheme(manager = themeManager, nextState, prevState = state, forceShouldChange = false) {
    const forceUpdate = shouldUpdate == null ? void 0 : shouldUpdate();
    if (!forceShouldChange && forceUpdate === false)
      return;
    const next = nextState || manager.getState(props, parentManager);
    if (forceShouldChange)
      return next;
    if (!next)
      return;
    if (forceUpdate !== true && !manager.getStateShouldChange(next, prevState)) {
      return;
    }
    return next;
  }
  if (!isServer) {
    useLayoutEffect(() => {
      if (props.inverse && !mounted) {
        setThemeState({ ...themeState, mounted: true });
        return;
      }
      if (isNewTheme && themeManager) {
        activeThemeManagers.add(themeManager);
      }
      if (isNewTheme || getShouldUpdateTheme(themeManager)) {
        setThemeState(createState);
      }
      const selfListenerDispose = themeManager.onChangeTheme((_a, _b, forced) => {
        if (forced) {
          setThemeState((prev) => createState(prev, true));
        }
      });
      const disposeChangeListener = parentManager == null ? void 0 : parentManager.onChangeTheme((name, manager) => {
        const force = shouldUpdate == null ? void 0 : shouldUpdate();
        const doUpdate = force ?? Boolean((keys == null ? void 0 : keys.length) || isNewTheme);
        if (process.env.NODE_ENV === "development" && props.debug) {
          console.log(` \u{1F538} onChange`, themeManager.id, {
            force,
            doUpdate,
            props,
            name,
            manager,
            keys
          });
        }
        if (doUpdate) {
          setThemeState(createState);
        }
      }, themeManager.id);
      return () => {
        selfListenerDispose();
        disposeChangeListener == null ? void 0 : disposeChangeListener();
        activeThemeManagers.delete(themeManager);
      };
    }, [
      themeManager,
      parentManager,
      isNewTheme,
      props.componentName,
      props.inverse,
      props.name,
      props.reset,
      mounted
    ]);
    if (process.env.NODE_ENV === "development" && props.debug !== "profile") {
      useEffect(() => {
        globalThis["TamaguiThemeManagers"] ??= /* @__PURE__ */ new Set();
        globalThis["TamaguiThemeManagers"].add(themeManager);
        return () => {
          globalThis["TamaguiThemeManagers"].delete(themeManager);
        };
      }, [themeManager]);
    }
  }
  if (isInversingOnMount) {
    if (!parentManager)
      throw "\u274C 3";
    return {
      isNewTheme: false,
      themeManager: parentManager,
      state: {
        ...parentManager.state,
        className: ""
      }
    };
  }
  return {
    state,
    isNewTheme,
    themeManager
  };
  function createState(prev, force = false) {
    if (prev && (shouldUpdate == null ? void 0 : shouldUpdate()) === false) {
      return prev;
    }
    let themeManager2 = parentManager;
    let state2;
    const hasThemeUpdatingProps = getHasThemeUpdatingProps(props);
    if (hasThemeUpdatingProps) {
      const getNewThemeManager = () => {
        return new ThemeManager(props, root ? "root" : parentManager);
      };
      if (prev == null ? void 0 : prev.themeManager) {
        themeManager2 = prev.themeManager;
        const forceChange = Boolean(keys == null ? void 0 : keys.length);
        const next = themeManager2.getState(props, parentManager);
        const nextState = getShouldUpdateTheme(
          themeManager2,
          next,
          prev.state,
          forceChange
        );
        if (nextState) {
          state2 = nextState;
          if (!prev.isNewTheme || !isWeb) {
            themeManager2 = getNewThemeManager();
          } else {
            themeManager2.updateState(nextState);
          }
        } else {
          if (prev.isNewTheme) {
            if (parentManager && !next) {
              themeManager2 = parentManager;
            }
          }
        }
      } else {
        themeManager2 = getNewThemeManager();
        state2 = { ...themeManager2.state };
      }
    }
    const isNewTheme2 = Boolean(themeManager2 !== parentManager || props.inverse);
    const mounted2 = !props.inverse ? true : root || (prev == null ? void 0 : prev.mounted);
    if (!state2) {
      if (isNewTheme2) {
        state2 = themeManager2.state;
      } else {
        state2 = parentManager.state;
        themeManager2 = parentManager;
      }
    }
    if (!force && state2.name === (prev == null ? void 0 : prev.state.name)) {
      return prev;
    }
    const response = {
      state: state2,
      themeManager: themeManager2,
      isNewTheme: isNewTheme2,
      mounted: mounted2
    };
    if (process.env.NODE_ENV === "development" && props["debug"] && isClient) {
      console.groupCollapsed(` \u{1F537} ${themeManager2.id} useChangeThemeEffect createState`);
      const parentState = { ...parentManager == null ? void 0 : parentManager.state };
      const parentId = parentManager == null ? void 0 : parentManager.id;
      const themeManagerState = { ...themeManager2.state };
      console.log({
        props,
        parentState,
        parentId,
        themeManager: themeManager2,
        prev,
        response,
        themeManagerState
      });
      console.groupEnd();
    }
    return response;
  }
};
export {
  activeThemeManagers,
  getThemeProxied,
  useChangeThemeEffect,
  useTheme,
  useThemeWithState
};
//# sourceMappingURL=useTheme.js.map
