import { isWeb } from "@tamagui/constants";
import { configListeners, setConfig, setTokens } from "./config";
import { createVariables } from "./createVariables";
import { getThemeCSSRules } from "./helpers/getThemeCSSRules";
import {
  getAllRules,
  listenForSheetChanges,
  scanAllSheets
} from "./helpers/insertStyleRule";
import { proxyThemesToParents } from "./helpers/proxyThemeToParents";
import { registerCSSVariable, variableToCSS } from "./helpers/registerCSSVariable";
import { ensureThemeVariable } from "./helpers/themes";
import { configureMedia } from "./hooks/useMedia";
import { parseFont, registerFontVariables } from "./insertFont";
import { Tamagui } from "./Tamagui";
const createdConfigs = /* @__PURE__ */ new WeakMap();
function createTamagui(configIn) {
  var _a;
  if (createdConfigs.has(configIn)) {
    return configIn;
  }
  if (process.env.NODE_ENV === "development") {
    if (!configIn.tokens) {
      throw new Error("Must define tokens");
    }
    if (!configIn.themes) {
      throw new Error("Must define themes");
    }
    if (!configIn.fonts) {
      throw new Error("Must define fonts");
    }
  }
  const tokens = createVariables(configIn.tokens);
  const tokensParsed = {};
  const tokensMerged = {};
  for (const cat in tokens) {
    tokensParsed[cat] = {};
    tokensMerged[cat] = {};
    const tokenCat = tokens[cat];
    for (const key in tokenCat) {
      const val = tokenCat[key];
      const prefixedKey = `$${key}`;
      tokensParsed[cat][prefixedKey] = val;
      tokensMerged[cat][prefixedKey] = val;
      tokensMerged[cat][key] = val;
    }
  }
  setTokens(tokensMerged);
  const noThemes = Object.keys(configIn.themes).length === 0;
  const foundThemes = scanAllSheets(noThemes, tokensParsed);
  listenForSheetChanges();
  const fontTokens = Object.fromEntries(
    Object.entries(configIn.fonts).map(([k, v]) => {
      return [k, createVariables(v, "f", true)];
    })
  );
  let fontSizeTokens = null;
  const fontsParsed = (() => {
    const res = {};
    for (const familyName in fontTokens) {
      const font = fontTokens[familyName];
      const fontParsed = parseFont(font);
      res[`$${familyName}`] = fontParsed;
      if (!fontSizeTokens && fontParsed.size) {
        fontSizeTokens = new Set(Object.keys(fontParsed.size));
      }
    }
    return res;
  })();
  const specificTokens = {};
  const themeConfig = (() => {
    const cssRuleSets = [];
    if (process.env.TAMAGUI_DOES_SSR_CSS !== "true" && // we can leave this out if mutating, only need the js for getThemeCSSRules
    process.env.TAMAGUI_DOES_SSR_CSS !== "mutates-themes") {
      const declarations = [];
      const fontDeclarations = {};
      for (const key in tokens) {
        for (const skey in tokens[key]) {
          const variable = tokens[key][skey];
          specificTokens[`$${key}.${skey}`] = variable;
          if (process.env.NODE_ENV === "development") {
            if (typeof variable === "undefined") {
              throw new Error(
                `No value for tokens.${key}.${skey}:
${JSON.stringify(
                  variable,
                  null,
                  2
                )}`
              );
            }
          }
          if (isWeb) {
            registerCSSVariable(variable);
            declarations.push(variableToCSS(variable, key === "zIndex"));
          }
        }
      }
      if (isWeb) {
        let declarationsToRuleSet2 = function(decs, selector = "") {
          return `:root${selector} {${sep}${[...decs].join(`;${sep}`)}${sep}}`;
        };
        var declarationsToRuleSet = declarationsToRuleSet2;
        for (const key in fontsParsed) {
          const fontParsed = fontsParsed[key];
          const [name, language] = key.includes("_") ? key.split("_") : [key];
          const fontVars = registerFontVariables(fontParsed);
          fontDeclarations[key] = {
            name: name.slice(1),
            declarations: fontVars,
            language
          };
        }
        const sep = process.env.NODE_ENV === "development" ? configIn.cssStyleSeparator || " " : "";
        cssRuleSets.push(declarationsToRuleSet2(declarations));
        if (fontDeclarations) {
          for (const key in fontDeclarations) {
            const { name, declarations: declarations2, language = "default" } = fontDeclarations[key];
            const fontSelector = `.font_${name}`;
            const langSelector = `:root .t_lang-${name}-${language} ${fontSelector}`;
            const selectors = language === "default" ? ` ${fontSelector}, ${langSelector}` : langSelector;
            const specificRuleSet = declarationsToRuleSet2(declarations2, selectors);
            cssRuleSets.push(specificRuleSet);
          }
        }
      }
    }
    const themesIn = { ...configIn.themes };
    const dedupedThemes = foundThemes ?? getThemesDeduped(themesIn);
    const themes = proxyThemesToParents(dedupedThemes);
    return {
      themes,
      cssRuleSets,
      getThemeRulesSets() {
        let themeRuleSets = [];
        if (isWeb) {
          for (const { names, theme } of dedupedThemes) {
            const nextRules = getThemeCSSRules({
              config: configIn,
              themeName: names[0],
              names,
              theme
            });
            themeRuleSets = [...themeRuleSets, ...nextRules];
          }
        }
        return themeRuleSets;
      }
    };
  })();
  const shorthands = configIn.shorthands || {};
  let lastCSSInsertedRulesIndex = -1;
  const getCSS = ({ separator = "\n", sinceLastCall, exclude } = {}) => {
    if (sinceLastCall && lastCSSInsertedRulesIndex >= 0) {
      const rules = getAllRules();
      lastCSSInsertedRulesIndex = rules.length;
      return rules.slice(lastCSSInsertedRulesIndex).join(separator);
    }
    lastCSSInsertedRulesIndex = 0;
    const runtimeStyles = getAllRules().join(separator);
    if (exclude === "design-system") {
      return runtimeStyles;
    }
    const designSystem = `._ovs-contain {overscroll-behavior:contain;}
.is_Text .is_Text {display:inline-flex;}
._dsp_contents {display:contents;}
${themeConfig.cssRuleSets.join(separator)}`;
    return `${designSystem}
${exclude ? "" : themeConfig.getThemeRulesSets().join(separator)}
${runtimeStyles}`;
  };
  const getNewCSS = (opts) => getCSS({ ...opts, sinceLastCall: true });
  const defaultFontName = configIn.defaultFont || // uses font named "body" if present for compat
  ("body" in configIn.fonts ? "body" : 0) || // defaults to the first font to make life easier
  Object.keys(configIn.fonts)[0];
  if (process.env.NODE_ENV !== "production") {
    if ((defaultFontName == null ? void 0 : defaultFontName[0]) === "$") {
      throw new Error(`Pass defaultFont without a $ prefix (${configIn.defaultFont})`);
    }
  }
  const defaultFont = `$${defaultFontName}`;
  const config = {
    groupNames: [],
    settings: {},
    onlyAllowShorthands: false,
    fontLanguages: [],
    animations: {},
    media: {},
    ...configIn,
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(([k, v]) => [v, k])) : {},
    themes: themeConfig.themes,
    fontsParsed,
    themeConfig,
    tokensParsed,
    parsed: true,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens
    // const tokens = [...getToken(tokens.size[0])]
    // .spacer-sm + ._dsp_contents._dsp-sm-hidden { margin-left: -var(--${}) }
  };
  configureMedia(config);
  setConfig(config);
  if (configListeners.size) {
    configListeners.forEach((cb) => cb(config));
    configListeners.clear();
  }
  createdConfigs.set(config, true);
  if (process.env.NODE_ENV === "development") {
    if ((_a = process.env.DEBUG) == null ? void 0 : _a.startsWith("tamagui")) {
      console.log("Tamagui config:", config);
    }
    if (!globalThis["Tamagui"]) {
      globalThis["Tamagui"] = Tamagui;
    }
  }
  return config;
}
function getThemesDeduped(themes) {
  const dedupedThemes = [];
  const existing = /* @__PURE__ */ new Map();
  for (const themeName in themes) {
    const darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "";
    const rawTheme = themes[themeName];
    const key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
    if (existing.has(key)) {
      const e = existing.get(key);
      e.names.push(themeName);
      continue;
    }
    const theme = { ...rawTheme };
    for (const key2 in theme) {
      ensureThemeVariable(theme, key2);
    }
    const deduped = {
      names: [themeName],
      theme
    };
    dedupedThemes.push(deduped);
    existing.set(key, deduped);
  }
  return dedupedThemes;
}
export {
  createTamagui
};
//# sourceMappingURL=createTamagui.js.map
