"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var withTamagui_exports = {};
__export(withTamagui_exports, {
  withTamagui: () => withTamagui
});
module.exports = __toCommonJS(withTamagui_exports);
var import_fs = require("fs");
var import_path = __toESM(require("path"));
var import_browserslist = __toESM(require("browserslist"));
var import_esm_resolve = __toESM(require("esm-resolve"));
var import_css = require("next/dist/build/webpack/config/blocks/css");
var import_loaders = require("next/dist/build/webpack/config/blocks/css/loaders");
var import_tamagui_loader = require("tamagui-loader");
var import_webpack = __toESM(require("webpack"));
const withTamagui = (tamaguiOptions) => {
  return (nextConfig = {}) => {
    var _a;
    const isAppDir = (_a = nextConfig.experimental) == null ? void 0 : _a.appDir;
    return {
      ...nextConfig,
      webpack: (webpackConfig, options) => {
        var _a2;
        const { dir, config, dev, isServer } = options;
        const resolver = (0, import_esm_resolve.default)((0, import_path.join)(dir, "index.js"), {
          constraints: "node"
        });
        if (typeof globalThis["__DEV__"] === "undefined") {
          globalThis["__DEV__"] = dev;
        }
        const isNext12 = typeof ((_a2 = options.config) == null ? void 0 : _a2.swcMinify) === "boolean";
        if (!isNext12) {
          throw new Error(`Next.js 12 only supported`);
        }
        const prefix = `${isServer ? " ssr " : " web "} |`;
        const safeResolves = (resolves, multiple = false) => {
          var _a3;
          const res = [];
          for (const [out, mod] of resolves) {
            if (out.endsWith("$")) {
              res.push([out, mod]);
              continue;
            }
            try {
              res.push([out, resolveEsm(mod)]);
              if (multiple) {
                res.push([out, resolveEsm(mod, true)]);
              }
            } catch (err) {
              if (out.includes(`@gorhom/bottom-sheet`)) {
                continue;
              }
              if ((_a3 = process.env.DEBUG) == null ? void 0 : _a3.startsWith("tamagui")) {
                console.log(prefix, `withTamagui skipping resolving ${out}`, err);
              }
            }
          }
          return res;
        };
        const resolveEsm = (relativePath, onlyRequire = false) => {
          if (isServer || onlyRequire) {
            return require.resolve(relativePath);
          }
          const esm = resolver(relativePath);
          return esm ? import_path.default.join(dir, esm) : require.resolve(relativePath);
        };
        const SEP = import_path.default.sep;
        const componentsFullPaths = safeResolves(
          tamaguiOptions.components.map(
            (moduleName) => [moduleName, moduleName]
          ),
          true
        );
        const componentsBaseDirs = componentsFullPaths.map(([_, fullPath]) => {
          let rootPath = (0, import_path.dirname)(fullPath);
          while (rootPath.length > 1) {
            const pkg = (0, import_path.join)(rootPath, "package.json");
            const hasPkg = (0, import_fs.existsSync)(pkg);
            if (hasPkg) {
              return rootPath;
            } else {
              rootPath = (0, import_path.join)(rootPath, "..");
            }
          }
          throw new Error(`Couldn't find package.json in any path above: ${fullPath}`);
        });
        function isInComponentModule(fullPath) {
          return componentsBaseDirs.some(
            (componentDir) => fullPath.startsWith(componentDir)
          );
        }
        const shouldExclude = (path2, projectRoot) => {
          var _a3;
          const res = (_a3 = tamaguiOptions.shouldExtract) == null ? void 0 : _a3.call(tamaguiOptions, path2, projectRoot);
          if (typeof res === "boolean") {
            return !res;
          }
          if (isInComponentModule(path2)) {
            return false;
          }
          return (0, import_tamagui_loader.shouldExclude)(path2, projectRoot);
        };
        const rnw = tamaguiOptions.useReactNativeWebLite ? "react-native-web-lite" : "react-native-web";
        const tamaguiAliases = Object.fromEntries(
          safeResolves([
            ["@tamagui/core/reset.css", "@tamagui/core/reset.css"],
            ["@tamagui/core", "@tamagui/core"],
            ["@tamagui/web", "@tamagui/web"],
            // web specific light react-native-svg, optional, can use svgs but had issues with compat
            ["react-native-svg", "@tamagui/react-native-svg"],
            // fixes https://github.com/kentcdodds/mdx-bundler/issues/143
            ["react/jsx-runtime.js", "react/jsx-runtime"],
            ["react/jsx-runtime", "react/jsx-runtime"],
            ["react/jsx-dev-runtime.js", "react/jsx-dev-runtime"],
            ["react/jsx-dev-runtime", "react/jsx-dev-runtime"],
            ["react-native-reanimated", "react-native-reanimated"],
            ["react-native$", rnw],
            ["react-native-web$", rnw],
            ["@testing-library/react-native", "@tamagui/proxy-worm"],
            ["@gorhom/bottom-sheet$", "@gorhom/bottom-sheet"],
            // fix reanimated 3
            ["react-native/Libraries/Renderer/shims/ReactFabric", "@tamagui/proxy-worm"],
            ...tamaguiOptions.aliasReactPackages ? [
              ["react", "react"],
              ["react-dom", "react-dom"]
            ] : []
          ])
        );
        const alias = {
          ...webpackConfig.resolve.alias || {},
          ...tamaguiAliases
        };
        if (process.env.DEBUG) {
          console.log("Tamagui alias:", alias);
        }
        if (process.env.ANALYZE === "true") {
          Object.assign(webpackConfig.optimization, {
            concatenateModules: false
          });
        }
        webpackConfig.resolve.alias = alias;
        const defines = {
          "process.env.IS_STATIC": JSON.stringify(""),
          "process.env.TAMAGUI_TARGET": '"web"',
          "process.env.TAMAGUI_IS_SERVER": JSON.stringify(isServer ? "true" : ""),
          __DEV__: JSON.stringify(dev),
          ...(tamaguiOptions.outputCSS || process.env.TAMAGUI_DOES_SSR_CSS) && {
            "process.env.TAMAGUI_DOES_SSR_CSS": JSON.stringify(
              process.env.TAMAGUI_DOES_SSR_CSS ?? ((tamaguiOptions == null ? void 0 : tamaguiOptions.doesMutateThemes) === false ? true : "mutates-themes")
            )
          }
        };
        webpackConfig.plugins.push(new import_webpack.default.DefinePlugin(defines));
        const excludeExports = tamaguiOptions.excludeReactNativeWebExports;
        if (Array.isArray(excludeExports)) {
          try {
            const regexStr = `react-native-web(-lite)?/.*(${excludeExports.join(
              "|"
            )}).*js`;
            const regex = new RegExp(regexStr);
            webpackConfig.plugins.push(
              new import_webpack.default.NormalModuleReplacementPlugin(
                regex,
                resolveEsm("@tamagui/proxy-worm")
              )
            );
          } catch (err) {
            console.warn(
              `Invalid names provided to excludeReactNativeWebExports: ${excludeExports.join(
                ", "
              )}`
            );
          }
        }
        if (process.env.IGNORE_TS_CONFIG_PATHS) {
          if (process.env.DEBUG) {
            console.log(prefix, "ignoring tsconfig paths");
          }
          if (webpackConfig.resolve.plugins[0]) {
            delete webpackConfig.resolve.plugins[0].paths["@tamagui/*"];
            delete webpackConfig.resolve.plugins[0].paths["tamagui"];
          }
        }
        if (!isServer) {
          nextConfig.modularizeImports ?? (nextConfig.modularizeImports = {});
          nextConfig.modularizeImports["@tamagui/lucide-icons"] = {
            transform: `@tamagui/lucide-icons/dist/esm/icons/{{kebabCase member}}`,
            skipDefaultConversion: true
          };
        }
        if (isServer) {
          const externalize = (context, request) => {
            const fullPath = request[0] === "." ? import_path.default.join(context, request) : request;
            if (tamaguiOptions.shouldExcludeFromServer) {
              const userRes = tamaguiOptions.shouldExcludeFromServer({
                context,
                request,
                fullPath
              });
              if (userRes !== void 0) {
                return userRes;
              }
            }
            if (isInComponentModule(fullPath)) {
              return false;
            }
            if (fullPath.includes("react-native-web")) {
              return false;
            }
            if (fullPath === "react-native" || fullPath.startsWith(`react-native${SEP}`)) {
              return false;
            }
            if (
              // feather icons uses react-native-svg which needs to be aliased
              // fullPath.includes('/lucide-icons/') ||
              fullPath.startsWith("react-native-web") || fullPath.includes(`node_modules${SEP}react-native-web`) || new RegExp(`^(react-dom|react)${SEP}$`).test(fullPath)
            ) {
              return `commonjs ${fullPath}`;
            }
            if (fullPath.startsWith("moti") || fullPath.startsWith("solito") || fullPath === "tamagui" || fullPath.startsWith("@tamagui") || fullPath === "react-native-safe-area-context" || fullPath === "expo-linear-gradient" || fullPath.startsWith("@react-navigation") || fullPath.startsWith("@gorhom")) {
              return;
            }
            if (/^@?react-native-/.test(request)) {
              return false;
            }
            return true;
          };
          webpackConfig.externals = [
            ...webpackConfig.externals.map((external) => {
              if (typeof external !== "function") {
                return external;
              }
              return (ctx, cb) => {
                const isCb = typeof cb === "function";
                const res = externalize(ctx.context, ctx.request);
                if (isCb) {
                  if (typeof res === "string") {
                    return cb(null, res);
                  }
                  if (res) {
                    return external(ctx, cb);
                  }
                  return cb();
                }
                return !res ? Promise.resolve(void 0) : typeof res === "string" ? Promise.resolve(res) : external(ctx);
              };
            })
          ];
        }
        const cssRules = webpackConfig.module.rules.find(
          (rule) => Array.isArray(rule.oneOf) && rule.oneOf.some(
            ({ test }) => typeof test === "object" && typeof test.test === "function" && test.test("filename.css")
          )
        ).oneOf;
        if (cssRules) {
          if (tamaguiOptions.enableLegacyFontSupport) {
            cssRules.unshift({
              test: /\.(woff(2)?|eot|ttf|otf)(\?v=\d+\.\d+\.\d+)?$/,
              use: [
                {
                  loader: require.resolve("url-loader"),
                  options: {
                    limit: nextConfig.inlineFontLimit || 1024,
                    fallback: require.resolve("file-loader"),
                    publicPath: `${nextConfig.assetPrefix || ""}/_next/static/chunks/fonts/`,
                    outputPath: `${isServer ? "../" : ""}static/chunks/fonts/`,
                    name: "[name].[ext]"
                  }
                }
              ]
            });
          }
          const cssLoader = (0, import_loaders.getGlobalCssLoader)(
            // @ts-ignore
            {
              assetPrefix: nextConfig.assetPrefix || options.config.assetPrefix || config.assetPrefix,
              future: nextConfig.future,
              experimental: nextConfig.experimental || {},
              isEdgeRuntime: true,
              isProduction: !dev,
              targetWeb: true,
              isClient: !isServer,
              isServer,
              isDevelopment: dev
            },
            // @ts-ignore
            () => (0, import_css.lazyPostCSS)(dir, getSupportedBrowsers(dir, dev)),
            []
          );
          if (!isAppDir) {
            cssRules.unshift({
              test: tamaguiOptions.includeCSSTest ?? /\.tamagui\.css$/,
              sideEffects: true,
              use: cssLoader
            });
          }
        }
        const enableStudio = options.dev && options.nextRuntime === "nodejs" && isServer;
        webpackConfig.plugins.push(
          new import_tamagui_loader.TamaguiPlugin({
            enableStudio,
            isServer,
            exclude: (path2) => {
              const res = shouldExclude(path2, options.dir);
              return res;
            },
            ...tamaguiOptions
          })
        );
        if (typeof nextConfig.webpack === "function") {
          return nextConfig.webpack(webpackConfig, options);
        }
        return webpackConfig;
      }
    };
  };
};
function getSupportedBrowsers(dir, isDevelopment) {
  let browsers;
  try {
    browsers = import_browserslist.default.loadConfig({
      path: dir,
      env: isDevelopment ? "development" : "production"
    });
  } catch {
  }
  return browsers;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  withTamagui
});
//# sourceMappingURL=withTamagui.js.map
