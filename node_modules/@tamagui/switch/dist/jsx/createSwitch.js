import { useComposedRefs } from "@tamagui/compose-refs";
import {
  composeEventHandlers,
  createStyledContext,
  getVariableValue,
  isWeb,
  useProps,
  withStaticProperties
} from "@tamagui/core";
import { registerFocusable } from "@tamagui/focusable";
import { getSize } from "@tamagui/get-token";
import { useLabelContext } from "@tamagui/label";
import { useControllableState } from "@tamagui/use-controllable-state";
import { usePrevious } from "@tamagui/use-previous";
import * as React from "react";
import {
  Switch as NativeSwitch,
  Platform
} from "react-native";
const SwitchContext = createStyledContext({
  checked: false,
  disabled: false,
  size: void 0,
  frameWidth: 60,
  unstyled: false
});
function createSwitch({ Frame, Thumb, acceptsUnstyled }) {
  const SwitchThumb = Thumb.styleable(function SwitchThumb2(props, forwardedRef) {
    const { size: sizeProp, ...thumbProps } = props;
    const { disabled, checked, unstyled, frameWidth } = React.useContext(SwitchContext);
    const [thumbWidth, setThumbWidth] = React.useState(0);
    return (
      // @ts-ignore
      <Thumb
        theme={unstyled === false && checked ? "active" : null}
        data-state={getState(checked)}
        data-disabled={disabled ? "" : void 0}
        x={checked ? frameWidth - thumbWidth : 0}
        {...thumbProps}
        onLayout={composeEventHandlers(
          props.onLayout,
          (e) => (
            // @ts-ignore
            setThumbWidth(e.nativeEvent.layout.width)
          )
        )}
        ref={forwardedRef}
      />
    );
  });
  const SwitchComponent = Frame.extractable(
    React.forwardRef(function SwitchFrame(propsIn, forwardedRef) {
      const styledContext = React.useContext(SwitchContext);
      const props = useProps(propsIn);
      const {
        labeledBy: ariaLabelledby,
        name,
        checked: checkedProp,
        defaultChecked,
        required,
        disabled,
        value = "on",
        onCheckedChange,
        size = styledContext.size ?? "$true",
        unstyled = styledContext.unstyled ?? false,
        native: nativeProp,
        nativeProps,
        ...switchProps
      } = props;
      const leftBorderWidth = (() => {
        let _ = void 0;
        for (const key in switchProps) {
          if (key === "borderWidth" || key === "borderLeftWidth") {
            _ = switchProps[key];
          }
        }
        if (acceptsUnstyled && _ === void 0 && unstyled === false) {
          _ = 2;
        }
        if (typeof _ === "string") {
          _ = getVariableValue(getSize(_));
        }
        return +_;
      })();
      const native = Array.isArray(nativeProp) ? nativeProp : [nativeProp];
      const shouldRenderMobileNative = !isWeb && nativeProp === true || !isWeb && native.includes("mobile") || native.includes("android") && Platform.OS === "android" || native.includes("ios") && Platform.OS === "ios";
      const [button, setButton] = React.useState(null);
      const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
      const labelId = useLabelContext(button);
      const labelledBy = ariaLabelledby || labelId;
      const hasConsumerStoppedPropagationRef = React.useRef(false);
      const isFormControl = isWeb ? button ? Boolean(button.closest("form")) : true : false;
      const [frameWidth, setFrameWidth] = React.useState(60);
      const [checked = false, setChecked] = useControllableState({
        prop: checkedProp,
        defaultProp: defaultChecked || false,
        onChange: onCheckedChange,
        transition: true
      });
      if (shouldRenderMobileNative) {
        return <NativeSwitch
          value={checkedProp}
          onValueChange={onCheckedChange}
          {...nativeProps}
        />;
      }
      if (!isWeb) {
        React.useEffect(() => {
          if (!props.id)
            return;
          return registerFocusable(props.id, {
            focus: () => {
              setChecked((x) => !x);
            }
          });
        }, [props.id, setChecked]);
      }
      return <>
        {
          /* @ts-ignore */
        }
        <Frame
          unstyled={unstyled}
          size={size}
          checked={checked}
          disabled={disabled}
          frameWidth={frameWidth - leftBorderWidth * 2}
          theme={checked ? "active" : null}
          themeShallow
          role="switch"
          aria-checked={checked}
          aria-labelledby={labelledBy}
          aria-required={required}
          data-state={getState(checked)}
          data-disabled={disabled ? "" : void 0}
          tabIndex={disabled ? void 0 : 0}
          value={value}
          {...switchProps}
          ref={composedRefs}
          onPress={composeEventHandlers(props.onPress, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isWeb && isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })}
          onLayout={composeEventHandlers(
            props.onLayout,
            (e) => (
              // @ts-ignore
              setFrameWidth(e.nativeEvent.layout.width)
            )
          )}
        />
        {isWeb && isFormControl && <BubbleInput
          control={button}
          bubbles={!hasConsumerStoppedPropagationRef.current}
          name={name}
          value={value}
          checked={checked}
          required={required}
          disabled={disabled}
          style={{ transform: "translateX(-100%)" }}
        />}
      </>;
    })
  );
  const BubbleInput = (props) => {
    const { control, checked, bubbles = true, ...inputProps } = props;
    const ref = React.useRef(null);
    const prevChecked = usePrevious(checked);
    React.useEffect(() => {
      const input = ref.current;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return (
      // @ts-ignore
      <input
        type="checkbox"
        aria-hidden
        defaultChecked={checked}
        {...inputProps}
        tabIndex={-1}
        ref={ref}
        style={{
          ...props.style,
          // ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }}
      />
    );
  };
  function getState(checked) {
    return checked ? "checked" : "unchecked";
  }
  const Switch = withStaticProperties(SwitchComponent, {
    Thumb: SwitchThumb
  });
  return Switch;
}
export {
  SwitchContext,
  createSwitch
};
//# sourceMappingURL=createSwitch.js.map
