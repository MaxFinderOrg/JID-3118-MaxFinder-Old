import Module from "module";
import { join } from "path";
const ogRequire = Module.prototype.require;
async function generateThemes(inputFile) {
  const { unregister } = require("esbuild-register/dist/node").register({
    hookIgnoreNodeModules: false
  });
  const inputFilePath = inputFile[0] === "." ? join(process.cwd(), inputFile) : inputFile;
  purgeCache(inputFilePath);
  let promise = null;
  Module.prototype.require = function(id) {
    const out = ogRequire.apply(this, arguments);
    if (id === "@tamagui/theme-builder") {
      if (!promise) {
        let resolve;
        promise = new Promise((res) => {
          resolve = res;
        });
        return createThemeIntercept(out, {
          onComplete: (result) => {
            resolve == null ? void 0 : resolve(result.themeBuilder);
          }
        });
      }
    }
    return out;
  };
  try {
    const requiredThemes = require(inputFilePath);
    const themes = requiredThemes["default"] || requiredThemes["themes"];
    const generatedThemes = generatedThemesToTypescript(themes);
    const themeBuilder = promise ? await promise : null;
    return {
      generated: generatedThemes,
      state: themeBuilder == null ? void 0 : themeBuilder.state
    };
  } catch (err) {
    console.warn(` \u26A0\uFE0F Error running theme builder: ${err}`, err == null ? void 0 : err["stack"]);
  } finally {
    Module.prototype.require = ogRequire;
    unregister();
  }
}
const dedupedTokens = /* @__PURE__ */ new Map();
function generatedThemesToTypescript(themes) {
  const dedupedThemes = /* @__PURE__ */ new Map();
  const dedupedThemeToNames = /* @__PURE__ */ new Map();
  let i = 0;
  for (const name in themes) {
    i++;
    const theme = themes[name];
    let j = 0;
    for (const [key2, value] of Object.entries(theme)) {
      i++;
      const uniqueKey = `t${i}${j}`;
      if (!dedupedTokens.has(value)) {
        dedupedTokens.set(value, uniqueKey);
      }
    }
    const key = JSON.stringify(theme);
    if (dedupedThemes.has(key)) {
      dedupedThemeToNames.set(key, [...dedupedThemeToNames.get(key), name]);
    } else {
      dedupedThemes.set(key, theme);
      dedupedThemeToNames.set(key, [name]);
    }
  }
  const baseKeys = Object.entries(themes.light || themes[Object.keys(themes)[0]]);
  const baseTypeString = `type Theme = {
${baseKeys.map(([k]) => {
    return `  ${k}: string;
`;
  }).join("")}
}`;
  let out = `${baseTypeString}
`;
  out += `
function t(a) {
  let res: Record<string, string> = {}
  for (const [ki, vi] of a) {
    // @ts-ignore
    res[ks[ki]] = vs[vi]
  }
  return res
}
`;
  out += `const vs = [
`;
  let index = 0;
  const valueToIndex = {};
  dedupedTokens.forEach((name, value) => {
    valueToIndex[value] = index;
    index++;
    out += `  '${value}',
`;
  });
  out += "]\n\n";
  const keys = baseKeys.map(([k]) => k);
  out += `const ks = [
`;
  out += keys.map((k) => `'${k}'`).join(",\n");
  out += `]

`;
  let nameI = 0;
  dedupedThemes.forEach((theme) => {
    nameI++;
    const key = JSON.stringify(theme);
    const names = dedupedThemeToNames.get(key);
    const name = `n${nameI}`;
    const baseTheme = `const ${name} = ${objectToJsString(
      theme,
      keys,
      valueToIndex
    )} as Theme`;
    out += `
${baseTheme}`;
    const duplicateThemes = names.map((n) => `export const ${n} = ${name} as Theme`);
    out += `

` + duplicateThemes.join("\n");
  });
  return out;
}
function objectToJsString(obj, keys, valueToIndex) {
  let arrItems = [];
  for (const key in obj) {
    const ki = keys.indexOf(key);
    const vi = valueToIndex[obj[key]];
    arrItems.push(`[${ki}, ${vi}]`);
  }
  return `t([${arrItems.join(",")}])`;
}
function createThemeIntercept(createThemeExport, themeBuilderInterceptOpts) {
  return new Proxy(createThemeExport, {
    get(target, key) {
      const out = Reflect.get(target, key);
      if (key === "createThemeBuilder") {
        return new Proxy(out, {
          apply(target2, thisArg, argArray) {
            const builder = Reflect.apply(target2, thisArg, argArray);
            return themeBuilderIntercept(builder, themeBuilderInterceptOpts);
          }
        });
      }
      return out;
    }
  });
}
function themeBuilderIntercept(themeBuilder, themeBuilderInterceptOpts) {
  return new Proxy(themeBuilder, {
    get(target, key) {
      const out = Reflect.get(target, key);
      if (key === "build") {
        themeBuilderInterceptOpts.onComplete({
          themeBuilder
        });
      }
      return out;
    }
  });
}
function purgeCache(moduleName) {
  searchCache(moduleName, function(mod) {
    delete require.cache[mod.id];
  });
  Object.keys(module.constructor._pathCache).forEach(function(cacheKey) {
    if (cacheKey.indexOf(moduleName) > 0) {
      delete module.constructor._pathCache[cacheKey];
    }
  });
}
function searchCache(moduleName, callback) {
  let mod = require.resolve(moduleName);
  if (mod && (mod = require.cache[mod]) !== void 0) {
    ;
    (function traverse(mod2, depth = 0) {
      if (depth > 10)
        return;
      mod2.children.forEach(function(child) {
        traverse(child, depth + 1);
      });
      callback(mod2);
    })(mod);
  }
}
export {
  generateThemes
};
//# sourceMappingURL=generate-themes.mjs.map
