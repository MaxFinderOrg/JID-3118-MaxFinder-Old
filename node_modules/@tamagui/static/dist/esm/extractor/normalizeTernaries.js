import generate from "@babel/generator";
import * as t from "@babel/types";
import invariant from "invariant";
function normalizeTernaries(ternaries) {
  invariant(
    Array.isArray(ternaries),
    "extractStaticTernaries expects param 1 to be an array of ternaries"
  );
  if (ternaries.length === 0) {
    return [];
  }
  const ternariesByKey = {};
  for (let idx = -1, len = ternaries.length; ++idx < len; ) {
    const { test, consequent, alternate, remove, ...rest } = ternaries[idx];
    let ternaryTest = test;
    if (t.isExpressionStatement(test)) {
      ternaryTest = test.expression;
    }
    let shouldSwap = false;
    if (t.isUnaryExpression(test) && test.operator === "!") {
      ternaryTest = test.argument;
      shouldSwap = true;
    } else if (t.isBinaryExpression(test)) {
      if (test.operator === "!==" || test.operator === "!=") {
        ternaryTest = t.binaryExpression(
          test.operator.replace("!", "="),
          test.left,
          test.right
        );
        shouldSwap = true;
      }
    }
    const key = generate(ternaryTest).code;
    if (!ternariesByKey[key]) {
      ternariesByKey[key] = {
        ...rest,
        alternate: {},
        consequent: {},
        test: ternaryTest,
        remove
      };
    }
    const altStyle = (shouldSwap ? consequent : alternate) ?? {};
    const consStyle = (shouldSwap ? alternate : consequent) ?? {};
    Object.assign(ternariesByKey[key].alternate, altStyle);
    Object.assign(ternariesByKey[key].consequent, consStyle);
  }
  const ternaryExpression = Object.keys(ternariesByKey).map((key) => {
    return ternariesByKey[key];
  });
  return ternaryExpression;
}
export {
  normalizeTernaries
};
//# sourceMappingURL=normalizeTernaries.js.map
