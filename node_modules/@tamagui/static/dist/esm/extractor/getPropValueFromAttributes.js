import generate from "@babel/generator";
import * as t from "@babel/types";
import { accessSafe } from "./accessSafe";
function getPropValueFromAttributes(propName, attrs) {
  let propIndex = -1;
  let jsxAttr = null;
  for (let idx = -1, len = attrs.length; ++idx < len; ) {
    const attr = attrs[idx];
    if (t.isJSXAttribute(attr) && attr.name && attr.name.name === propName) {
      propIndex = idx;
      jsxAttr = attr;
      break;
    }
  }
  if (!jsxAttr || jsxAttr.value == null) {
    return null;
  }
  let propValue = jsxAttr.value;
  if (t.isJSXExpressionContainer(propValue)) {
    propValue = propValue.expression;
  }
  if (t.isJSXEmptyExpression(propValue)) {
    console.error("encountered JSXEmptyExpression");
    return null;
  }
  const applicableSpreads = attrs.filter(
    // 1. idx is greater than propValue prop index
    // 2. attr is a spread operator
    (attr, idx) => {
      if (t.isJSXSpreadAttribute(attr)) {
        if (t.isIdentifier(attr.argument) || t.isMemberExpression(attr.argument)) {
          return idx > propIndex;
        }
        if (t.isLogicalExpression(attr.argument)) {
          return false;
        }
        throw new Error(
          `unsupported spread of type "${attr.argument.type}": ${// @ts-ignore
          generate(attr).code}`
        );
      }
      return false;
    }
  ).map((attr) => attr.argument);
  if (applicableSpreads.length > 0) {
    propValue = applicableSpreads.reduce(
      (acc, val) => t.logicalExpression("||", accessSafe(val, propName), acc),
      propValue
    );
  }
  return propValue;
}
export {
  getPropValueFromAttributes
};
//# sourceMappingURL=getPropValueFromAttributes.js.map
