import { basename, relative } from "path";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import {
  expandStylesAndRemoveNullishValues,
  getSplitStyles,
  mediaQueryConfig,
  propMapper,
  proxyThemeVariables,
  pseudoDescriptors
} from "@tamagui/core-node";
import { createDOMProps } from "react-native-web-internals";
import { FAILED_EVAL } from "../constants";
import { createEvaluator, createSafeEvaluator } from "./createEvaluator";
import { evaluateAstNode } from "./evaluateAstNode";
import {
  attrStr,
  findComponentName,
  getValidComponent,
  getValidComponentsPaths,
  getValidImport,
  isPresent,
  isValidImport,
  objToStr
} from "./extractHelpers";
import { findTopmostFunction } from "./findTopmostFunction";
import { cleanupBeforeExit, getStaticBindingsForScope } from "./getStaticBindingsForScope";
import { literalToAst } from "./literalToAst";
import { loadTamagui, loadTamaguiSync } from "./loadTamagui";
import { logLines } from "./logLines";
import { normalizeTernaries } from "./normalizeTernaries";
import { setPropsToFontFamily } from "./propsToFontFamilyCache";
import { removeUnusedHooks } from "./removeUnusedHooks";
import { timer } from "./timer";
import { validHTMLAttributes } from "./validHTMLAttributes";
const UNTOUCHED_PROPS = {
  key: true,
  style: true,
  className: true
};
const INLINE_EXTRACTABLE = {
  ref: "ref",
  key: "key",
  ...process.env.TAMAGUI_TARGET === "web" && {
    onPress: "onClick",
    onHoverIn: "onMouseEnter",
    onHoverOut: "onMouseLeave",
    onPressIn: "onMouseDown",
    onPressOut: "onMouseUp"
  }
};
const validHooks = {
  useMedia: true,
  useTheme: true
};
const createTernary = (x) => x;
let hasLoggedBaseInfo = false;
function isFullyDisabled(props) {
  return props.disableExtraction && props.disableDebugAttr;
}
function createExtractor({ logger = console } = { logger: console }) {
  if (!process.env.TAMAGUI_TARGET) {
    console.warn('\u26A0\uFE0F Please set process.env.TAMAGUI_TARGET to either "web" or "native"');
    process.exit(1);
  }
  const componentState = {
    focus: false,
    hover: false,
    unmounted: true,
    press: false,
    pressIn: false
  };
  const styleProps = {
    resolveVariablesAs: process.env.TAMAGUI_TARGET === "native" ? "value" : "variable",
    noClassNames: false,
    isAnimated: false
  };
  const shouldAddDebugProp = (
    // really basic disable this for next.js because it messes with ssr
    !process.env.npm_package_dependencies_next && process.env.TAMAGUI_TARGET !== "native" && process.env.IDENTIFY_TAGS !== "false" && (process.env.NODE_ENV === "development" || process.env.DEBUG || process.env.IDENTIFY_TAGS)
  );
  let projectInfo = null;
  function loadSync(props) {
    if (isFullyDisabled(props)) {
      return null;
    }
    return projectInfo ||= loadTamaguiSync(props);
  }
  async function load(props) {
    if (isFullyDisabled(props)) {
      return null;
    }
    return projectInfo ||= await loadTamagui(props);
  }
  return {
    options: {
      logger
    },
    cleanupBeforeExit,
    loadTamagui: load,
    loadTamaguiSync: loadSync,
    getTamagui() {
      return projectInfo == null ? void 0 : projectInfo.tamaguiConfig;
    },
    parseSync: (f, props) => {
      const projectInfo2 = loadSync(props);
      return parseWithConfig(projectInfo2 || {}, f, props);
    },
    parse: async (f, props) => {
      const projectInfo2 = await load(props);
      return parseWithConfig(projectInfo2 || {}, f, props);
    }
  };
  function parseWithConfig({ components, tamaguiConfig }, fileOrPath, options) {
    var _a;
    const {
      config = "tamagui.config.ts",
      importsWhitelist = ["constants.js"],
      evaluateVars = true,
      sourcePath = "",
      onExtractTag,
      onStyleRule,
      getFlattenedNode,
      disable,
      disableExtraction,
      disableExtractInlineMedia,
      disableExtractVariables,
      disableDebugAttr,
      disableExtractFoundComponents,
      includeExtensions = [".ts", ".tsx", ".jsx"],
      extractStyledDefinitions = false,
      prefixLogs,
      excludeProps,
      target,
      ...restProps
    } = options;
    let shouldPrintDebug = options.shouldPrintDebug || false;
    if (disable === true || Array.isArray(disable) && disable.includes(sourcePath)) {
      return null;
    }
    if (!isFullyDisabled(options)) {
      if (!components) {
        throw new Error(`Must provide components`);
      }
    }
    if (sourcePath && includeExtensions && !includeExtensions.some((ext) => sourcePath.endsWith(ext))) {
      if (shouldPrintDebug) {
        logger.info(
          `Ignoring file due to includeExtensions: ${sourcePath}, includeExtensions: ${includeExtensions.join(
            ", "
          )}`
        );
      }
      return null;
    }
    function isValidStyleKey(name, staticConfig) {
      var _a2, _b, _c;
      if (!projectInfo) {
        throw new Error(`Tamagui extractor not loaded yet`);
      }
      if (target === "native" && name[0] === "$" && mediaQueryConfig[name.slice(1)]) {
        return false;
      }
      return !!(((_a2 = staticConfig.validStyles) == null ? void 0 : _a2[name]) || pseudoDescriptors[name] || // dont disable variants or else you lose many things flattening
      ((_b = staticConfig.variants) == null ? void 0 : _b[name]) || ((_c = projectInfo == null ? void 0 : projectInfo.tamaguiConfig) == null ? void 0 : _c.shorthands[name]) || (name[0] === "$" ? !!mediaQueryConfig[name.slice(1)] : false));
    }
    const isTargetingHTML = target === "html";
    const ogDebug = shouldPrintDebug;
    const tm = timer();
    const propsWithFileInfo = {
      ...options,
      sourcePath,
      allLoadedComponents: components ? [...components] : []
    };
    if (!hasLoggedBaseInfo) {
      hasLoggedBaseInfo = true;
      if (shouldPrintDebug) {
        logger.info(
          [
            "loaded components:",
            propsWithFileInfo.allLoadedComponents.map((comp) => Object.keys(comp.nameToInfo).join(", ")).join(", ")
          ].join(" ")
        );
      }
      if ((_a = process.env.DEBUG) == null ? void 0 : _a.startsWith("tamagui")) {
        logger.info(
          [
            "loaded:",
            JSON.stringify(propsWithFileInfo.allLoadedComponents, null, 2)
          ].join("\n")
        );
      }
    }
    tm.mark("load-tamagui", !!shouldPrintDebug);
    if (!isFullyDisabled(options)) {
      if (!(tamaguiConfig == null ? void 0 : tamaguiConfig.themes)) {
        console.error(
          `\u26D4\uFE0F Error: Missing "themes" in your tamagui.config file, this may be due to duplicated dependency versions. Try out https://github.com/bmish/check-dependency-version-consistency to see if there are mis-matches, or search your lockfile.`
        );
        console.log(`  Got config:`, tamaguiConfig);
        process.exit(0);
      }
    }
    const firstThemeName = Object.keys((tamaguiConfig == null ? void 0 : tamaguiConfig.themes) || {})[0];
    const firstTheme = (tamaguiConfig == null ? void 0 : tamaguiConfig.themes[firstThemeName]) || {};
    if (!firstTheme || typeof firstTheme !== "object") {
      console.error(`Missing theme, an error occurred when importing your config`);
      console.log(`Got config:`, tamaguiConfig);
      console.log(`Looking for theme:`, firstThemeName);
      process.exit(0);
    }
    const proxiedTheme = proxyThemeVariables(firstTheme);
    const themeAccessListeners = /* @__PURE__ */ new Set();
    const defaultTheme = new Proxy(proxiedTheme, {
      get(target2, key) {
        if (Reflect.has(target2, key)) {
          themeAccessListeners.forEach((cb) => cb(String(key)));
        }
        return Reflect.get(target2, key);
      }
    });
    const body = fileOrPath.type === "Program" ? fileOrPath.get("body") : fileOrPath.program.body;
    if (!isFullyDisabled(options)) {
      if (Object.keys(components || []).length === 0) {
        console.warn(
          `Warning: Tamagui didn't find any valid components (DEBUG=tamagui for more)`
        );
        if (process.env.DEBUG === "tamagui") {
          console.log(`components`, Object.keys(components || []), components);
        }
      }
    }
    if (shouldPrintDebug === "verbose") {
      logger.info(
        `allLoadedComponent modules ${propsWithFileInfo.allLoadedComponents.map((k) => k.moduleName).join(", ")}`
      );
    }
    let doesUseValidImport = false;
    let hasImportedTheme = false;
    const importDeclarations = [];
    for (const bodyPath of body) {
      if (bodyPath.type !== "ImportDeclaration")
        continue;
      const node = "node" in bodyPath ? bodyPath.node : bodyPath;
      const moduleName = node.source.value;
      const valid = isValidImport(propsWithFileInfo, moduleName);
      if (valid) {
        importDeclarations.push(node);
      }
      if (extractStyledDefinitions) {
        if (valid) {
          if (node.specifiers.some((specifier) => specifier.local.name === "styled")) {
            doesUseValidImport = true;
            break;
          }
        }
      }
      if (valid) {
        const names = node.specifiers.map((specifier) => specifier.local.name);
        const isValidComponent = names.some(
          (name) => Boolean(isValidImport(propsWithFileInfo, moduleName, name) || validHooks[name])
        );
        if (shouldPrintDebug === "verbose") {
          logger.info(
            ` - import ${isValidComponent ? "\u2705" : "\u21E3"} - ${names.join(
              ", "
            )} from '${moduleName}' - (valid: ${JSON.stringify(
              getValidComponentsPaths(propsWithFileInfo)
            )})`
          );
        }
        if (isValidComponent) {
          doesUseValidImport = true;
          break;
        }
      }
    }
    if (shouldPrintDebug) {
      logger.info(
        `${JSON.stringify({ doesUseValidImport, hasImportedTheme }, null, 2)}
`
      );
    }
    if (!doesUseValidImport) {
      return null;
    }
    function getValidImportedComponent(componentName) {
      const importDeclaration = importDeclarations.find(
        (dec) => dec.specifiers.some((spec) => spec.local.name === componentName)
      );
      if (!importDeclaration) {
        return null;
      }
      return getValidImport(
        propsWithFileInfo,
        importDeclaration.source.value,
        componentName
      );
    }
    tm.mark("import-check", !!shouldPrintDebug);
    let couldntParse = false;
    const modifiedComponents = /* @__PURE__ */ new Set();
    const bindingCache = {};
    const callTraverse = (a) => {
      return fileOrPath.type === "File" ? traverse(fileOrPath, a) : fileOrPath.traverse(a);
    };
    const shouldDisableExtraction = disableExtraction === true || Array.isArray(disableExtraction) && disableExtraction.includes(sourcePath);
    let programPath = null;
    const res = {
      styled: 0,
      flattened: 0,
      optimized: 0,
      modified: 0,
      found: 0
    };
    callTraverse({
      // @ts-ignore
      Program: {
        enter(path) {
          programPath = path;
        }
      },
      // styled() calls
      CallExpression(path) {
        var _a2;
        if (disable || shouldDisableExtraction || extractStyledDefinitions === false) {
          return;
        }
        if (!t.isIdentifier(path.node.callee) || path.node.callee.name !== "styled") {
          return;
        }
        const variableName = t.isVariableDeclarator(path.parent) && t.isIdentifier(path.parent.id) ? path.parent.id.name : "unknown";
        const parentNode = path.node.arguments[0];
        if (!t.isIdentifier(parentNode)) {
          return;
        }
        const parentName = parentNode.name;
        const definition = path.node.arguments[1];
        if (!parentName || !definition || !t.isObjectExpression(definition)) {
          return;
        }
        const Component = getValidImportedComponent(parentName);
        if (!Component) {
          if (shouldPrintDebug) {
            logger.info(` No component found`);
          }
          return;
        }
        const componentSkipProps = /* @__PURE__ */ new Set([
          ...Component.staticConfig.inlineWhenUnflattened || [],
          ...Component.staticConfig.inlineProps || [],
          ...Component.staticConfig.deoptProps || [],
          // for now skip variants, will return to them
          "variants",
          "defaultVariants",
          // skip fontFamily its basically a "variant", important for theme use to be value always
          "fontFamily",
          "name",
          "focusStyle",
          "hoverStyle",
          "pressStyle"
        ]);
        const skipped = /* @__PURE__ */ new Set();
        const styles = {};
        const staticNamespace = getStaticBindingsForScope(
          path.scope,
          importsWhitelist,
          sourcePath,
          bindingCache,
          shouldPrintDebug
        );
        const attemptEval = !evaluateVars ? evaluateAstNode : createEvaluator({
          props: propsWithFileInfo,
          staticNamespace,
          sourcePath,
          shouldPrintDebug
        });
        const attemptEvalSafe = createSafeEvaluator(attemptEval);
        for (const property of definition.properties) {
          if (!t.isObjectProperty(property) || !t.isIdentifier(property.key) || !isValidStyleKey(property.key.name, Component.staticConfig) || // TODO make pseudos and variants work
          // skip pseudos
          pseudoDescriptors[property.key.name] || // skip variants
          ((_a2 = Component.staticConfig.variants) == null ? void 0 : _a2[property.key.name]) || componentSkipProps.has(property.key.name)) {
            skipped.add(property);
            continue;
          }
          const out2 = attemptEvalSafe(property.value);
          if (out2 === FAILED_EVAL) {
            skipped.add(property);
          } else {
            styles[property.key.name] = out2;
          }
        }
        const out = getSplitStyles(
          styles,
          Component.staticConfig,
          defaultTheme,
          "",
          componentState,
          styleProps,
          void 0,
          void 0,
          void 0,
          shouldPrintDebug
        );
        const classNames = {
          ...out.classNames
        };
        if (shouldPrintDebug) {
          logger.info(
            [
              `Extracted styled(${variableName})
`,
              JSON.stringify(styles, null, 2),
              "\n classNames:",
              JSON.stringify(classNames, null, 2),
              "\n  rulesToInsert:",
              out.rulesToInsert.flatMap((rule) => rule.rules).join("\n")
            ].join(" ")
          );
        }
        definition.properties = definition.properties.map((prop) => {
          if (skipped.has(prop) || !t.isObjectProperty(prop) || !t.isIdentifier(prop.key)) {
            return prop;
          }
          const key = prop.key.name;
          const value = classNames[key];
          if (value) {
            return t.objectProperty(t.stringLiteral(key), t.stringLiteral(value));
          }
          return prop;
        });
        if (out.rulesToInsert) {
          for (const { identifier, rules } of out.rulesToInsert) {
            onStyleRule == null ? void 0 : onStyleRule(identifier, rules);
          }
        }
        res.styled++;
        if (shouldPrintDebug) {
          logger.info(`Extracted styled(${variableName})`);
        }
      },
      JSXElement(traversePath) {
        var _a2;
        tm.mark("jsx-element", !!shouldPrintDebug);
        const node = traversePath.node.openingElement;
        const ogAttributes = node.attributes.map((attr) => ({ ...attr }));
        const componentName = findComponentName(traversePath.scope);
        const closingElement = traversePath.node.closingElement;
        if (t.isJSXMemberExpression(closingElement == null ? void 0 : closingElement.name) || !t.isJSXIdentifier(node.name)) {
          return;
        }
        const binding = traversePath.scope.getBinding(node.name.name);
        let modulePath = "";
        if (binding) {
          if (!t.isImportDeclaration(binding.path.parent)) {
            if (shouldPrintDebug) {
              logger.info(` - Binding not import declaration, skip`);
            }
            return;
          }
          modulePath = binding.path.parent.source.value;
          if (!isValidImport(propsWithFileInfo, modulePath, binding.identifier.name)) {
            if (shouldPrintDebug) {
              logger.info(
                ` - Binding for ${componentName} not internal import or from components ${binding.identifier.name} in ${modulePath}`
              );
            }
            return;
          }
        }
        const component = getValidComponent(propsWithFileInfo, modulePath, node.name.name);
        if (!component || !component.staticConfig) {
          if (shouldPrintDebug) {
            logger.info(` - No Tamagui conf on this: ${node.name.name}`);
          }
          return;
        }
        const originalNodeName = node.name.name;
        res.found++;
        const filePath = `./${relative(process.cwd(), sourcePath)}`;
        const lineNumbers = node.loc ? node.loc.start.line + (node.loc.start.line !== node.loc.end.line ? `-${node.loc.end.line}` : "") : "";
        const codePosition = `${filePath}:${lineNumbers}`;
        const debugPropValue = node.attributes.filter(
          (n) => t.isJSXAttribute(n) && t.isJSXIdentifier(n.name) && n.name.name === "debug"
        ).map((n) => {
          if (n.value === null)
            return true;
          if (t.isStringLiteral(n.value))
            return n.value.value;
          return false;
        })[0];
        if (debugPropValue) {
          shouldPrintDebug = debugPropValue;
        }
        if (shouldPrintDebug) {
          logger.info("\n");
          logger.info(
            `\x1B[33m%s\x1B[0m ${componentName} | ${codePosition} -------------------`
          );
          logger.info(["\x1B[1m", "\x1B[32m", `<${originalNodeName} />`, disableDebugAttr ? "" : "\u{1F41B}"].join(" "));
        }
        if (shouldAddDebugProp && !disableDebugAttr) {
          res.modified++;
          node.attributes.unshift(
            t.jsxAttribute(t.jsxIdentifier("data-is"), t.stringLiteral(node.name.name))
          );
          if (componentName) {
            node.attributes.unshift(
              t.jsxAttribute(t.jsxIdentifier("data-in"), t.stringLiteral(componentName))
            );
          }
          node.attributes.unshift(
            t.jsxAttribute(
              t.jsxIdentifier("data-at"),
              t.stringLiteral(`${basename(filePath)}:${lineNumbers}`)
            )
          );
        }
        if (shouldDisableExtraction) {
          if (shouldPrintDebug === "verbose") {
            console.log(` Extraction disabled`);
          }
          return;
        }
        try {
          let evaluateAttribute2 = function(path) {
            const attribute = path.node;
            const attr = { type: "attr", value: attribute };
            if (t.isJSXSpreadAttribute(attribute)) {
              const arg = attribute.argument;
              const conditional = t.isConditionalExpression(arg) ? (
                // <YStack {...isSmall ? { color: 'red } : { color: 'blue }}
                [arg.test, arg.consequent, arg.alternate]
              ) : t.isLogicalExpression(arg) && arg.operator === "&&" ? (
                // <YStack {...isSmall && { color: 'red }}
                [arg.left, arg.right, null]
              ) : null;
              if (conditional) {
                const [test, alt, cons] = conditional;
                if (!test)
                  throw new Error(`no test`);
                if ([alt, cons].some((side) => side && !isStaticObject2(side))) {
                  if (shouldPrintDebug) {
                    logger.info(`not extractable ${alt} ${cons}`);
                  }
                  return attr;
                }
                return [
                  ...createTernariesFromObjectProperties2(test, alt) || [],
                  ...cons && createTernariesFromObjectProperties2(
                    t.unaryExpression("!", test),
                    cons
                  ) || []
                ].map((ternary) => ({
                  type: "ternary",
                  value: ternary
                }));
              }
            }
            if (t.isJSXSpreadAttribute(attribute) || !attribute.name || typeof attribute.name.name !== "string") {
              if (shouldPrintDebug) {
                logger.info("  ! inlining, spread attr");
              }
              inlined.set(`${Math.random()}`, "spread");
              return attr;
            }
            const name = attribute.name.name;
            if (excludeProps == null ? void 0 : excludeProps.has(name)) {
              if (shouldPrintDebug) {
                logger.info(["  excluding prop", name].join(" "));
              }
              return null;
            }
            if (inlineProps.has(name)) {
              inlined.set(name, name);
              if (shouldPrintDebug) {
                logger.info(["  ! inlining, inline prop", name].join(" "));
              }
              return attr;
            }
            if (deoptProps.has(name)) {
              shouldDeopt = true;
              inlined.set(name, name);
              if (shouldPrintDebug) {
                logger.info(["  ! inlining, deopted prop", name].join(" "));
              }
              return attr;
            }
            if (UNTOUCHED_PROPS[name]) {
              return attr;
            }
            if (INLINE_EXTRACTABLE[name]) {
              inlined.set(name, INLINE_EXTRACTABLE[name]);
              return attr;
            }
            if (name.startsWith("data-")) {
              return attr;
            }
            if (name[0] === "$" && t.isJSXExpressionContainer(attribute == null ? void 0 : attribute.value)) {
              const shortname = name.slice(1);
              if (mediaQueryConfig[shortname]) {
                if (target === "native") {
                  shouldDeopt = true;
                }
                if (disableExtractInlineMedia) {
                  return attr;
                }
                const expression = attribute.value.expression;
                if (!t.isJSXEmptyExpression(expression)) {
                  const ternaries2 = createTernariesFromObjectProperties2(
                    t.stringLiteral(shortname),
                    expression,
                    {
                      inlineMediaQuery: shortname
                    }
                  );
                  if (ternaries2) {
                    return ternaries2.map((value2) => ({
                      type: "ternary",
                      value: value2
                    }));
                  }
                }
              }
            }
            const [value, valuePath] = (() => {
              if (t.isJSXExpressionContainer(attribute == null ? void 0 : attribute.value)) {
                return [attribute.value.expression, path.get("value")];
              } else {
                return [attribute.value, path.get("value")];
              }
            })();
            const remove = () => {
              Array.isArray(valuePath) ? valuePath.map((p) => p.remove()) : valuePath.remove();
            };
            if (name === "ref") {
              if (shouldPrintDebug) {
                logger.info(["  ! inlining, ref", name].join(" "));
              }
              inlined.set("ref", "ref");
              return attr;
            }
            if (name === "tag") {
              return {
                type: "attr",
                value: path.node
              };
            }
            if (disableExtractVariables === true) {
              if (value) {
                if (value.type === "StringLiteral" && value.value[0] === "$") {
                  if (shouldPrintDebug) {
                    logger.info(
                      [
                        `  ! inlining, native disable extract: ${name} =`,
                        value.value
                      ].join(" ")
                    );
                  }
                  inlined.set(name, true);
                  return attr;
                }
              }
            }
            if (name === "theme") {
              inlined.set("theme", attr.value);
              return attr;
            }
            const styleValue = attemptEvalSafe(value);
            if (!variants[name] && !isValidStyleKey(name, staticConfig)) {
              let keys = [name];
              let out = null;
              out = propMapper(name, styleValue, propMapperStyleState);
              if (out) {
                if (!Array.isArray(out)) {
                  logger.warn(`Error expected array but got`, out);
                  couldntParse = true;
                  shouldDeopt = true;
                } else {
                  out = Object.fromEntries(out);
                  keys = Object.keys(out);
                }
              }
              if (out) {
                if (isTargetingHTML) {
                  out = createDOMProps(isTextView ? "span" : "div", out);
                  delete out.className;
                }
                keys = Object.keys(out);
              }
              let didInline = false;
              const attributes = keys.map((key) => {
                const val = out[key];
                const isStyle = isValidStyleKey(key, staticConfig);
                if (isStyle) {
                  return {
                    type: "style",
                    value: { [key]: styleValue },
                    name: key,
                    attr: path.node
                  };
                }
                if (validHTMLAttributes[key] || key.startsWith("aria-") || key.startsWith("data-") || // this is debug stuff added by vite / new jsx transform
                key === "__source" || key === "__self") {
                  return attr;
                }
                if (shouldPrintDebug) {
                  logger.info("  ! inlining, non-static " + key);
                }
                didInline = true;
                inlined.set(key, val);
                return val;
              });
              if (didInline) {
                if (shouldPrintDebug) {
                  logger.info(`  bailing flattening due to attributes ${attributes}`);
                }
                return attr;
              }
              return attributes;
            }
            if (styleValue !== FAILED_EVAL) {
              if (inlineWhenUnflattened.has(name)) {
                inlineWhenUnflattenedOGVals[name] = { styleValue, attr };
              }
              if (isValidStyleKey(name, staticConfig)) {
                if (shouldPrintDebug) {
                  logger.info(`  style: ${name} = ${styleValue}`);
                }
                if (!(name in defaultProps)) {
                  if (!hasSetOptimized) {
                    res.optimized++;
                    hasSetOptimized = true;
                  }
                }
                return {
                  type: "style",
                  value: { [name]: styleValue },
                  name,
                  attr: path.node
                };
              } else {
                if (variants[name]) {
                  variantValues.set(name, styleValue);
                }
                inlined.set(name, true);
                return attr;
              }
            }
            if (t.isBinaryExpression(value)) {
              if (shouldPrintDebug) {
                logger.info(` binary expression ${name} = ${value}`);
              }
              const { operator, left, right } = value;
              const lVal = attemptEvalSafe(left);
              const rVal = attemptEvalSafe(right);
              if (shouldPrintDebug) {
                logger.info(
                  `  evalBinaryExpression lVal ${String(lVal)}, rVal ${String(rVal)}`
                );
              }
              if (lVal !== FAILED_EVAL && t.isConditionalExpression(right)) {
                const ternary = addBinaryConditional(operator, left, right);
                if (ternary)
                  return ternary;
              }
              if (rVal !== FAILED_EVAL && t.isConditionalExpression(left)) {
                const ternary = addBinaryConditional(operator, right, left);
                if (ternary)
                  return ternary;
              }
              if (shouldPrintDebug) {
                logger.info(`  evalBinaryExpression cant extract`);
              }
              inlined.set(name, true);
              return attr;
            }
            const staticConditional = getStaticConditional(value);
            if (staticConditional) {
              if (shouldPrintDebug === "verbose") {
                logger.info(` static conditional ${name} ${value}`);
              }
              return { type: "ternary", value: staticConditional };
            }
            const staticLogical = getStaticLogical(value);
            if (staticLogical) {
              if (shouldPrintDebug === "verbose") {
                logger.info(` static ternary ${name} =  ${value}`);
              }
              return { type: "ternary", value: staticLogical };
            }
            inlined.set(name, true);
            if (shouldPrintDebug) {
              logger.info(` ! inline no match ${name} ${value}`);
            }
            return attr;
            function addBinaryConditional(operator, staticExpr, cond) {
              if (getStaticConditional(cond)) {
                const alt = attemptEval(
                  t.binaryExpression(operator, staticExpr, cond.alternate)
                );
                const cons = attemptEval(
                  t.binaryExpression(operator, staticExpr, cond.consequent)
                );
                if (shouldPrintDebug) {
                  logger.info(["  binaryConditional", cond.test, cons, alt].join(" "));
                }
                return {
                  type: "ternary",
                  value: {
                    test: cond.test,
                    remove,
                    alternate: { [name]: alt },
                    consequent: { [name]: cons }
                  }
                };
              }
              return null;
            }
            function getStaticConditional(value2) {
              if (t.isConditionalExpression(value2)) {
                try {
                  const aVal = attemptEval(value2.alternate);
                  const cVal = attemptEval(value2.consequent);
                  if (shouldPrintDebug) {
                    const type = value2.test.type;
                    logger.info(["      static ternary", type, cVal, aVal].join(" "));
                  }
                  return {
                    test: value2.test,
                    remove,
                    consequent: { [name]: cVal },
                    alternate: { [name]: aVal }
                  };
                } catch (err) {
                  if (shouldPrintDebug) {
                    logger.info(["       cant eval ternary", err.message].join(" "));
                  }
                }
              }
              return null;
            }
            function getStaticLogical(value2) {
              if (t.isLogicalExpression(value2)) {
                if (value2.operator === "&&") {
                  try {
                    const val = attemptEval(value2.right);
                    if (shouldPrintDebug) {
                      logger.info(["  staticLogical", value2.left, name, val].join(" "));
                    }
                    return {
                      test: value2.left,
                      remove,
                      consequent: { [name]: val },
                      alternate: null
                    };
                  } catch (err) {
                    if (shouldPrintDebug) {
                      logger.info(["  cant static eval logical", err].join(" "));
                    }
                  }
                }
              }
              return null;
            }
          }, isStaticObject2 = function(obj) {
            return t.isObjectExpression(obj) && obj.properties.every((prop) => {
              if (!t.isObjectProperty(prop)) {
                logger.info(["not object prop", prop].join(" "));
                return false;
              }
              const propName = prop.key["name"];
              if (!isValidStyleKey(propName, staticConfig) && propName !== "tag") {
                if (shouldPrintDebug) {
                  logger.info(["  not a valid style prop!", propName].join(" "));
                }
                return false;
              }
              return true;
            });
          }, createTernariesFromObjectProperties2 = function(test, side, ternaryPartial = {}) {
            if (!side) {
              return null;
            }
            if (!isStaticObject2(side)) {
              throw new Error("not extractable");
            }
            return side.properties.flatMap((property) => {
              if (!t.isObjectProperty(property)) {
                throw new Error("expected object property");
              }
              if (t.isIdentifier(property.key)) {
                const key = property.key.name;
                const mediaQueryKey = key.slice(1);
                const isMediaQuery = key[0] === "$" && mediaQueryConfig[mediaQueryKey];
                if (isMediaQuery) {
                  if (t.isExpression(property.value)) {
                    const ternaries2 = createTernariesFromObjectProperties2(
                      t.stringLiteral(mediaQueryKey),
                      property.value,
                      {
                        inlineMediaQuery: mediaQueryKey
                      }
                    );
                    if (ternaries2) {
                      return ternaries2.map((value) => ({
                        ...ternaryPartial,
                        ...value,
                        // ensure media query test stays on left side (see getMediaQueryTernary)
                        test: t.logicalExpression("&&", value.test, test)
                      }));
                    } else {
                      logger.info(["\u26A0\uFE0F no ternaries?", property].join(" "));
                    }
                  } else {
                    logger.info(["\u26A0\uFE0F not expression", property].join(" "));
                  }
                }
              }
              if (t.isConditionalExpression(property.value)) {
                const [truthy, falsy] = [
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.consequent)
                  ]),
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.alternate)
                  ])
                ].map((x) => attemptEval(x));
                return [
                  createTernary({
                    remove() {
                    },
                    ...ternaryPartial,
                    test: t.logicalExpression("&&", test, property.value.test),
                    consequent: truthy,
                    alternate: null
                  }),
                  createTernary({
                    ...ternaryPartial,
                    test: t.logicalExpression(
                      "&&",
                      test,
                      t.unaryExpression("!", property.value.test)
                    ),
                    consequent: falsy,
                    alternate: null,
                    remove() {
                    }
                  })
                ];
              }
              const obj = t.objectExpression([
                t.objectProperty(property.key, property.value)
              ]);
              const consequent = attemptEval(obj);
              return createTernary({
                remove() {
                },
                ...ternaryPartial,
                test,
                consequent,
                alternate: null
              });
            });
          }, mergeToEnd2 = function(obj, key, val) {
            if (key in obj) {
              delete obj[key];
            }
            obj[key] = val;
          }, expandStylesAndRemoveNullishValuesWithoutVariants2 = function(style) {
            let res2 = {};
            for (const key in style) {
              if (staticConfig.variants && key in staticConfig.variants) {
                mergeToEnd2(res2, key, style[key]);
              } else {
                const expanded = expandStylesAndRemoveNullishValues({ [key]: style[key] });
                for (const key2 in expanded) {
                  mergeToEnd2(res2, key2, expanded[key2]);
                }
              }
            }
            return res2;
          }, mergeStyles2 = function(prev2, next) {
            for (const key in next) {
              if (pseudoDescriptors[key]) {
                prev2[key] = prev2[key] || {};
                Object.assign(prev2[key], next[key]);
              } else {
                mergeToEnd2(prev2, key, next[key]);
              }
            }
          };
          var evaluateAttribute = evaluateAttribute2, isStaticObject = isStaticObject2, createTernariesFromObjectProperties = createTernariesFromObjectProperties2, mergeToEnd = mergeToEnd2, expandStylesAndRemoveNullishValuesWithoutVariants = expandStylesAndRemoveNullishValuesWithoutVariants2, mergeStyles = mergeStyles2;
          const { staticConfig } = component;
          const defaultProps = { ...staticConfig.defaultProps || {} };
          const variants = staticConfig.variants || {};
          const isTextView = staticConfig.isText || false;
          const validStyles = (staticConfig == null ? void 0 : staticConfig.validStyles) ?? {};
          let tagName = defaultProps.tag ?? (isTextView ? "span" : "div");
          traversePath.get("openingElement").get("attributes").forEach((path) => {
            const attr = path.node;
            if (t.isJSXSpreadAttribute(attr))
              return;
            if (attr.name.name !== "tag")
              return;
            const val = attr.value;
            if (!t.isStringLiteral(val))
              return;
            tagName = val.value;
          });
          if (shouldPrintDebug === "verbose") {
            console.log(` Start tag ${tagName}`);
          }
          const flatNode = getFlattenedNode == null ? void 0 : getFlattenedNode({ isTextView, tag: tagName });
          const inlineProps = /* @__PURE__ */ new Set([
            // adding some always inline props
            "dataSet",
            ...restProps.inlineProps || [],
            ...staticConfig.inlineProps || []
          ]);
          const deoptProps = /* @__PURE__ */ new Set([
            // always de-opt animation these
            "animation",
            "disableOptimization",
            // when using a non-CSS driver, de-opt on enterStyle/exitStyle
            ...(tamaguiConfig == null ? void 0 : tamaguiConfig.animations.isReactNative) ? ["enterStyle", "exitStyle"] : [],
            ...restProps.deoptProps || [],
            ...staticConfig.deoptProps || []
          ]);
          const inlineWhenUnflattened = /* @__PURE__ */ new Set([
            ...staticConfig.inlineWhenUnflattened || []
          ]);
          const staticNamespace = getStaticBindingsForScope(
            traversePath.scope,
            importsWhitelist,
            sourcePath,
            bindingCache,
            shouldPrintDebug
          );
          const attemptEval = !evaluateVars ? evaluateAstNode : createEvaluator({
            props: propsWithFileInfo,
            staticNamespace,
            sourcePath,
            traversePath,
            shouldPrintDebug
          });
          const attemptEvalSafe = createSafeEvaluator(attemptEval);
          if (shouldPrintDebug) {
            logger.info(`  staticNamespace ${Object.keys(staticNamespace).join(", ")}`);
          }
          if (couldntParse) {
            return;
          }
          tm.mark("jsx-element-flattened", !!shouldPrintDebug);
          let attrs = [];
          let shouldDeopt = false;
          const inlined = /* @__PURE__ */ new Map();
          const variantValues = /* @__PURE__ */ new Map();
          let hasSetOptimized = false;
          const inlineWhenUnflattenedOGVals = {};
          const propMapperStyleState = {
            staticConfig,
            usedKeys: {},
            classNames: {},
            style: {},
            theme: defaultTheme,
            viewProps: defaultProps,
            conf: tamaguiConfig,
            curProps: defaultProps,
            props: defaultProps,
            componentState,
            styleProps: {
              ...styleProps,
              resolveVariablesAs: "auto"
            },
            debug: shouldPrintDebug
          };
          attrs = traversePath.get("openingElement").get("attributes").flatMap((path) => {
            var _a3;
            try {
              const res2 = evaluateAttribute2(path);
              tm.mark("jsx-element-evaluate-attr", !!shouldPrintDebug);
              if (!res2) {
                path.remove();
              }
              return res2;
            } catch (err) {
              if (shouldPrintDebug) {
                logger.info(
                  [
                    "Recoverable error extracting attribute",
                    err.message,
                    shouldPrintDebug === "verbose" ? err.stack : ""
                  ].join(" ")
                );
                if (shouldPrintDebug === "verbose") {
                  logger.info(`node ${(_a3 = path.node) == null ? void 0 : _a3.type}`);
                }
              }
              inlined.set(`${Math.random()}`, "spread");
              return {
                type: "attr",
                value: path.node
              };
            }
          }).flat(4).filter(isPresent);
          if (shouldPrintDebug) {
            logger.info(
              ["  - attrs (before):\n", logLines(attrs.map(attrStr).join(", "))].join(" ")
            );
          }
          if (couldntParse || shouldDeopt) {
            if (shouldPrintDebug) {
              logger.info(
                [`  avoid optimizing:`, { couldntParse, shouldDeopt }].join(" ")
              );
            }
            node.attributes = ogAttributes;
            return;
          }
          const parentFn = findTopmostFunction(traversePath);
          if (parentFn) {
            modifiedComponents.add(parentFn);
          }
          let ternaries = [];
          attrs = attrs.reduce((out, cur) => {
            const next = attrs[attrs.indexOf(cur) + 1];
            if (cur.type === "ternary") {
              ternaries.push(cur.value);
            }
            if ((!next || next.type !== "ternary") && ternaries.length) {
              const normalized = normalizeTernaries(ternaries).map(
                ({ alternate, consequent, ...rest }) => {
                  return {
                    type: "ternary",
                    value: {
                      ...rest,
                      alternate: alternate || null,
                      consequent: consequent || null
                    }
                  };
                }
              );
              try {
                return [...out, ...normalized];
              } finally {
                if (shouldPrintDebug) {
                  logger.info(
                    `    normalizeTernaries (${ternaries.length} => ${normalized.length})`
                  );
                }
                ternaries = [];
              }
            }
            if (cur.type === "ternary") {
              return out;
            }
            out.push(cur);
            return out;
          }, []).flat();
          const hasSpread = attrs.some(
            (x) => x.type === "attr" && t.isJSXSpreadAttribute(x.value)
          );
          const hasOnlyStringChildren = !hasSpread && (node.selfClosing || traversePath.node.children && traversePath.node.children.every((x) => x.type === "JSXText"));
          const themeVal = inlined.get("theme");
          if (target !== "native") {
            inlined.delete("theme");
          }
          for (const [key] of [...inlined]) {
            const isStaticObjectVariant = ((_a2 = staticConfig.variants) == null ? void 0 : _a2[key]) && variantValues.has(key);
            if (INLINE_EXTRACTABLE[key] || isStaticObjectVariant) {
              inlined.delete(key);
            }
          }
          const canFlattenProps = inlined.size === 0;
          let shouldFlatten = Boolean(
            flatNode && !shouldDeopt && canFlattenProps && !hasSpread && !staticConfig.isStyledHOC && !staticConfig.isHOC && !staticConfig.isReactNative && staticConfig.neverFlatten !== true && (staticConfig.neverFlatten === "jsx" ? hasOnlyStringChildren : true)
          );
          const shouldWrapTheme = shouldFlatten && themeVal;
          const usedThemeKeys = /* @__PURE__ */ new Set();
          if (disableExtractVariables) {
            themeAccessListeners.add((key) => {
              shouldFlatten = false;
              usedThemeKeys.add(key);
              if (shouldPrintDebug === "verbose") {
                logger.info([" ! accessing theme key, avoid flatten", key].join(" "));
              }
            });
          }
          if (shouldPrintDebug) {
            try {
              logger.info([" flatten?", shouldFlatten, objToStr({ hasSpread, shouldDeopt, canFlattenProps, shouldWrapTheme, hasOnlyStringChildren }), "inlined", inlined.size, [...inlined]].join(" "));
            } catch {
            }
          }
          if (shouldFlatten && shouldWrapTheme) {
            if (!programPath) {
              console.warn(
                `No program path found, avoiding importing flattening / importing theme in ${sourcePath}`
              );
            } else {
              if (shouldPrintDebug) {
                logger.info(["  - wrapping theme", themeVal].join(" "));
              }
              attrs = attrs.filter(
                (x) => x.type === "attr" && t.isJSXAttribute(x.value) && x.value.name.name === "theme" ? false : true
              );
              if (!hasImportedTheme) {
                hasImportedTheme = true;
                programPath.node.body.push(
                  t.importDeclaration(
                    [
                      t.importSpecifier(
                        t.identifier("_TamaguiTheme"),
                        t.identifier("Theme")
                      )
                    ],
                    t.stringLiteral("@tamagui/core")
                  )
                );
              }
              traversePath.replaceWith(
                t.jsxElement(
                  t.jsxOpeningElement(t.jsxIdentifier("_TamaguiTheme"), [
                    t.jsxAttribute(t.jsxIdentifier("name"), themeVal.value)
                  ]),
                  t.jsxClosingElement(t.jsxIdentifier("_TamaguiTheme")),
                  [traversePath.node]
                )
              );
            }
          }
          if (shouldFlatten) {
            const defaultStyleAttrs = Object.keys(defaultProps).flatMap((key) => {
              if (!isValidStyleKey(key, staticConfig)) {
                return [];
              }
              const value = defaultProps[key];
              const name = (tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[key]) || key;
              if (value === void 0) {
                logger.warn(
                  `\u26A0\uFE0F Error evaluating default style for component, prop ${key} ${value}`
                );
                shouldDeopt = true;
                return;
              }
              const attr = {
                type: "style",
                name,
                value: { [name]: value }
              };
              return attr;
            });
            if (defaultStyleAttrs.length) {
              attrs = [...defaultStyleAttrs, ...attrs];
            }
          }
          if (shouldDeopt || !shouldFlatten) {
            if (shouldPrintDebug) {
              logger.info(`Deopting ${shouldDeopt} ${shouldFlatten}`);
            }
            node.attributes = ogAttributes;
            return;
          }
          if (shouldPrintDebug) {
            logger.info(
              ["  - attrs (flattened): \n", logLines(attrs.map(attrStr).join(", "))].join(
                " "
              )
            );
          }
          let foundStaticProps = {};
          for (const key in attrs) {
            const cur = attrs[key];
            if (cur.type === "style") {
              const expanded = expandStylesAndRemoveNullishValuesWithoutVariants2(
                cur.value
              );
              for (const key2 in expanded) {
                mergeToEnd2(foundStaticProps, key2, expanded[key2]);
              }
              continue;
            }
            if (cur.type === "attr") {
              if (t.isJSXSpreadAttribute(cur.value)) {
                continue;
              }
              if (!t.isJSXIdentifier(cur.value.name)) {
                continue;
              }
              const key2 = cur.value.name.name;
              const value = attemptEvalSafe(cur.value.value || t.booleanLiteral(true));
              if (value !== FAILED_EVAL) {
                mergeToEnd2(foundStaticProps, key2, value);
              }
            }
          }
          const completeProps = {};
          for (const key in defaultProps) {
            if (!(key in foundStaticProps)) {
              completeProps[key] = defaultProps[key];
            }
          }
          for (const key in foundStaticProps) {
            completeProps[key] = foundStaticProps[key];
          }
          attrs = attrs.reduce((acc, cur) => {
            if (!cur)
              return acc;
            if (cur.type === "attr" && !t.isJSXSpreadAttribute(cur.value)) {
              if (shouldFlatten) {
                const name = cur.value.name.name;
                if (typeof name === "string") {
                  if (name === "tag") {
                    return acc;
                  }
                  if (variants[name] && variantValues.has(name)) {
                    const styleState = {
                      ...propMapperStyleState,
                      props: completeProps,
                      curProps: completeProps
                    };
                    let out = Object.fromEntries(
                      propMapper(name, variantValues.get(name), styleState) || []
                    );
                    if (out && isTargetingHTML) {
                      const cn = out.className;
                      out = createDOMProps(isTextView ? "span" : "div", out);
                      out.className = cn;
                    }
                    if (shouldPrintDebug) {
                      logger.info([" - expanded variant", name, out].join(" "));
                    }
                    for (const key2 in out) {
                      const value2 = out[key2];
                      if (isValidStyleKey(key2, staticConfig)) {
                        acc.push({
                          type: "style",
                          value: { [key2]: value2 },
                          name: key2,
                          attr: cur.value
                        });
                      } else {
                        acc.push({
                          type: "attr",
                          value: t.jsxAttribute(
                            t.jsxIdentifier(key2),
                            t.jsxExpressionContainer(
                              typeof value2 === "string" ? t.stringLiteral(value2) : literalToAst(value2)
                            )
                          )
                        });
                      }
                    }
                  }
                }
              }
            }
            if (cur.type !== "style") {
              acc.push(cur);
              return acc;
            }
            let key = Object.keys(cur.value)[0];
            const value = cur.value[key];
            const fullKey = tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[key];
            if (fullKey) {
              cur.value = { [fullKey]: value };
              key = fullKey;
            }
            if (disableExtractVariables) {
              if (value[0] === "$" && (usedThemeKeys.has(key) || usedThemeKeys.has(fullKey))) {
                if (shouldPrintDebug) {
                  logger.info([`   keeping variable inline: ${key} =`, value].join(" "));
                }
                acc.push({
                  type: "attr",
                  value: t.jsxAttribute(
                    t.jsxIdentifier(key),
                    t.jsxExpressionContainer(t.stringLiteral(value))
                  )
                });
                return acc;
              }
            }
            acc.push(cur);
            return acc;
          }, []);
          tm.mark("jsx-element-expanded", !!shouldPrintDebug);
          if (shouldPrintDebug) {
            logger.info(
              ["  - attrs (expanded): \n", logLines(attrs.map(attrStr).join(", "))].join(
                " "
              )
            );
          }
          let prev = null;
          const getProps = (props, includeProps = false, debugName = "") => {
            if (!props) {
              if (shouldPrintDebug)
                logger.info([" getProps() no props"].join(" "));
              return {};
            }
            if (excludeProps == null ? void 0 : excludeProps.size) {
              for (const key in props) {
                if (excludeProps.has(key)) {
                  if (shouldPrintDebug)
                    logger.info([" delete excluded", key].join(" "));
                  delete props[key];
                }
              }
            }
            try {
              const out = getSplitStyles(
                props,
                staticConfig,
                defaultTheme,
                "",
                componentState,
                {
                  ...styleProps,
                  fallbackProps: completeProps
                },
                void 0,
                void 0,
                void 0,
                debugPropValue || shouldPrintDebug
              );
              const outProps = {
                ...includeProps ? out.viewProps : {},
                ...out.style,
                ...out.pseudos
              };
              if (shouldPrintDebug) {
                logger.info(`(${debugName})`);
                logger.info(`
       getProps (props in): ${logLines(objToStr(props))}`);
                logger.info(`
       getProps (outProps): ${logLines(objToStr(outProps))}`);
              }
              if (out.fontFamily) {
                setPropsToFontFamily(outProps, out.fontFamily);
                if (shouldPrintDebug) {
                  logger.info(`
      \u{1F4AC} new font fam: ${out.fontFamily}`);
                }
              }
              return outProps;
            } catch (err) {
              logger.info(["error", err.message, err.stack].join(" "));
              return {};
            }
          };
          if (shouldFlatten) {
            attrs.unshift({
              type: "style",
              value: defaultProps
            });
          }
          attrs = attrs.reduce((acc, cur) => {
            if (cur.type === "style") {
              const key = Object.keys(cur.value)[0];
              const value = cur.value[key];
              const shouldKeepOriginalAttr = (
                // !isStyleAndAttr[key] &&
                !shouldFlatten && // de-opt if non-style
                !validStyles[key] && !pseudoDescriptors[key] && !(key.startsWith("data-") || key.startsWith("aria-"))
              );
              if (shouldKeepOriginalAttr) {
                if (shouldPrintDebug) {
                  logger.info(["     - keeping as non-style", key].join(" "));
                }
                prev = cur;
                acc.push({
                  type: "attr",
                  value: t.jsxAttribute(
                    t.jsxIdentifier(key),
                    t.jsxExpressionContainer(
                      typeof value === "string" ? t.stringLiteral(value) : literalToAst(value)
                    )
                  )
                });
                acc.push(cur);
                return acc;
              }
              if ((prev == null ? void 0 : prev.type) === "style") {
                mergeStyles2(prev.value, cur.value);
                return acc;
              }
            }
            prev = cur;
            acc.push(cur);
            return acc;
          }, []);
          if (shouldPrintDebug) {
            logger.info(
              [
                "  - attrs (combined \u{1F500}): \n",
                logLines(attrs.map(attrStr).join(", "))
              ].join(" ")
            );
          }
          let getStyleError = null;
          for (const attr of attrs) {
            try {
              if (shouldPrintDebug) {
                console.log(`  Processing ${attr.type}:`);
              }
              switch (attr.type) {
                case "ternary": {
                  const a = getProps(attr.value.alternate, false, "ternary.alternate");
                  const c = getProps(attr.value.consequent, false, "ternary.consequent");
                  if (a)
                    attr.value.alternate = a;
                  if (c)
                    attr.value.consequent = c;
                  if (shouldPrintDebug)
                    logger.info(["     => tern ", attrStr(attr)].join(" "));
                  continue;
                }
                case "style": {
                  const styles = getProps(attr.value, false, "style");
                  if (styles) {
                    attr.value = styles;
                  }
                  if (shouldPrintDebug)
                    logger.info(["  * styles (in)", logLines(objToStr(attr.value))].join(" "));
                  if (shouldPrintDebug)
                    logger.info(["  * styles (out)", logLines(objToStr(styles))].join(" "));
                  continue;
                }
                case "attr": {
                  if (shouldFlatten && t.isJSXAttribute(attr.value)) {
                    const key = attr.value.name.name;
                    if (key === "style" || key === "className" || key === "tag") {
                      continue;
                    }
                    const value = attemptEvalSafe(
                      attr.value.value || t.booleanLiteral(true)
                    );
                    if (value !== FAILED_EVAL) {
                      const outProps = getProps({ [key]: value }, true, `attr.${key}`);
                      const outKey = Object.keys(outProps)[0];
                      if (outKey) {
                        const outVal = outProps[outKey];
                        attr.value = t.jsxAttribute(
                          t.jsxIdentifier(outKey),
                          t.jsxExpressionContainer(
                            typeof outVal === "string" ? t.stringLiteral(outVal) : literalToAst(outVal)
                          )
                        );
                      }
                    }
                  }
                }
              }
            } catch (err) {
              getStyleError = err;
            }
          }
          if (shouldPrintDebug) {
            logger.info(["  - attrs (ternaries/combined):\n", logLines(attrs.map(attrStr).join(", "))].join(" "));
          }
          tm.mark("jsx-element-styles", !!shouldPrintDebug);
          if (getStyleError) {
            logger.info([" \u26A0\uFE0F postprocessing error, deopt", getStyleError].join(" "));
            node.attributes = ogAttributes;
            return null;
          }
          const existingStyleKeys = /* @__PURE__ */ new Set();
          for (let i = attrs.length - 1; i >= 0; i--) {
            const attr = attrs[i];
            if (shouldFlatten) {
              if (attr.type === "attr") {
                if (t.isJSXAttribute(attr.value)) {
                  if (t.isJSXIdentifier(attr.value.name)) {
                    const name = attr.value.name.name;
                    if (INLINE_EXTRACTABLE[name]) {
                      attr.value.name.name = INLINE_EXTRACTABLE[name];
                    }
                  }
                }
              }
            }
            if (attr.type === "style") {
              for (const key in attr.value) {
                if (existingStyleKeys.has(key)) {
                  if (shouldPrintDebug) {
                    logger.info([`  >> delete existing ${key}`].join(" "));
                  }
                  delete attr.value[key];
                } else {
                  existingStyleKeys.add(key);
                }
              }
            }
          }
          if (!shouldFlatten) {
            if (inlineWhenUnflattened.size) {
              for (const [index, attr] of attrs.entries()) {
                if (attr.type === "style") {
                  for (const key in attr.value) {
                    if (!inlineWhenUnflattened.has(key))
                      continue;
                    const val = inlineWhenUnflattenedOGVals[key];
                    if (val) {
                      delete attr.value[key];
                      attrs.splice(index - 1, 0, val.attr);
                    } else {
                      delete attr.value[key];
                    }
                  }
                }
              }
            }
          }
          if (shouldFlatten) {
            if (shouldPrintDebug) {
              logger.info(["  [\u2705] flattening", originalNodeName, flatNode].join(" "));
            }
            node.name.name = flatNode;
            res.flattened++;
            if (closingElement) {
              closingElement.name.name = flatNode;
            }
          }
          const isNativeNotFlat = !shouldFlatten && target === "native";
          if (isNativeNotFlat) {
            if (shouldPrintDebug) {
              logger.info(`Disabled flattening except for simple cases on native for now`);
            }
            node.attributes = ogAttributes;
            return null;
          }
          if (shouldPrintDebug) {
            logger.info([` - inlined props (${inlined.size}):`, shouldDeopt ? " deopted" : "", hasSpread ? " has spread" : "", staticConfig.neverFlatten ? "neverFlatten" : ""].join(" "));
            logger.info(`  - shouldFlatten/isFlattened: ${shouldFlatten}`);
            logger.info(`  - attrs (end):
 ${logLines(attrs.map(attrStr).join(", "))}`);
          }
          onExtractTag({
            parserProps: propsWithFileInfo,
            attrs,
            node,
            lineNumbers,
            filePath,
            config: tamaguiConfig,
            attemptEval,
            jsxPath: traversePath,
            originalNodeName,
            isFlattened: shouldFlatten,
            programPath,
            completeProps,
            staticConfig
          });
        } catch (err) {
          node.attributes = ogAttributes;
          console.error(`@tamagui/static Error: ${err.message} ${err.stack}`);
        } finally {
          if (debugPropValue) {
            shouldPrintDebug = ogDebug;
          }
        }
      }
    });
    tm.mark("jsx-done", !!shouldPrintDebug);
    if (modifiedComponents.size) {
      const all = Array.from(modifiedComponents);
      if (shouldPrintDebug) {
        logger.info(`  [\u{1FA9D}] hook check ${all.length}`);
      }
      for (const comp of all) {
        removeUnusedHooks(comp, shouldPrintDebug);
      }
    }
    tm.done(shouldPrintDebug === "verbose");
    return res;
  }
}
export {
  createExtractor
};
//# sourceMappingURL=createExtractor.js.map
