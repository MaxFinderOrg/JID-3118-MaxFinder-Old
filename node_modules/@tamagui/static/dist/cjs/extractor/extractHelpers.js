"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var extractHelpers_exports = {};
__export(extractHelpers_exports, {
  attrStr: () => attrStr,
  findComponentName: () => findComponentName,
  getValidComponent: () => getValidComponent,
  getValidComponentsPaths: () => getValidComponentsPaths,
  getValidImport: () => getValidImport,
  isComponentPackage: () => isComponentPackage,
  isInsideComponentPackage: () => isInsideComponentPackage,
  isPresent: () => isPresent,
  isSimpleSpread: () => isSimpleSpread,
  isValidImport: () => isValidImport,
  isValidModule: () => isValidModule,
  isValidThemeHook: () => isValidThemeHook,
  objToStr: () => objToStr,
  ternaryStr: () => ternaryStr
});
module.exports = __toCommonJS(extractHelpers_exports);
var import_path = require("path");
var import_generator = __toESM(require("@babel/generator"));
var t = __toESM(require("@babel/types"));
var import_find_root = __toESM(require("find-root"));
var import_memoize = require("../helpers/memoize");
function isPresent(input) {
  return input != null;
}
function isSimpleSpread(node) {
  return t.isIdentifier(node.argument) || t.isMemberExpression(node.argument);
}
const attrStr = (attr) => {
  return !attr ? "" : attr.type === "attr" ? getNameAttr(attr.value) : attr.type === "ternary" ? `...${ternaryStr(attr.value)}` : `${attr.type}(${objToStr(attr.value)})`;
};
const objToStr = (obj, spacer = ", ") => {
  if (!obj) {
    return `${obj}`;
  }
  return `{${Object.entries(obj).map(
    ([k, v]) => `${k}:${Array.isArray(v) ? `[...]` : v && typeof v === "object" ? `${objToStr(v, ",")}` : JSON.stringify(v)}`
  ).join(spacer)}}`;
};
const getNameAttr = (attr) => {
  if (t.isJSXSpreadAttribute(attr)) {
    return `...${attr.argument["name"]}`;
  }
  return "name" in attr ? attr.name.name : `unknown-${attr["type"]}`;
};
const ternaryStr = (x) => {
  const conditional = t.isIdentifier(x.test) ? x.test.name : t.isMemberExpression(x.test) ? [x.test.object["name"], x.test.property["name"]] : (
    // @ts-ignore
    (0, import_generator.default)(x.test).code
  );
  return [
    "ternary(",
    conditional,
    isFilledObj(x.consequent) ? ` ? ${objToStr(x.consequent)}` : " ? \u{1F6AB}",
    isFilledObj(x.alternate) ? ` : ${objToStr(x.alternate)}` : " : \u{1F6AB}",
    ")"
  ].flat().join("");
};
const isFilledObj = (obj) => obj && Object.keys(obj).length;
function findComponentName(scope) {
  var _a;
  const componentName = "";
  let cur = scope.path;
  while (cur.parentPath && !t.isProgram(cur.parentPath.parent)) {
    cur = cur.parentPath;
  }
  let node = cur.parent;
  if (t.isExportNamedDeclaration(node)) {
    node = node.declaration;
  }
  if (t.isVariableDeclaration(node)) {
    const [dec] = node.declarations;
    if (t.isVariableDeclarator(dec) && t.isIdentifier(dec.id)) {
      return dec.id.name;
    }
  }
  if (t.isFunctionDeclaration(node)) {
    return (_a = node.id) == null ? void 0 : _a.name;
  }
  return componentName;
}
function isValidThemeHook(props, jsxPath, n, sourcePath) {
  var _a;
  if (!t.isIdentifier(n.object) || !t.isIdentifier(n.property))
    return false;
  const bindings = jsxPath.scope.getAllBindings();
  const binding = bindings[n.object.name];
  if (!(binding == null ? void 0 : binding.path))
    return false;
  if (!binding.path.isVariableDeclarator())
    return false;
  const init = binding.path.node.init;
  if (!init || !t.isCallExpression(init))
    return false;
  if (!t.isIdentifier(init.callee))
    return false;
  if (init.callee.name !== "useTheme")
    return false;
  const importNode = (_a = binding.scope.getBinding("useTheme")) == null ? void 0 : _a.path.parent;
  if (!t.isImportDeclaration(importNode))
    return false;
  if (sourcePath && !isValidImport(props, sourcePath)) {
    return false;
  }
  return true;
}
const isInsideComponentPackage = (props, moduleName) => {
  return getValidComponentsPaths(props).some((path) => {
    return moduleName.startsWith(path);
  });
};
const isComponentPackage = (props, srcName) => {
  return getValidComponentsPaths(props).some((path) => {
    return srcName.startsWith(path);
  });
};
function getValidComponent(props, moduleName, componentName) {
  if (componentName[0].toUpperCase() !== componentName[0]) {
    return false;
  }
  for (const loaded of props.allLoadedComponents) {
    if (!loaded)
      continue;
    const isInModule = moduleName === "*" || moduleName.startsWith(loaded.moduleName);
    const foundComponent = loaded.nameToInfo[componentName];
    if (isInModule && foundComponent) {
      return foundComponent;
    }
  }
  return null;
}
const isValidModule = (props, moduleName) => {
  if (typeof moduleName !== "string") {
    throw new Error(`No module name`);
  }
  const isLocal = moduleName.startsWith(".");
  return {
    isLocal,
    isValid: isLocal ? isInsideComponentPackage(props, moduleName) : isComponentPackage(props, moduleName)
  };
};
const getValidImport = (props, moduleName, componentName) => {
  const { isValid, isLocal } = isValidModule(props, moduleName);
  if (!isValid || !componentName) {
    return null;
  }
  return getValidComponent(props, isLocal ? "*" : moduleName, componentName) || null;
};
const isValidImport = (props, moduleName, componentName) => {
  if (!componentName) {
    return isValidModule(props, moduleName).isValid;
  }
  return Boolean(getValidImport(props, moduleName, componentName));
};
const getValidComponentPackages = (0, import_memoize.memoize)((props) => {
  return [.../* @__PURE__ */ new Set(["@tamagui/core", "tamagui", ...props.components])];
});
const getValidComponentsPaths = (0, import_memoize.memoize)((props) => {
  return getValidComponentPackages(props).map((pkg) => {
    const root = (0, import_find_root.default)(pkg);
    return (0, import_path.basename)(root);
  });
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  attrStr,
  findComponentName,
  getValidComponent,
  getValidComponentsPaths,
  getValidImport,
  isComponentPackage,
  isInsideComponentPackage,
  isPresent,
  isSimpleSpread,
  isValidImport,
  isValidModule,
  isValidThemeHook,
  objToStr,
  ternaryStr
});
//# sourceMappingURL=extractHelpers.js.map
