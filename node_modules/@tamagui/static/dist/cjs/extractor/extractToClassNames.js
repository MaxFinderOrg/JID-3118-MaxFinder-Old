"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var extractToClassNames_exports = {};
__export(extractToClassNames_exports, {
  extractToClassNames: () => extractToClassNames
});
module.exports = __toCommonJS(extractToClassNames_exports);
var path = __toESM(require("path"));
var import_path = require("path");
var util = __toESM(require("util"));
var import_generator = __toESM(require("@babel/generator"));
var t = __toESM(require("@babel/types"));
var import_core_node = require("@tamagui/core-node");
var import_helpers = require("@tamagui/helpers");
var import_babelParse = require("./babelParse");
var import_buildClassName = require("./buildClassName");
var import_ensureImportingConcat = require("./ensureImportingConcat");
var import_extractHelpers = require("./extractHelpers");
var import_extractMediaStyle = require("./extractMediaStyle");
var import_getPrefixLogs = require("./getPrefixLogs");
var import_hoistClassNames = require("./hoistClassNames");
var import_logLines = require("./logLines");
var import_propsToFontFamilyCache = require("./propsToFontFamilyCache");
var import_timer = require("./timer");
const mergeStyleGroups = {
  shadowOpacity: true,
  shadowRadius: true,
  shadowColor: true,
  shadowOffset: true
};
async function extractToClassNames({
  extractor,
  source,
  sourcePath,
  options,
  shouldPrintDebug
}) {
  const tm = (0, import_timer.timer)();
  if (sourcePath == null ? void 0 : sourcePath.includes("node_modules")) {
    return null;
  }
  if (shouldPrintDebug) {
    console.warn(`--- ${sourcePath} --- 

`);
  }
  if (typeof source !== "string") {
    throw new Error("`source` must be a string of javascript");
  }
  if (sourcePath && !path.isAbsolute(sourcePath)) {
    throw new Error("`sourcePath` must be an absolute path to a .js file");
  }
  if (!/.[tj]sx?$/i.test(sourcePath || "")) {
    console.warn(`${sourcePath == null ? void 0 : sourcePath.slice(0, 100)} - bad filename.`);
  }
  if (!options.disableExtraction) {
    await extractor.loadTamagui(options);
  }
  const shouldLogTiming = options.logTimings ?? true;
  const start = Date.now();
  const mem = process.env.TAMAGUI_SHOW_MEMORY_USAGE && shouldLogTiming ? process.memoryUsage() : null;
  let ast;
  try {
    ast = (0, import_babelParse.babelParse)(source, sourcePath);
  } catch (err) {
    console.error("babel parse error:", sourcePath == null ? void 0 : sourcePath.slice(0, 100));
    throw err;
  }
  tm.mark(`babel-parse`, shouldPrintDebug === "verbose");
  const cssMap = /* @__PURE__ */ new Map();
  const existingHoists = {};
  let hasFlattened = false;
  const res = await extractor.parse(ast, {
    shouldPrintDebug,
    ...options,
    sourcePath,
    target: "html",
    extractStyledDefinitions: true,
    onStyleRule(identifier, rules) {
      const css = rules.join(";");
      if (shouldPrintDebug) {
        console.log(`adding styled() rule: .${identifier} ${css}`);
      }
      cssMap.set(`.${identifier}`, { css, commentTexts: [] });
    },
    getFlattenedNode: ({ tag }) => {
      hasFlattened = true;
      return tag;
    },
    onExtractTag: ({
      parserProps,
      attrs,
      node,
      attemptEval,
      jsxPath,
      originalNodeName,
      filePath,
      lineNumbers,
      programPath,
      isFlattened,
      config,
      completeProps,
      staticConfig
    }) => {
      var _a;
      if (staticConfig.acceptsClassName === false) {
        if (shouldPrintDebug) {
          console.log(`bail, acceptsClassName is false`);
        }
        return;
      }
      const didFlattenThisTag = hasFlattened;
      hasFlattened = false;
      let finalClassNames = [];
      const finalAttrs = [];
      let finalStyles = [];
      let viewStyles = {};
      for (const attr of attrs) {
        if (attr.type === "style") {
          viewStyles = {
            ...viewStyles,
            ...attr.value
          };
        }
      }
      const ensureNeededPrevStyle = (style) => {
        const keys = Object.keys(style);
        if (!keys.some((key) => mergeStyleGroups[key])) {
          return style;
        }
        for (const k in mergeStyleGroups) {
          if (k in viewStyles) {
            style[k] = style[k] ?? viewStyles[k];
          }
        }
        return style;
      };
      const addStyles = (style) => {
        if (!style)
          return [];
        const styleWithPrev = ensureNeededPrevStyle(style);
        const res2 = (0, import_core_node.getStylesAtomic)(styleWithPrev);
        if (res2.length) {
          finalStyles = [...finalStyles, ...res2];
        }
        return res2;
      };
      let lastMediaImportance = 1;
      for (const attr of attrs) {
        switch (attr.type) {
          case "style": {
            if (!isFlattened) {
              const styles2 = (0, import_core_node.getStylesAtomic)(attr.value);
              finalStyles = [...finalStyles, ...styles2];
              for (const style of styles2) {
                const prop = style.pseudo ? `${style.property}-${style.pseudo}` : style.property;
                finalAttrs.push(
                  t.jsxAttribute(t.jsxIdentifier(prop), t.stringLiteral(style.identifier))
                );
              }
            } else {
              const styles2 = addStyles(attr.value);
              const newFontFamily = (0, import_propsToFontFamilyCache.getFontFamilyClassNameFromProps)(attr.value) || "";
              const newClassNames = (0, import_helpers.concatClassName)(
                styles2.map((x) => x.identifier).join(" ") + newFontFamily
              );
              const existing = finalClassNames.find(
                (x) => x.type == "StringLiteral"
              );
              if (existing) {
                let previous = existing.value;
                if (newFontFamily) {
                  if (shouldPrintDebug) {
                    console.log(` newFontFamily: ${newFontFamily}`);
                  }
                  previous = previous.replace(/font_[a-z]+/i, "");
                }
                existing.value = `${previous} ${newClassNames}`;
              } else {
                finalClassNames = [...finalClassNames, t.stringLiteral(newClassNames)];
              }
            }
            break;
          }
          case "attr": {
            const val = attr.value;
            if (t.isJSXSpreadAttribute(val)) {
              if ((0, import_extractHelpers.isSimpleSpread)(val)) {
                finalClassNames.push(
                  t.logicalExpression(
                    "&&",
                    val.argument,
                    t.memberExpression(val.argument, t.identifier("className"))
                  )
                );
              }
            } else if (val.name.name === "className") {
              const value = val.value;
              if (value) {
                try {
                  const evaluatedValue = attemptEval(value);
                  finalClassNames.push(t.stringLiteral(evaluatedValue));
                } catch (e) {
                  finalClassNames.push(value["expression"]);
                }
              }
              continue;
            }
            finalAttrs.push(val);
            break;
          }
          case "ternary": {
            const mediaExtraction = (0, import_extractMediaStyle.extractMediaStyle)(
              parserProps,
              attr.value,
              jsxPath,
              extractor.getTamagui(),
              sourcePath || "",
              lastMediaImportance,
              shouldPrintDebug
            );
            if (shouldPrintDebug) {
              if (mediaExtraction) {
                console.log(
                  "ternary (mediaStyles)",
                  ((_a = mediaExtraction.ternaryWithoutMedia) == null ? void 0 : _a.inlineMediaQuery) ?? "",
                  mediaExtraction.mediaStyles.map((x) => x.identifier).join(".")
                );
              }
            }
            if (!mediaExtraction) {
              addTernaryStyle(
                attr.value,
                addStyles(attr.value.consequent),
                addStyles(attr.value.alternate)
              );
              continue;
            }
            lastMediaImportance++;
            if (mediaExtraction.mediaStyles) {
              finalStyles = [...finalStyles, ...mediaExtraction.mediaStyles];
            }
            if (mediaExtraction.ternaryWithoutMedia) {
              addTernaryStyle(
                mediaExtraction.ternaryWithoutMedia,
                mediaExtraction.mediaStyles,
                []
              );
            } else {
              finalClassNames = [
                ...finalClassNames,
                ...mediaExtraction.mediaStyles.map((x) => t.stringLiteral(x.identifier))
              ];
            }
            break;
          }
        }
      }
      function addTernaryStyle(ternary, a, b) {
        const cCN = a.map((x) => x.identifier).join(" ");
        const aCN = b.map((x) => x.identifier).join(" ");
        if (a.length && b.length) {
          finalClassNames.push(
            t.conditionalExpression(
              ternary.test,
              t.stringLiteral(cCN),
              t.stringLiteral(aCN)
            )
          );
        } else {
          finalClassNames.push(
            t.conditionalExpression(
              ternary.test,
              t.stringLiteral(" " + cCN),
              t.stringLiteral(" " + aCN)
            )
          );
        }
      }
      if (shouldPrintDebug) {
        console.log(
          "  finalClassNames\n",
          (0, import_logLines.logLines)(finalClassNames.map((x) => x["value"]).join(" "))
        );
      }
      node.attributes = finalAttrs;
      if (finalClassNames.length) {
        const extraClassNames = (() => {
          let value = "";
          if (!isFlattened) {
            return value;
          }
          if (process.env.TAMAGUI_DEBUG_OPTIMIZATIONS) {
            value += `is_tamagui_flattened`;
          }
          if (staticConfig.componentName) {
            value += ` is_${staticConfig.componentName}`;
          }
          return value;
        })();
        const names = (0, import_buildClassName.buildClassName)(finalClassNames, extraClassNames);
        const nameExpr = names ? (0, import_hoistClassNames.hoistClassNames)(jsxPath, existingHoists, names) : null;
        let expr = nameExpr;
        if (nameExpr && !t.isIdentifier(nameExpr)) {
          if (!didFlattenThisTag) {
          } else {
            (0, import_ensureImportingConcat.ensureImportingConcat)(programPath);
            const simpleSpreads = attrs.filter(
              (x) => t.isJSXSpreadAttribute(x.value) && (0, import_extractHelpers.isSimpleSpread)(x.value)
            );
            expr = t.callExpression(t.identifier("concatClassName"), [
              expr,
              ...simpleSpreads.map((val) => val.value["argument"])
            ]);
          }
        }
        node.attributes.push(
          t.jsxAttribute(t.jsxIdentifier("className"), t.jsxExpressionContainer(expr))
        );
      }
      const comment = util.format(
        "/* %s:%s (%s) */",
        filePath,
        lineNumbers,
        originalNodeName
      );
      for (const { identifier, rules } of finalStyles) {
        const className = `.${identifier}`;
        if (cssMap.has(className)) {
          if (comment) {
            const val = cssMap.get(className);
            val.commentTexts.push(comment);
            cssMap.set(className, val);
          }
        } else if (rules.length) {
          cssMap.set(className, {
            css: rules.join("\n"),
            commentTexts: [comment]
          });
        }
      }
    }
  });
  if (!res || !res.modified && !res.optimized && !res.flattened && !res.styled) {
    if (shouldPrintDebug) {
      console.log("no res or none modified", res);
    }
    return null;
  }
  const styles = Array.from(cssMap.values()).map((x) => x.css).join("\n").trim();
  const result = (0, import_generator.default)(
    ast,
    {
      concise: false,
      filename: sourcePath,
      // this makes the debug output terrible, and i think sourcemap works already
      retainLines: false,
      sourceFileName: sourcePath,
      sourceMaps: true
    },
    source
  );
  if (shouldPrintDebug) {
    console.log(
      "\n -------- output code ------- \n\n",
      result.code.split("\n").filter((x) => !x.startsWith("//")).join("\n")
    );
    console.log("\n -------- output style -------- \n\n", styles);
  }
  if (shouldLogTiming) {
    const memUsed = mem ? Math.round((process.memoryUsage().heapUsed - mem.heapUsed) / 1024 / 1204 * 10) / 10 : 0;
    const path2 = (0, import_path.basename)(sourcePath || "").replace(/\.[jt]sx?$/, "").slice(0, 22).trim().padStart(24);
    const numStyled = `${res.styled}`.padStart(3);
    const numOptimized = `${res.optimized}`.padStart(3);
    const numFound = `${res.found}`.padStart(3);
    const numFlattened = `${res.flattened}`.padStart(3);
    const memory = memUsed ? ` ${memUsed}MB` : "";
    const timing = Date.now() - start;
    const timingStr = `${timing}ms`.padStart(6);
    const pre = (0, import_getPrefixLogs.getPrefixLogs)(options);
    const memStr = memory ? `(${memory})` : "";
    console.log(
      `${pre} ${path2}  ${numFound} \xB7 ${numOptimized} \xB7 ${numFlattened} \xB7 ${numStyled}  ${timingStr} ${memStr}`
    );
  }
  return {
    ast,
    styles,
    js: result.code,
    map: result.map
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  extractToClassNames
});
//# sourceMappingURL=extractToClassNames.js.map
