"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bundleConfig_exports = {};
__export(bundleConfig_exports, {
  bundleConfig: () => bundleConfig,
  esbuildOptions: () => esbuildOptions,
  getBundledConfig: () => getBundledConfig,
  hasBundledConfigChanged: () => hasBundledConfigChanged,
  loadComponents: () => loadComponents
});
module.exports = __toCommonJS(bundleConfig_exports);
var import_fs = require("fs");
var import_path = require("path");
var import_generator = __toESM(require("@babel/generator"));
var import_traverse = __toESM(require("@babel/traverse"));
var t = __toESM(require("@babel/types"));
var import_cli_color = require("@tamagui/cli-color");
var import_esbuild = __toESM(require("esbuild"));
var import_fs_extra = require("fs-extra");
var import_require = require("../require");
var import_babelParse = require("./babelParse");
var import_bundle = require("./bundle");
var import_getTamaguiConfigPathFromOptionsConfig = require("./getTamaguiConfigPathFromOptionsConfig");
const external = [
  "@tamagui/core",
  "@tamagui/web",
  "@tamagui/core-node",
  "react",
  "react-dom",
  "react-native-svg"
];
const esbuildExtraOptions = {
  define: {
    __DEV__: `${process.env.NODE_ENV === "development"}`
  }
};
const esbuildOptions = {
  target: "es2018",
  format: "cjs",
  jsx: "transform",
  platform: "node",
  ...esbuildExtraOptions
};
let currentBundle = null;
let isBundling = false;
let lastBundle = null;
const waitForBundle = /* @__PURE__ */ new Set();
function hasBundledConfigChanged() {
  if (lastBundle === currentBundle) {
    return false;
  }
  lastBundle = currentBundle;
  return true;
}
async function getBundledConfig(props, rebuild = false) {
  if (isBundling) {
    await new Promise((res) => {
      waitForBundle.add(res);
    });
  } else if (!currentBundle || rebuild) {
    return await bundleConfig(props);
  }
  return currentBundle;
}
async function bundleConfig(props) {
  var _a, _b, _c, _d;
  try {
    isBundling = true;
    const configEntry = props.config ? (0, import_getTamaguiConfigPathFromOptionsConfig.getTamaguiConfigPathFromOptionsConfig)(props.config) : "";
    const tmpDir = (0, import_path.join)(process.cwd(), ".tamagui");
    const configOutPath = (0, import_path.join)(tmpDir, `tamagui.config.cjs`);
    const baseComponents = props.components.filter((x) => x !== "@tamagui/core");
    const componentOutPaths = baseComponents.map(
      (componentModule) => (0, import_path.join)(
        tmpDir,
        `${componentModule.split(import_path.sep).join("-").replace(/[^a-z0-9]+/gi, "")}-components.config.cjs`
      )
    );
    if (process.env.NODE_ENV === "development" && ((_a = process.env.DEBUG) == null ? void 0 : _a.startsWith("tamagui"))) {
      console.log(`Building config entry`, configEntry);
    }
    try {
      await (0, import_fs_extra.ensureDir)(tmpDir);
    } catch {
    }
    const start = Date.now();
    await Promise.all([
      props.config ? (0, import_bundle.bundle)({
        entryPoints: [configEntry],
        external,
        outfile: configOutPath,
        target: "node16",
        ...esbuildExtraOptions
      }) : null,
      ...baseComponents.map((componentModule, i) => {
        return (0, import_bundle.bundle)({
          entryPoints: [componentModule],
          resolvePlatformSpecificEntries: true,
          external,
          outfile: componentOutPaths[i],
          target: "node16",
          ...esbuildExtraOptions
        });
      })
    ]);
    (0, import_cli_color.colorLog)(
      import_cli_color.Color.FgYellow,
      `
    \u27A1 [tamagui] (${Date.now() - start}ms):`
    );
    (0, import_cli_color.colorLog)(
      import_cli_color.Color.Dim,
      `
        Config     .${import_path.sep}${(0, import_path.relative)(process.cwd(), configOutPath)}
        Components ${[
        ...componentOutPaths.map((p) => `.${import_path.sep}${(0, import_path.relative)(process.cwd(), p)}`)
      ].join("\n             ")}
        `
    );
    let out;
    const unregisterTamagui = (0, import_require.registerRequire)();
    try {
      out = require(configOutPath);
    } catch (err) {
      throw err;
    } finally {
      unregisterTamagui();
    }
    const config = out.default || out;
    if (!config) {
      throw new Error(`No config: ${config}`);
    }
    let components = loadComponents({
      ...props,
      components: componentOutPaths
    });
    if (!components) {
      throw new Error(`No components found: ${componentOutPaths.join(", ")}`);
    }
    for (const component of components) {
      component.moduleName = baseComponents[componentOutPaths.indexOf(component.moduleName)];
      if (!component.moduleName) {
        if (((_b = process.env.DEBUG) == null ? void 0 : _b.includes("tamagui")) || process.env.IS_TAMAGUI_DEV) {
          console.warn(
            `\u26A0\uFE0F no module name found: ${component.moduleName} ${JSON.stringify(
              baseComponents
            )} in ${JSON.stringify(componentOutPaths)}`
          );
        }
      }
    }
    const coreComponents = loadComponents({
      ...props,
      components: ["@tamagui/core-node"]
    });
    if (coreComponents) {
      coreComponents[0].moduleName = "@tamagui/core";
      components = [...components, ...coreComponents];
    }
    if (process.env.NODE_ENV === "development" && ((_c = process.env.DEBUG) == null ? void 0 : _c.startsWith("tamagui"))) {
      console.log("Loaded components", components);
    }
    const res = {
      components,
      nameToPaths: {},
      tamaguiConfig: config
    };
    currentBundle = res;
    return res;
  } catch (err) {
    console.error(
      `Error bundling tamagui config: ${err == null ? void 0 : err.message} (run with DEBUG=tamagui to see stack)`
    );
    if ((_d = process.env.DEBUG) == null ? void 0 : _d.includes("tamagui")) {
      console.error(err.stack);
    }
  } finally {
    isBundling = false;
    waitForBundle.forEach((cb) => cb());
    waitForBundle.clear();
  }
}
function loadComponents(props) {
  const componentsModules = props.components;
  const key = componentsModules.join("");
  if (cacheComponents[key]) {
    return cacheComponents[key];
  }
  const unregister = (0, import_require.registerRequire)();
  try {
    const info = componentsModules.flatMap((name) => {
      var _a;
      const extension = (0, import_path.extname)(name);
      const isLocal = Boolean(extension);
      const isDynamic = isLocal && !props.config;
      if (isDynamic && !process.env.TAMAGUI_ENABLE_DYNAMIC_LOAD) {
        return [];
      }
      const fileContents = isDynamic ? (0, import_fs.readFileSync)(name, "utf-8") : "";
      const loadModule = isDynamic ? (0, import_path.join)((0, import_path.dirname)(name), `.tamagui-dynamic-eval-${(0, import_path.basename)(name)}.tsx`) : name;
      let writtenContents = fileContents;
      let didBabel = false;
      function attemptLoad({ forceExports = false } = {}) {
        if (isDynamic) {
          writtenContents = forceExports ? esbuildit(
            transformAddExports((0, import_babelParse.babelParse)(esbuildit(fileContents, "modern"), name))
          ) : esbuildit(fileContents);
          (0, import_fs_extra.writeFileSync)(loadModule, writtenContents);
        }
        if (process.env.DEBUG === "tamagui") {
          console.log(`loadModule`, loadModule, require.resolve(loadModule));
        }
        const nameToInfo = getComponentStaticConfigByName(
          name,
          interopDefaultExport(require(loadModule))
        );
        return {
          moduleName: name,
          nameToInfo
        };
      }
      const dispose = () => {
        isDynamic && (0, import_fs_extra.removeSync)(loadModule);
      };
      try {
        const res = attemptLoad({
          forceExports: true
        });
        didBabel = true;
        return res;
      } catch (err) {
        console.log("babel err", err, writtenContents);
        writtenContents = fileContents;
        if ((_a = process.env.DEBUG) == null ? void 0 : _a.startsWith("tamagui")) {
          console.log(`Error parsing babel likely`, err);
        }
      } finally {
        dispose();
      }
      try {
        return attemptLoad({
          forceExports: false
        });
      } catch (err) {
        if (!process.env.TAMAGUI_DISABLE_WARN_DYNAMIC_LOAD) {
          console.log(`

Tamagui attempted but failed to dynamically load components in:
  ${name}

This will leave some styled() tags unoptimized.
Disable this file (or dynamic loading altogether):

  disableExtractFoundComponents: ['${name}'] | true

Quiet this warning with environment variable:
      
  TAMAGUI_DISABLE_WARN_DYNAMIC_LOAD=1

`);
          console.log(err);
          console.log(
            `At: ${loadModule}`,
            `
didBabel: ${didBabel}`,
            `
In:`,
            writtenContents,
            `
isDynamic: `,
            isDynamic
          );
        }
        return [];
      } finally {
        dispose();
      }
    });
    cacheComponents[key] = info;
    return info;
  } catch (err) {
    console.log(`Tamagui error bundling components`, err.message, err.stack);
    return null;
  } finally {
    unregister();
  }
}
const esbuildit = (src, target) => {
  return import_esbuild.default.transformSync(src, {
    ...esbuildOptions,
    ...target === "modern" && {
      target: "es2022",
      jsx: "transform",
      loader: "tsx",
      platform: "neutral",
      format: "esm"
    }
  }).code;
};
function getComponentStaticConfigByName(name, exported) {
  const components = {};
  try {
    if (!exported || typeof exported !== "object" || Array.isArray(exported)) {
      throw new Error(`Invalid export from package ${name}: ${typeof exported}`);
    }
    for (const key in exported) {
      const found = getTamaguiComponent(key, exported[key]);
      if (found) {
        const { Component, ...sc } = found.staticConfig;
        components[key] = { staticConfig: sc };
      }
    }
  } catch (err) {
    if (process.env.TAMAGUI_DISABLE_WARN_DYNAMIC_LOAD !== "1") {
      console.error(
        `Tamagui failed getting from ${name} (Disable error by setting environment variable TAMAGUI_DISABLE_WARN_DYNAMIC_LOAD=1)`
      );
      console.error(err);
    }
  }
  return components;
}
function getTamaguiComponent(name, Component) {
  if (name[0].toUpperCase() !== name[0]) {
    return;
  }
  const staticConfig = Component == null ? void 0 : Component.staticConfig;
  if (staticConfig) {
    return Component;
  }
}
function interopDefaultExport(mod) {
  return (mod == null ? void 0 : mod.default) ?? mod;
}
const cacheComponents = {};
function transformAddExports(ast) {
  const usedNames = /* @__PURE__ */ new Set();
  (0, import_traverse.default)(ast, {
    ExportNamedDeclaration(nodePath) {
      if (nodePath.node.specifiers) {
        for (const spec of nodePath.node.specifiers) {
          usedNames.add(
            t.isIdentifier(spec.exported) ? spec.exported.name : spec.exported.value
          );
        }
      }
    }
  });
  (0, import_traverse.default)(ast, {
    VariableDeclaration(nodePath) {
      if (!t.isProgram(nodePath.parent))
        return;
      const decs = nodePath.node.declarations;
      if (decs.length > 1)
        return;
      const [dec] = decs;
      if (!t.isIdentifier(dec.id))
        return;
      if (!dec.init)
        return;
      if (usedNames.has(dec.id.name))
        return;
      usedNames.add(dec.id.name);
      nodePath.replaceWith(
        t.exportNamedDeclaration(t.variableDeclaration("let", [dec]), [
          t.exportSpecifier(t.identifier(dec.id.name), t.identifier(dec.id.name))
        ])
      );
    }
  });
  return (0, import_generator.default)(ast, {
    concise: false,
    filename: "test.tsx",
    retainLines: false,
    sourceMaps: false
  }).code;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  bundleConfig,
  esbuildOptions,
  getBundledConfig,
  hasBundledConfigChanged,
  loadComponents
});
//# sourceMappingURL=bundleConfig.js.map
