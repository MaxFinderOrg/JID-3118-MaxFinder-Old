"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bundle_exports = {};
__export(bundle_exports, {
  bundle: () => bundle,
  bundleSync: () => bundleSync
});
module.exports = __toCommonJS(bundle_exports);
var import_path = require("path");
var import_esbuild = __toESM(require("esbuild"));
var import_fs_extra = require("fs-extra");
var import_loadTamagui = require("./loadTamagui");
function getESBuildConfig({ entryPoints, resolvePlatformSpecificEntries, ...options }, aliases) {
  var _a;
  const alias = require("@tamagui/core-node").aliasPlugin;
  if ((_a = process.env.DEBUG) == null ? void 0 : _a.startsWith("tamagui")) {
    console.log(`Building`, entryPoints);
  }
  const tsconfig = (0, import_path.join)(__dirname, "..", "..", "..", "tamagui.tsconfig.json");
  const resolvedEntryPoints = !resolvePlatformSpecificEntries ? entryPoints : entryPoints.map(import_loadTamagui.resolveWebOrNativeSpecificEntry);
  const res = {
    bundle: true,
    entryPoints: resolvedEntryPoints,
    format: "cjs",
    target: "node16",
    jsx: "transform",
    jsxFactory: "react",
    allowOverwrite: true,
    keepNames: true,
    resolveExtensions: [
      ...process.env.TAMAGUI_TARGET === "web" ? [".web.tsx", ".web.ts", ".web.jsx", ".web.js"] : [".native.tsx", ".native.ts", ".native.jsx", ".native.js"],
      ".tsx",
      ".ts",
      ".jsx",
      ".js"
    ],
    platform: "node",
    tsconfig,
    loader: {
      ".js": "jsx",
      ".png": "dataurl",
      ".jpg": "dataurl",
      ".jpeg": "dataurl",
      ".svg": "dataurl",
      ".gif": "dataurl",
      ".webp": "dataurl",
      ".woff2": "dataurl",
      ".woff": "dataurl",
      ".eot": "dataurl",
      ".otf": "dataurl",
      ".ttf": "dataurl"
    },
    logLevel: "warning",
    plugins: [
      {
        name: "external",
        setup(build) {
          build.onResolve({ filter: /@tamagui\/core/ }, (args) => {
            return {
              path: "@tamagui/core-node",
              external: true
            };
          });
          build.onResolve({ filter: /react-native\/package.json$/ }, (args) => {
            return {
              path: "react-native/package.json",
              external: true
            };
          });
          build.onResolve({ filter: /@tamagui\/web/ }, (args) => {
            return {
              path: "@tamagui/core-node",
              external: true
            };
          });
          build.onResolve({ filter: /^(react-native|react-native\/.*)$/ }, (args) => {
            return {
              path: "react-native-web-lite",
              external: true
            };
          });
        }
      },
      alias({
        ...aliases
      })
    ],
    ...options
  };
  return res;
}
async function bundle(props, aliases) {
  await asyncLock(props);
  const config = getESBuildConfig(props, aliases);
  return import_esbuild.default.build(config);
}
function bundleSync(props, aliases) {
  return import_esbuild.default.buildSync(getESBuildConfig(props, aliases));
}
async function asyncLock(props) {
  var _a;
  const lockFile = (0, import_path.join)((0, import_path.dirname)(props.outfile), (0, import_path.basename)(props.outfile, ".lock"));
  const lockStat = await (0, import_fs_extra.stat)(lockFile).catch(() => {
  });
  const lockedMsAgo = !lockStat ? Infinity : (/* @__PURE__ */ new Date()).getTime() - new Date(lockStat.mtime).getTime();
  if (lockedMsAgo < 500) {
    if ((_a = process.env.DEBUG) == null ? void 0 : _a.startsWith("tamagui")) {
      console.log(`Waiting for existing build`, props.entryPoints);
    }
    let tries = 5;
    while (tries--) {
      if (await (0, import_fs_extra.pathExists)(props.outfile)) {
        return;
      } else {
        await new Promise((res) => setTimeout(res, 50));
      }
    }
  }
  void (0, import_fs_extra.writeFile)(lockFile, "");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  bundle,
  bundleSync
});
//# sourceMappingURL=bundle.js.map
