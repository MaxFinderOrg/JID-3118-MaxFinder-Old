import { useResponderEvents } from "@tamagui/react-native-use-responder-events";
import {
  Stack as WebStack,
  Text as WebText,
  composeEventHandlers,
  setupHooks
} from "@tamagui/web";
import { getBaseViews } from "./getBaseViews";
import { useElementLayout } from "./hooks/useElementLayout";
import { usePlatformMethods } from "./hooks/usePlatformMethods";
import { usePressability } from "./vendor/Pressability";
export * from "@tamagui/web";
export * from "./reactNativeTypes";
const Stack = WebStack;
const Text = WebText;
setupHooks({
  getBaseViews,
  usePropsTransform(elementType, propsIn, hostRef) {
    const {
      // event props
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture,
      // android
      collapsable,
      focusable,
      // deprecated,
      accessible,
      accessibilityDisabled,
      onLayout,
      hrefAttrs,
      ...viewProps
    } = propsIn;
    usePlatformMethods(hostRef);
    useElementLayout(hostRef, onLayout);
    useResponderEvents(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    if (viewProps.href !== void 0 && hrefAttrs !== void 0) {
      const { download, rel, target } = hrefAttrs;
      if (download != null) {
        viewProps.download = download;
      }
      if (rel != null) {
        viewProps.rel = rel;
      }
      if (typeof target === "string") {
        viewProps.target = target.charAt(0) !== "_" ? `_${target}` : target;
      }
    }
    return viewProps;
  },
  useEvents(viewProps, events, { pseudos }, setStateShallow) {
    if (process.env.TAMAGUI_TARGET === "native") {
      const attachFocus = !!(pseudos == null ? void 0 : pseudos.focusStyle);
      if (attachFocus) {
        viewProps.onFocus = composeEventHandlers(viewProps.onFocus, () => {
          setStateShallow({ focus: true });
        });
        viewProps.onBlur = composeEventHandlers(viewProps.onBlur, () => {
          setStateShallow({ focus: false });
        });
      }
      if (events && viewProps.hitSlop) {
        events.hitSlop = viewProps.hitSlop;
      }
      const pressability = usePressability(events || null);
      if (events) {
        if (events.onPress) {
          for (const key in pressability) {
            const og = viewProps[key];
            const val = pressability[key];
            viewProps[key] = og && !dontComposePressabilityKeys[key] ? composeEventHandlers(og, val) : val;
          }
        }
      }
    }
  }
});
const dontComposePressabilityKeys = {
  onClick: true
};
export {
  Stack,
  Text
};
//# sourceMappingURL=index.js.map
